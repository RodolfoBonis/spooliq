
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RodolfoBonis/spooliq/app/fx.go (0.0%)</option>
				
				<option value="file1">github.com/RodolfoBonis/spooliq/app/hooks.go (0.0%)</option>
				
				<option value="file2">github.com/RodolfoBonis/spooliq/app/init.go (0.0%)</option>
				
				<option value="file3">github.com/RodolfoBonis/spooliq/core/config/app_config.go (0.0%)</option>
				
				<option value="file4">github.com/RodolfoBonis/spooliq/core/config/environment.go (9.3%)</option>
				
				<option value="file5">github.com/RodolfoBonis/spooliq/core/config/sentry.go (0.0%)</option>
				
				<option value="file6">github.com/RodolfoBonis/spooliq/core/config/zap.go (0.0%)</option>
				
				<option value="file7">github.com/RodolfoBonis/spooliq/core/errors/app-error.go (0.0%)</option>
				
				<option value="file8">github.com/RodolfoBonis/spooliq/core/errors/http-error.go (0.0%)</option>
				
				<option value="file9">github.com/RodolfoBonis/spooliq/core/errors/messages.go (0.0%)</option>
				
				<option value="file10">github.com/RodolfoBonis/spooliq/core/health/health_check.go (0.0%)</option>
				
				<option value="file11">github.com/RodolfoBonis/spooliq/core/logger/body.go (0.0%)</option>
				
				<option value="file12">github.com/RodolfoBonis/spooliq/core/logger/body_log_writer.go (0.0%)</option>
				
				<option value="file13">github.com/RodolfoBonis/spooliq/core/logger/logger.go (52.4%)</option>
				
				<option value="file14">github.com/RodolfoBonis/spooliq/core/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file15">github.com/RodolfoBonis/spooliq/core/middlewares/cache_middleware.go (0.0%)</option>
				
				<option value="file16">github.com/RodolfoBonis/spooliq/core/middlewares/cors_middleware.go (0.0%)</option>
				
				<option value="file17">github.com/RodolfoBonis/spooliq/core/middlewares/monitoring_middleware.go (0.0%)</option>
				
				<option value="file18">github.com/RodolfoBonis/spooliq/core/services/amqp_service.go (0.0%)</option>
				
				<option value="file19">github.com/RodolfoBonis/spooliq/core/services/auth_service.go (0.0%)</option>
				
				<option value="file20">github.com/RodolfoBonis/spooliq/core/services/database_service.go (0.0%)</option>
				
				<option value="file21">github.com/RodolfoBonis/spooliq/core/services/fx.go (0.0%)</option>
				
				<option value="file22">github.com/RodolfoBonis/spooliq/core/services/redis_service.go (0.0%)</option>
				
				<option value="file23">github.com/RodolfoBonis/spooliq/core/services/seeds_service.go (0.0%)</option>
				
				<option value="file24">github.com/RodolfoBonis/spooliq/core/types/array_type.go (0.0%)</option>
				
				<option value="file25">github.com/RodolfoBonis/spooliq/core/types/stacktrace_type.go (0.0%)</option>
				
				<option value="file26">github.com/RodolfoBonis/spooliq/docs/docs.go (0.0%)</option>
				
				<option value="file27">github.com/RodolfoBonis/spooliq/features/auth/auth_route.go (0.0%)</option>
				
				<option value="file28">github.com/RodolfoBonis/spooliq/features/auth/di/auth_di.go (0.0%)</option>
				
				<option value="file29">github.com/RodolfoBonis/spooliq/features/auth/domain/entities/register_entities.go (0.0%)</option>
				
				<option value="file30">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/forgot_password_uc.go (0.0%)</option>
				
				<option value="file31">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/login_uc.go (0.0%)</option>
				
				<option value="file32">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/logout_uc.go (0.0%)</option>
				
				<option value="file33">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/refresh_uc.go (0.0%)</option>
				
				<option value="file34">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/register_uc.go (0.0%)</option>
				
				<option value="file35">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/usecase.go (0.0%)</option>
				
				<option value="file36">github.com/RodolfoBonis/spooliq/features/auth/domain/usecases/validate_token_uc.go (0.0%)</option>
				
				<option value="file37">github.com/RodolfoBonis/spooliq/features/calculation/domain/entities/cost_breakdown_entity.go (90.3%)</option>
				
				<option value="file38">github.com/RodolfoBonis/spooliq/features/calculation/domain/services/calculation_service.go (86.0%)</option>
				
				<option value="file39">github.com/RodolfoBonis/spooliq/features/export/data/services/csv_export_service.go (0.0%)</option>
				
				<option value="file40">github.com/RodolfoBonis/spooliq/features/export/data/services/json_export_service.go (0.0%)</option>
				
				<option value="file41">github.com/RodolfoBonis/spooliq/features/export/data/services/pdf_export_service.go (0.0%)</option>
				
				<option value="file42">github.com/RodolfoBonis/spooliq/features/export/di/export_di.go (0.0%)</option>
				
				<option value="file43">github.com/RodolfoBonis/spooliq/features/export/domain/entities/export_entity.go (0.0%)</option>
				
				<option value="file44">github.com/RodolfoBonis/spooliq/features/export/domain/services/export_service_impl.go (0.0%)</option>
				
				<option value="file45">github.com/RodolfoBonis/spooliq/features/export/presentation/handlers/export_handler.go (0.0%)</option>
				
				<option value="file46">github.com/RodolfoBonis/spooliq/features/filaments/data/repositories/filament_repository_impl.go (0.0%)</option>
				
				<option value="file47">github.com/RodolfoBonis/spooliq/features/filaments/di/filaments_di.go (0.0%)</option>
				
				<option value="file48">github.com/RodolfoBonis/spooliq/features/filaments/domain/entities/filament_entity.go (0.0%)</option>
				
				<option value="file49">github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases/filament_usecase.go (0.0%)</option>
				
				<option value="file50">github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases/filament_usecase_impl.go (0.0%)</option>
				
				<option value="file51">github.com/RodolfoBonis/spooliq/features/filaments/filaments_route.go (0.0%)</option>
				
				<option value="file52">github.com/RodolfoBonis/spooliq/features/presets/data/repositories/preset_repository_impl.go (0.0%)</option>
				
				<option value="file53">github.com/RodolfoBonis/spooliq/features/presets/data/services/preset_service_impl.go (0.0%)</option>
				
				<option value="file54">github.com/RodolfoBonis/spooliq/features/presets/di/preset_di.go (0.0%)</option>
				
				<option value="file55">github.com/RodolfoBonis/spooliq/features/presets/domain/entities/preset_entity.go (0.0%)</option>
				
				<option value="file56">github.com/RodolfoBonis/spooliq/features/presets/presentation/dto/preset_dto.go (0.0%)</option>
				
				<option value="file57">github.com/RodolfoBonis/spooliq/features/presets/presentation/handlers/preset_handler.go (0.0%)</option>
				
				<option value="file58">github.com/RodolfoBonis/spooliq/features/quotes/data/mappers/quote_mapper.go (0.0%)</option>
				
				<option value="file59">github.com/RodolfoBonis/spooliq/features/quotes/data/models/quote_model.go (0.0%)</option>
				
				<option value="file60">github.com/RodolfoBonis/spooliq/features/quotes/data/repositories/quote_repository_impl.go (0.0%)</option>
				
				<option value="file61">github.com/RodolfoBonis/spooliq/features/quotes/di/quote_di.go (0.0%)</option>
				
				<option value="file62">github.com/RodolfoBonis/spooliq/features/quotes/domain/entities/quote.go (0.0%)</option>
				
				<option value="file63">github.com/RodolfoBonis/spooliq/features/quotes/domain/services/snapshot_service.go (0.0%)</option>
				
				<option value="file64">github.com/RodolfoBonis/spooliq/features/quotes/domain/usecases/quote_usecase_impl.go (0.0%)</option>
				
				<option value="file65">github.com/RodolfoBonis/spooliq/features/quotes/presentation/dto/quote_dto.go (0.0%)</option>
				
				<option value="file66">github.com/RodolfoBonis/spooliq/features/quotes/presentation/handlers/quote_handler.go (0.0%)</option>
				
				<option value="file67">github.com/RodolfoBonis/spooliq/features/system/data/services/gpu/linux_detector.go (0.0%)</option>
				
				<option value="file68">github.com/RodolfoBonis/spooliq/features/system/data/services/gpu/macos_detector.go (0.0%)</option>
				
				<option value="file69">github.com/RodolfoBonis/spooliq/features/system/data/services/gpu/nvidia_detector.go (0.0%)</option>
				
				<option value="file70">github.com/RodolfoBonis/spooliq/features/system/data/services/gpu/service.go (0.0%)</option>
				
				<option value="file71">github.com/RodolfoBonis/spooliq/features/system/data/services/gpu/windows_detector.go (0.0%)</option>
				
				<option value="file72">github.com/RodolfoBonis/spooliq/features/system/data/services/system.service.go (0.0%)</option>
				
				<option value="file73">github.com/RodolfoBonis/spooliq/features/system/di/system_di.go (0.0%)</option>
				
				<option value="file74">github.com/RodolfoBonis/spooliq/features/system/domain/usecases/system.uc.go (0.0%)</option>
				
				<option value="file75">github.com/RodolfoBonis/spooliq/features/system/domain/usecases/usecase.go (0.0%)</option>
				
				<option value="file76">github.com/RodolfoBonis/spooliq/features/system/system_route.go (0.0%)</option>
				
				<option value="file77">github.com/RodolfoBonis/spooliq/features/users/data/repositories/keycloak_user_repository.go (0.0%)</option>
				
				<option value="file78">github.com/RodolfoBonis/spooliq/features/users/data/services/user_service_impl.go (0.0%)</option>
				
				<option value="file79">github.com/RodolfoBonis/spooliq/features/users/di/user_di.go (0.0%)</option>
				
				<option value="file80">github.com/RodolfoBonis/spooliq/features/users/domain/entities/user_entity.go (0.0%)</option>
				
				<option value="file81">github.com/RodolfoBonis/spooliq/features/users/presentation/dto/user_dto.go (0.0%)</option>
				
				<option value="file82">github.com/RodolfoBonis/spooliq/features/users/presentation/handlers/user_handler.go (0.0%)</option>
				
				<option value="file83">github.com/RodolfoBonis/spooliq/main.go (0.0%)</option>
				
				<option value="file84">github.com/RodolfoBonis/spooliq/routes/router.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/middlewares"
        "github.com/RodolfoBonis/spooliq/core/services"
        "github.com/RodolfoBonis/spooliq/features/auth/di"
        auth_uc "github.com/RodolfoBonis/spooliq/features/auth/domain/usecases"
        exportdi "github.com/RodolfoBonis/spooliq/features/export/di"
        filamentsdi "github.com/RodolfoBonis/spooliq/features/filaments/di"
        filaments_uc "github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases"
        presetsdi "github.com/RodolfoBonis/spooliq/features/presets/di"
        quotesdi "github.com/RodolfoBonis/spooliq/features/quotes/di"
        systemdi "github.com/RodolfoBonis/spooliq/features/system/di"
        system_uc "github.com/RodolfoBonis/spooliq/features/system/domain/usecases"
        usersdi "github.com/RodolfoBonis/spooliq/features/users/di"
        "github.com/RodolfoBonis/spooliq/routes"
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"
)

// NewFxApp cria e retorna uma nova instância da aplicação Fx.
func NewFxApp() *fx.App <span class="cov0" title="0">{
        return fx.New(
                logger.Module,
                config.Module,
                services.Module,
                middlewares.Module,
                di.AuthModule,
                systemdi.SystemModule,
                filamentsdi.FilamentsModule,
                quotesdi.QuotesModule,
                exportdi.Module,
                usersdi.Module,
                presetsdi.Module,
                fx.Provide(
                        gin.New,
                ),
                fx.Invoke(
                        func(lc fx.Lifecycle, router *gin.Engine, systemUc system_uc.SystemUseCase, authUc auth_uc.AuthUseCase, filamentsUc filaments_uc.FilamentUseCase, monitoring *middlewares.MonitoringMiddleware, cacheMiddleware *middlewares.CacheMiddleware, redisService *services.RedisService, protectFactory func(handler gin.HandlerFunc, role string) gin.HandlerFunc, logger logger.Logger) </span><span class="cov0" title="0">{
                                // Initialize Redis connection
                                if err := redisService.Init(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(nil, "Failed to initialize Redis", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                }</span>

                                <span class="cov0" title="0">routes.InitializeRoutes(router, systemUc, authUc, filamentsUc, protectFactory, cacheMiddleware, logger)
                                RegisterHooks(lc, router, logger, monitoring)
                                _ = services.OpenConnection(logger)</span>
                        },
                ),
                // Incluir as migrações e seeds do init.go
                InitAndRun(),
        )
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "context"
        "fmt"
        "net/http"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/middlewares"
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"
)

// RegisterHooks registers application lifecycle hooks.
func RegisterHooks(lifecycle fx.Lifecycle, router *gin.Engine, logger logger.Logger, monitoring *middlewares.MonitoringMiddleware) <span class="cov0" title="0">{
        lifecycle.Append(
                fx.Hook{
                        OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                                err := router.SetTrustedProxies([]string{})
                                if err != nil </span><span class="cov0" title="0">{
                                        appError := errors.RootError(err.Error(), nil)
                                        logger.LogError(ctx, "Erro ao configurar trusted proxies", appError)
                                        panic(err)</span>
                                }
                                <span class="cov0" title="0">config.SentryConfig()
                                router.Use(monitoring.SentryMiddleware())
                                router.Use(monitoring.LogMiddleware)
                                router.Use(gin.Logger())
                                router.Use(gin.Recovery())
                                router.Use(gin.ErrorLogger())
                                runPort := fmt.Sprintf(":%s", config.EnvPort())
                                go func() </span><span class="cov0" title="0">{
                                        err = router.Run(runPort)
                                        if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                                appError := errors.RootError(err.Error(), nil)
                                                logger.LogError(ctx, "Erro ao subir servidor HTTP", appError)
                                                panic(err)</span>
                                        }
                                }()
                                <span class="cov0" title="0">return nil</span>
                        },
                        OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                                logger.Info(ctx, "Stopping server.")
                                return nil
                        }</span>,
                },
        )
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/services"
        "github.com/RodolfoBonis/spooliq/docs"
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"
)

func InitAndRun() fx.Option <span class="cov0" title="0">{
        return fx.Invoke(func(lc fx.Lifecycle, cfg *config.AppConfig, amqpService *services.AmqpService, app *gin.Engine, log logger.Logger) </span><span class="cov0" title="0">{
                lc.Append(fx.Hook{
                        OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                                // Initialize database connection
                                services.OpenConnection(log)
                                log.Info(ctx, "💿 Database connected successfully")

                                // Run database migrations
                                services.RunMigrations()
                                log.Info(ctx, "📊 Database migrations completed")

                                // Run seeds
                                services.RunSeeds(log)
                                log.Info(ctx, "🌱 Database seeds completed")

                                // Try to initialize AMQP connection (optional)
                                _, err := amqpService.StartAmqpConnection()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(ctx, "⚠️  RabbitMQ not available - continuing without AMQP messaging", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        log.Info(ctx, "🔗 AMQP connected successfully")
                                }</span>

                                // setup the swagger info
                                <span class="cov0" title="0">if cfg.Environment == entities.Environment.Development </span><span class="cov0" title="0">{
                                        docs.SwaggerInfo.Host = "localhost:" + cfg.Port
                                }</span> else<span class="cov0" title="0"> {
                                        docs.SwaggerInfo.Host = "spooliq.RodolfoBonis.com"
                                }</span>

                                <span class="cov0" title="0">docs.SwaggerInfo.BasePath = "/api/v1"
                                docs.SwaggerInfo.Schemes = []string{"http", "https"}
                                docs.SwaggerInfo.Title = "spooliq"
                                docs.SwaggerInfo.Description = "SpoolIq calcula o preço real das suas impressões 3D: filamento multi-cor (g/m), energia (kWh + bandeira), desgaste, overhead e mão-de-obra. Gera pacotes (só impressão, ajustes, modelagem), exporta PDF/CSV e guarda materiais."
                                docs.SwaggerInfo.Version = "1.0"

                                host := cfg.Environment
                                if cfg.Environment == entities.Environment.Development </span><span class="cov0" title="0">{
                                        host = "localhost"
                                }</span> else<span class="cov0" title="0"> {
                                        host = "spooliq.RodolfoBonis.com"
                                }</span>

                                <span class="cov0" title="0">docs.SwaggerInfo.Host = host + ":" + cfg.Port

                                // Run the Gin server
                                go app.Run(":" + cfg.Port)

                                return nil</span>
                        },
                        OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                                log.Info(ctx, "🛑 Shutting down gracefully")
                                return nil
                        }</span>,
                })
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "github.com/RodolfoBonis/spooliq/core/entities"
        "go.uber.org/fx"
)

// AppConfig holds the application configuration.
type AppConfig struct {
        Port     string
        Keycloak entities.KeyCloakDataEntity
        // ServiceID is the unique identifier for the service.
        ServiceID      string
        SentryDSN      string
        DBHost         string
        DBPort         string
        DBUser         string
        DBPassword     string
        DBName         string
        Environment    string
        ServiceName    string
        AmqpConnection string
        RedisHost      string
        RedisPort      string
        RedisPassword  string
        RedisDB        int
}

// NewAppConfig creates and returns a new AppConfig instance.
func NewAppConfig() *AppConfig <span class="cov0" title="0">{
        return &amp;AppConfig{
                Port:           EnvPort(),
                Keycloak:       EnvKeyCloak(),
                ServiceID:      EnvServiceID(),
                SentryDSN:      EnvSentryDSN(),
                DBHost:         EnvDBHost(),
                DBPort:         EnvDBPort(),
                DBUser:         EnvDBUser(),
                DBPassword:     EnvDBPassword(),
                DBName:         EnvDBName(),
                Environment:    EnvironmentConfig(),
                ServiceName:    EnvServiceName(),
                AmqpConnection: EnvAmqpConnection(),
                RedisHost:      EnvRedisHost(),
                RedisPort:      EnvRedisPort(),
                RedisPassword:  EnvRedisPassword(),
                RedisDB:        EnvRedisDB(),
        }
}</span>

// Module provides the fx module for AppConfig.
var Module = fx.Module("config", fx.Provide(NewAppConfig))
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"

        "github.com/RodolfoBonis/spooliq/core/entities"

        "github.com/joho/godotenv"
)

// GetEnv retrieves the value of the specified environment variable.
func GetEnv(key, defaultValue string) string <span class="cov8" title="1">{
        value := os.Getenv(key)

        if value != "" </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov8" title="1">return defaultValue</span>
}

// EnvPort returns the port from environment variables.
func EnvPort() string <span class="cov0" title="0">{
        return GetEnv("PORT", "8000")
}</span>

// EnvKeyCloak returns the Keycloak configuration from environment variables.
func EnvKeyCloak() entities.KeyCloakDataEntity <span class="cov0" title="0">{
        return entities.KeyCloakDataEntity{
                ClientID:     GetEnv("CLIENT_ID", ""),
                ClientSecret: GetEnv("CLIENT_SECRET", ""),
                Realm:        GetEnv("REALM", ""),
                Host:         GetEnv("KEYCLOAK_HOST", ""),
        }
}</span>

// EnvServiceID retrieves the service ID from the environment variables.
// If not set, tries to derive from the module name automatically.
func EnvServiceID() string <span class="cov0" title="0">{
        return GetEnv("SERVICE_ID", "")
}</span>

// EnvSentryDSN returns the Sentry DSN from environment variables.
func EnvSentryDSN() string <span class="cov0" title="0">{
        return GetEnv("SENTRY_DSN", "")
}</span>

// EnvDBHost returns the database host from environment variables.
func EnvDBHost() string <span class="cov0" title="0">{
        return GetEnv("DB_HOST", "localhost")
}</span>

// EnvDBPort returns the database port from environment variables.
func EnvDBPort() string <span class="cov0" title="0">{
        return GetEnv("DB_PORT", "5432")
}</span>

// EnvDBUser returns the database user from environment variables.
func EnvDBUser() string <span class="cov0" title="0">{
        return GetEnv("DB_USER", "user")
}</span>

// EnvDBPassword returns the database password from environment variables.
func EnvDBPassword() string <span class="cov0" title="0">{
        return GetEnv("DB_SECRET", "password")
}</span>

// EnvDBName returns the database name from environment variables.
func EnvDBName() string <span class="cov0" title="0">{
        return GetEnv("DB_NAME", "spooliq_db")
}</span>

// EnvDBDriver returns the database driver from environment variables.
func EnvDBDriver() string <span class="cov0" title="0">{
        return GetEnv("DB_DRIVER", "postgres")
}</span>

// EnvDBSQLitePath returns the SQLite database path from environment variables.
func EnvDBSQLitePath() string <span class="cov0" title="0">{
        return GetEnv("DB_SQLITE_PATH", "./spooliq.db")
}</span>

// EnvRedisHost returns the Redis host from environment variables.
func EnvRedisHost() string <span class="cov0" title="0">{
        return GetEnv("REDIS_HOST", "localhost")
}</span>

// EnvRedisPort returns the Redis port from environment variables.
func EnvRedisPort() string <span class="cov0" title="0">{
        return GetEnv("REDIS_PORT", "6379")
}</span>

// EnvRedisPassword returns the Redis password from environment variables.
func EnvRedisPassword() string <span class="cov0" title="0">{
        return GetEnv("REDIS_PASSWORD", "")
}</span>

// EnvRedisDB returns the Redis database number from environment variables.
func EnvRedisDB() int <span class="cov0" title="0">{
        dbStr := GetEnv("REDIS_DB", "0")
        db, err := strconv.Atoi(dbStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return db</span>
}

// EnvironmentConfig returns the environment configuration.
func EnvironmentConfig() string <span class="cov8" title="1">{
        return GetEnv("ENV", "development")
}</span>

// EnvServiceName returns the service name from environment variables.
func EnvServiceName() string <span class="cov0" title="0">{
        return GetEnv("SERVICE_NAME", "spooliq")
}</span>

func envUserAmqp() string <span class="cov0" title="0">{
        return GetEnv("USER_AMQP", "guest")
}</span>

func envPasswordAmqp() string <span class="cov0" title="0">{
        return GetEnv("PASSWORD_AMQP", "guest")
}</span>

func envHostAmqp() string <span class="cov0" title="0">{
        return GetEnv("HOST_AMQP", "localhost:5672")
}</span>

// EnvAmqpConnection returns the AMQP connection string from environment variables.
func EnvAmqpConnection() string <span class="cov0" title="0">{
        user := envUserAmqp()
        password := envPasswordAmqp()
        host := envHostAmqp()

        return fmt.Sprintf("amqp://%s:%s@%s/", user, password, host)
}</span>

// LoadEnvVars loads all environment variables required by the application.
func LoadEnvVars() <span class="cov0" title="0">{
        env := EnvironmentConfig()
        if env == entities.Environment.Production || env == entities.Environment.Staging </span><span class="cov0" title="0">{
                fmt.Printf("Not using .env file in production or staging")
                return
        }</span>

        <span class="cov0" title="0">filename := fmt.Sprintf(".env.%s", env)

        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                filename = ".env"
        }</span>

        <span class="cov0" title="0">err := godotenv.Load(filename)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf(".env file not loaded")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"

        "github.com/getsentry/sentry-go"
)

// SentryConfig returns the Sentry configuration for the application.
func SentryConfig() <span class="cov0" title="0">{
        if err := sentry.Init(sentry.ClientOptions{
                Dsn:              EnvSentryDSN(),
                EnableTracing:    true,
                TracesSampleRate: 1.0,
        }); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Sentry initialization failed: %v\n", err)
                // Don't exit on Sentry failure, just log and continue
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// ZapConfig returns the zap logger configuration.
func ZapConfig() *zap.Logger <span class="cov0" title="0">{
        core := zapcore.NewCore(
                zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),
                zapcore.AddSync(os.Stdout),
                zap.InfoLevel,
        )

        return zap.New(core, zap.AddCaller(), zap.AddStacktrace(zap.ErrorLevel))
}</span>

// ZapTestConfig returns the zap logger configuration for tests.
func ZapTestConfig() *zap.Logger <span class="cov0" title="0">{
        logger, err := zap.NewProduction()

        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">return logger</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

import (
        "net/http"

        "github.com/RodolfoBonis/spooliq/core/entities"
)

// Error is the base interface for all custom errors in the system.
type Error interface {
        error
        Code() int
        Message() string
        StackTrace() string
        Context() map[string]interface{}
        Unwrap() error
        ToLogFields() map[string]interface{}
        ToHTTPError() *HTTPError
}

// AppError representa um erro de aplicação padronizado.
type AppError struct {
        Type    entities.AppErrorType
        Message string
        Fields  map[string]interface{}
        Cause   error
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// HTTPStatus returns the HTTP status code for the AppError.
func (e *AppError) HTTPStatus() int <span class="cov0" title="0">{
        if status, ok := entities.AppErrorTypeToHTTP[e.Type]; ok </span><span class="cov0" title="0">{
                return status
        }</span>
        <span class="cov0" title="0">return http.StatusInternalServerError</span>
}

// NewAppError cria um novo erro padronizado.
func NewAppError(errType entities.AppErrorType, msg string, fields map[string]interface{}, cause error) *AppError <span class="cov0" title="0">{
        if msg == "" </span><span class="cov0" title="0">{
                msg = entities.AppErrorTypeToString[errType]
        }</span>
        <span class="cov0" title="0">return &amp;AppError{
                Type:    errType,
                Message: msg,
                Fields:  fields,
                Cause:   cause,
        }</span>
}

// ToLogFields returns a map with all error details for structured logging.
func (e *AppError) ToLogFields() map[string]interface{} <span class="cov0" title="0">{
        fields := map[string]interface{}{
                "error_code":    e.Type,
                "error_message": e.Message,
        }
        for k, v := range e.Fields </span><span class="cov0" title="0">{
                fields[k] = v
        }</span>
        <span class="cov0" title="0">if e.Cause != nil </span><span class="cov0" title="0">{
                fields["cause"] = e.Cause.Error()
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// ToHTTPError converts an AppError to an HTTP error.
func (e *AppError) ToHTTPError() *HTTPError <span class="cov0" title="0">{
        return NewHTTPError(e.HTTPStatus(), e.Message)
}</span>

// EntityError creates a new entity error.
func EntityError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrEntity, message, ctx[0], nil)
}</span>

// EnvironmentError creates a new environment error.
func EnvironmentError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrEnvironment, message, ctx[0], nil)
}</span>

// MiddlewareError creates a new middleware error.
func MiddlewareError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrMiddleware, message, ctx[0], nil)
}</span>

// ModelError creates a new model error.
func ModelError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrModel, message, ctx[0], nil)
}</span>

// RepositoryError creates a new repository error.
func RepositoryError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrRepository, message, ctx[0], nil)
}</span>

// RootError creates a new root error.
func RootError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrRoot, message, ctx[0], nil)
}</span>

// ServiceError creates a new service error.
func ServiceError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrService, message, ctx[0], nil)
}</span>

// UsecaseError creates a new use case error.
func UsecaseError(message string, ctx ...map[string]interface{}) *AppError <span class="cov0" title="0">{
        return NewAppError(entities.ErrUsecase, message, ctx[0], nil)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package errors

// HTTPError represents an HTTP error.
type HTTPError struct {
        StatusCode int                    `json:"code"`
        Message    string                 `json:"message"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Context    map[string]interface{} `json:"context,omitempty"`
        Cause      string                 `json:"cause,omitempty"`
}

// NewHTTPError creates a new HttpError with status, message and optional stack/context.
func NewHTTPError(statusCode int, message string, stack ...string) *HTTPError <span class="cov0" title="0">{
        h := &amp;HTTPError{
                StatusCode: statusCode,
                Message:    message,
        }
        if len(stack) &gt; 0 </span><span class="cov0" title="0">{
                h.StackTrace = stack[0]
        }</span>
        <span class="cov0" title="0">return h</span>
}

// FromAppError creates a HttpError from an AppError.
func FromAppError(err *AppError) *HTTPError <span class="cov0" title="0">{
        return &amp;HTTPError{
                StatusCode: err.HTTPStatus(),
                Message:    err.Message,
                Context:    err.Fields,
                Cause:      unwrapCause(err.Cause),
        }
}</span>

// ToMap returns a map for structured logging.
func (e *HTTPError) ToMap() map[string]interface{} <span class="cov0" title="0">{
        fields := map[string]interface{}{
                "code":    e.StatusCode,
                "message": e.Message,
        }
        if e.StackTrace != "" </span><span class="cov0" title="0">{
                fields["stack_trace"] = e.StackTrace
        }</span>
        <span class="cov0" title="0">if e.Context != nil </span><span class="cov0" title="0">{
                fields["context"] = e.Context
        }</span>
        <span class="cov0" title="0">if e.Cause != "" </span><span class="cov0" title="0">{
                fields["cause"] = e.Cause
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Helper to unwrap cause from error chain.
func unwrapCause(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if u, ok := err.(interface{ Unwrap() error }); ok </span><span class="cov0" title="0">{
                if cause := u.Unwrap(); cause != nil </span><span class="cov0" title="0">{
                        return cause.Error()
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package errors

// ErrorMessages contém todas as mensagens de erro padronizadas em português
var ErrorMessages = struct {
        // Validação
        InvalidRequestFormat string
        ValidationFailed     string
        InvalidID           string

        // Autenticação
        UserNotAuthenticated string
        AccessDenied        string

        // Filamentos
        FilamentNotFound       string
        FailedToCreateFilament string
        FailedToUpdateFilament string
        FailedToDeleteFilament string
        FailedToGetFilaments   string
        FailedToGetUserFilaments string
        FailedToGetGlobalFilaments string

        // Orçamentos
        QuoteNotFound         string
        FailedToCreateQuote   string
        FailedToUpdateQuote   string
        FailedToDeleteQuote   string
        FailedToGetQuotes     string
        FailedToDuplicateQuote string
        FailedToCalculateQuote string
}{
        // Validação
        InvalidRequestFormat: "Formato de requisição inválido",
        ValidationFailed:     "Falha na validação dos dados",
        InvalidID:           "ID inválido",

        // Autenticação
        UserNotAuthenticated: "Usuário não autenticado",
        AccessDenied:        "Acesso negado",

        // Filamentos
        FilamentNotFound:       "Filamento não encontrado",
        FailedToCreateFilament: "Falha ao criar filamento",
        FailedToUpdateFilament: "Falha ao atualizar filamento",
        FailedToDeleteFilament: "Falha ao excluir filamento",
        FailedToGetFilaments:   "Falha ao buscar filamentos",
        FailedToGetUserFilaments: "Falha ao buscar filamentos do usuário",
        FailedToGetGlobalFilaments: "Falha ao buscar filamentos globais",

        // Orçamentos
        QuoteNotFound:         "Orçamento não encontrado",
        FailedToCreateQuote:   "Falha ao criar orçamento",
        FailedToUpdateQuote:   "Falha ao atualizar orçamento",
        FailedToDeleteQuote:   "Falha ao excluir orçamento",
        FailedToGetQuotes:     "Falha ao buscar orçamentos",
        FailedToDuplicateQuote: "Falha ao duplicar orçamento",
        FailedToCalculateQuote: "Falha ao calcular orçamento",
}

// Helper functions para criar responses padronizadas
func ErrorResponse(message string, details ...string) map[string]interface{} <span class="cov0" title="0">{
        response := map[string]interface{}{
                "error": message,
        }

        if len(details) &gt; 0 &amp;&amp; details[0] != "" </span><span class="cov0" title="0">{
                response["details"] = details[0]
        }</span>

        <span class="cov0" title="0">return response</span>
}

func ValidationErrorResponse(details string) map[string]interface{} <span class="cov0" title="0">{
        return ErrorResponse(ErrorMessages.ValidationFailed, details)
}</span>

func InvalidRequestResponse(details string) map[string]interface{} <span class="cov0" title="0">{
        return ErrorResponse(ErrorMessages.InvalidRequestFormat, details)
}</pre>
		
		<pre class="file" id="file10" style="display: none">package health

import (
        "net/http"

        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/gin-gonic/gin"
)

// Routes registers the health check routes for the application.
func Routes(route *gin.RouterGroup, logger logger.Logger) <span class="cov0" title="0">{
        route.GET("/health_check", func(context *gin.Context) </span><span class="cov0" title="0">{
                logger.Info(context.Request.Context(), "Health check accessed")
                context.String(http.StatusOK, "This Service is Healthy")
        }</span>)
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logger

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"

        "github.com/gin-gonic/gin"
)

var sensitiveFields = []string{"password", "token", "secret"}

func isDevelopment() bool <span class="cov0" title="0">{
        return os.Getenv("ENV") == "development" || os.Getenv("ENV") == "dev"
}</span>

func maskSensitiveFields(body string) string <span class="cov0" title="0">{
        var data map[string]interface{}
        if err := json.Unmarshal([]byte(body), &amp;data); err == nil </span><span class="cov0" title="0">{
                for _, field := range sensitiveFields </span><span class="cov0" title="0">{
                        if _, ok := data[field]; ok </span><span class="cov0" title="0">{
                                data[field] = "***MASKED***"
                        }</span>
                }
                <span class="cov0" title="0">if masked, err := json.Marshal(data); err == nil </span><span class="cov0" title="0">{
                        return string(masked)
                }</span>
        }
        <span class="cov0" title="0">return body</span>
}

// HandleRequestBody processes the request body for logging.
func HandleRequestBody(req *http.Request) string <span class="cov0" title="0">{
        if !isDevelopment() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var requestBodyBytes []byte
        if req.Body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">requestBodyBytes, _ = io.ReadAll(req.Body)
        if len(requestBodyBytes) &gt; 2048 </span><span class="cov0" title="0">{
                requestBodyBytes = requestBodyBytes[:2048]
        }</span>
        <span class="cov0" title="0">req.Body = io.NopCloser(bytes.NewBuffer(requestBodyBytes))
        return maskSensitiveFields(string(requestBodyBytes))</span>
}

// HandleResponseBody processes the response body for logging.
func HandleResponseBody(rw gin.ResponseWriter) *BodyLogWriter <span class="cov0" title="0">{
        return &amp;BodyLogWriter{Body: bytes.NewBufferString(""), ResponseWriter: rw}
}</span>

// FormatRequestAndResponse formats the request and response for logging.
func FormatRequestAndResponse(rw gin.ResponseWriter, req *http.Request, responseBody string, requestID string, requestBody string) string <span class="cov0" title="0">{
        if req.URL.String() == "/metrics" || strings.Contains(req.URL.String(), "/docs") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if !isDevelopment() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(requestBody) &gt; 2048 </span><span class="cov0" title="0">{
                requestBody = requestBody[:2048] + "..."
        }</span>
        <span class="cov0" title="0">if len(responseBody) &gt; 2048 </span><span class="cov0" title="0">{
                responseBody = responseBody[:2048] + "..."
        }</span>
        <span class="cov0" title="0">requestBody = maskSensitiveFields(requestBody)
        responseBody = maskSensitiveFields(responseBody)
        return fmt.Sprintf("[Request ID: %s], Status: [%d], Method: [%s], Url: %s Request Body: %s, Response Body: %s",
                requestID, rw.Status(), req.Method, req.URL.String(), requestBody, responseBody)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package logger

import (
        "bytes"

        "github.com/gin-gonic/gin"
)

// BodyLogWriter is a custom writer for logging HTTP body content.
type BodyLogWriter struct {
        gin.ResponseWriter
        Body *bytes.Buffer
}

func (w BodyLogWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.Body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package logger

import (
        "context"
        "os"
        "time"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "go.uber.org/fx"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Fields represents structured log fields.
type Fields map[string]interface{}

// Logger is a robust, structured logger interface for the whole system.
type Logger interface {
        Debug(ctx context.Context, message string, fields ...Fields)
        Info(ctx context.Context, message string, fields ...Fields)
        Warning(ctx context.Context, message string, fields ...Fields)
        Error(ctx context.Context, message string, fields ...Fields)
        Fatal(ctx context.Context, message string, fields ...Fields)
        Panic(ctx context.Context, message string, fields ...Fields)
        With(fields Fields) Logger
        LogError(ctx context.Context, message string, err error)
}

// CustomLogger is a zap-based implementation of Logger.
type CustomLogger struct {
        logger *zap.Logger
}

// LogData encapsula os dados do log.
type LogData struct {
        Level   string                 `json:"level"`
        Message string                 `json:"message"`
        Time    time.Time              `json:"time"`
        JSON    map[string]interface{} `json:"json,omitempty"`
}

// NewLogger creates a new robust logger instance for fx DI.
func NewLogger() Logger <span class="cov8" title="1">{
        var zapLogger *zap.Logger
        var cfg zap.Config
        if config.EnvironmentConfig() == entities.Environment.Development </span><span class="cov8" title="1">{
                cfg = zap.NewDevelopmentConfig()
        }</span> else<span class="cov0" title="0"> {
                cfg = zap.NewProductionConfig()
        }</span>
        // Dynamic log level from env
        <span class="cov8" title="1">if lvl := os.Getenv("LOG_LEVEL"); lvl != "" </span><span class="cov0" title="0">{
                if level, err := zapcore.ParseLevel(lvl); err == nil </span><span class="cov0" title="0">{
                        cfg.Level = zap.NewAtomicLevelAt(level)
                }</span>
        }
        <span class="cov8" title="1">cfg.EncoderConfig.TimeKey = "time"
        cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        zapLogger, _ = cfg.Build(
                zap.AddStacktrace(zapcore.ErrorLevel),
                zap.AddCaller(),
                zap.AddCallerSkip(1),
        )
        return &amp;CustomLogger{logger: zapLogger}</span>
}

// Debug logs a debug message.
func (cl *CustomLogger) Debug(ctx context.Context, message string, fields ...Fields) <span class="cov0" title="0">{
        cl.logger.Debug(message, cl.zapFields(ctx, fields...)...)
}</span>

// Info logs an info message.
func (cl *CustomLogger) Info(ctx context.Context, message string, fields ...Fields) <span class="cov8" title="1">{
        cl.logger.Info(message, cl.zapFields(ctx, fields...)...)
}</span>

// Warning logs a warning message.
func (cl *CustomLogger) Warning(ctx context.Context, message string, fields ...Fields) <span class="cov0" title="0">{
        cl.logger.Warn(message, cl.zapFields(ctx, fields...)...)
}</span>

// Error logs an error message.
func (cl *CustomLogger) Error(ctx context.Context, message string, fields ...Fields) <span class="cov0" title="0">{
        cl.logger.Error(message, cl.zapFields(ctx, fields...)...)
}</span>

// Fatal logs a fatal message.
func (cl *CustomLogger) Fatal(ctx context.Context, message string, fields ...Fields) <span class="cov0" title="0">{
        cl.logger.Fatal(message, cl.zapFields(ctx, fields...)...)
}</span>

// Panic logs a panic message.
func (cl *CustomLogger) Panic(ctx context.Context, message string, fields ...Fields) <span class="cov0" title="0">{
        cl.logger.Panic(message, cl.zapFields(ctx, fields...)...)
}</span>

// With returns a logger with additional fields.
func (cl *CustomLogger) With(fields Fields) Logger <span class="cov0" title="0">{
        return &amp;CustomLogger{logger: cl.logger.With(cl.fieldsToZap(fields)...)}
}</span>

// zapFields merges context and custom fields for structured logging.
func (cl *CustomLogger) zapFields(ctx context.Context, fields ...Fields) []zap.Field <span class="cov8" title="1">{
        var allFields = map[string]interface{}{}
        for _, f := range fields </span><span class="cov8" title="1">{
                for k, v := range f </span><span class="cov8" title="1">{
                        allFields[k] = v
                }</span>
        }
        // Add requestID from context if present
        <span class="cov8" title="1">if ctx != nil </span><span class="cov8" title="1">{
                if reqID, ok := ctx.Value("requestID").(string); ok &amp;&amp; reqID != "" </span><span class="cov0" title="0">{
                        allFields["requestID"] = reqID
                }</span>
                <span class="cov8" title="1">if ip, ok := ctx.Value("ip").(string); ok &amp;&amp; ip != "" </span><span class="cov0" title="0">{
                        allFields["ip"] = ip
                }</span>
        }
        <span class="cov8" title="1">return cl.fieldsToZap(allFields)</span>
}

func (cl *CustomLogger) fieldsToZap(fields Fields) []zap.Field <span class="cov8" title="1">{
        zfs := make([]zap.Field, 0, len(fields))
        for k, v := range fields </span><span class="cov8" title="1">{
                zfs = append(zfs, zap.Any(k, v))
        }</span>
        <span class="cov8" title="1">return zfs</span>
}

// Module provides the fx module for CustomLogger.
var Module = fx.Module("logger", fx.Provide(NewLogger))

// LogError logs any error in a structured way, extracting stacktrace/context if available.
func (cl *CustomLogger) LogError(ctx context.Context, message string, err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Create a logger with additional caller skip for LogError method
        <span class="cov0" title="0">loggerWithSkip := cl.logger.WithOptions(zap.AddCallerSkip(0))
        
        var fields map[string]interface{}
        if appErr, ok := err.(interface{ ToLogFields() map[string]interface{} }); ok </span><span class="cov0" title="0">{
                fields = appErr.ToLogFields()
        }</span> else<span class="cov0" title="0"> {
                fields = map[string]interface{}{
                        "error": err.Error(),
                }
        }</span>
        
        // Add context fields to error fields
        <span class="cov0" title="0">zapFields := cl.zapFields(ctx, fields)
        loggerWithSkip.Error(message, zapFields...)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middlewares

import (
        "encoding/json"
        "strings"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/services"
        "github.com/gin-gonic/gin"

        jsonToken "github.com/golang-jwt/jwt/v4"
)

// NewProtectMiddleware creates a new authentication middleware.
func NewProtectMiddleware(logger logger.Logger, authService *services.AuthService) func(handler gin.HandlerFunc, role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(handler gin.HandlerFunc, role string) gin.HandlerFunc </span><span class="cov0" title="0">{
                return func(c *gin.Context) </span><span class="cov0" title="0">{
                        ctx := c.Request.Context()
                        requestID, _ := c.Get("requestID")
                        keycloakDataAccess := config.EnvKeyCloak()
                        authHeader := c.GetHeader("Authorization")

                        if len(authHeader) &lt; 1 </span><span class="cov0" title="0">{
                                err := errors.NewAppError(entities.ErrInvalidToken, "Token ausente", nil, nil)
                                httpError := err.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: missing token", err)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">accessToken := strings.Split(authHeader, " ")[1]

                        rptResult, err := authService.GetClient().RetrospectToken(
                                c,
                                accessToken,
                                keycloakDataAccess.ClientID,
                                keycloakDataAccess.ClientSecret,
                                keycloakDataAccess.Realm,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrMiddleware, err.Error(), nil, err)
                                httpError := appError.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: token introspection error", appError)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">isTokenValid := *rptResult.Active

                        if !isTokenValid </span><span class="cov0" title="0">{
                                err := errors.NewAppError(entities.ErrInvalidToken, "Token inválido", nil, nil)
                                httpError := err.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: token invalid", err)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">token, _, err := authService.GetClient().DecodeAccessToken(
                                c,
                                accessToken,
                                keycloakDataAccess.Realm,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrMiddleware, err.Error(), nil, err)
                                httpError := appError.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: decode token error", appError)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">claims := token.Claims.(jsonToken.MapClaims)

                        jsonData, _ := json.Marshal(claims)

                        var userClaim entities.JWTClaim

                        err = json.Unmarshal(jsonData, &amp;userClaim)
                        if err != nil </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrMiddleware, err.Error(), nil, err)
                                httpError := appError.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: unmarshal claims error", appError)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">keyCloakData := config.EnvKeyCloak()
                        client := userClaim.ResourceAccess[keyCloakData.ClientID].(map[string]interface{})
                        rolesBytes, _ := json.Marshal(client["roles"])
                        err = json.Unmarshal(rolesBytes, &amp;userClaim.Roles)
                        if err != nil </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrMiddleware, err.Error(), nil, err)
                                httpError := appError.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: unmarshal roles error", appError)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">containsRole := userClaim.Roles.Contains(role)

                        if !containsRole </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrUnauthorized, "Perfil de acesso necessário ausente", nil, nil)
                                httpError := appError.ToHTTPError()
                                logger.LogError(ctx, "Auth failed: missing required role", appError)
                                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">logger.Info(ctx, "Auth success", map[string]interface{}{
                                "request_id": requestID,
                                "ip":         c.ClientIP(),
                                "role":       role,
                                "user_roles": userClaim.Roles,
                                "user_id":    userClaim.ID,
                                "email":      userClaim.Email,
                        })

                        // Set claims and individual user data for easy access
                        c.Set("claims", userClaim)
                        c.Set("user_id", userClaim.ID.String())
                        c.Set("user_email", userClaim.Email)
                        c.Set("user_role", role)
                        c.Set("user_roles", userClaim.Roles)
                        
                        handler(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middlewares

import (
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/services"
        "github.com/gin-gonic/gin"
)

// CacheConfig holds cache configuration for an endpoint.
type CacheConfig struct {
        TTL          time.Duration // Time to live
        KeyPrefix    string        // Prefix for cache keys
        VaryByUser   bool          // Include user ID in cache key
        VaryByQuery  bool          // Include query parameters in cache key
        VaryByHeader []string      // Include specific headers in cache key
        Condition    func(*gin.Context) bool // Optional condition to enable cache
}

// CacheMiddleware provides caching functionality for HTTP endpoints.
type CacheMiddleware struct {
        redisService *services.RedisService
        logger       logger.Logger
}

// NewCacheMiddleware creates a new cache middleware instance.
func NewCacheMiddleware(redisService *services.RedisService, logger logger.Logger) *CacheMiddleware <span class="cov0" title="0">{
        return &amp;CacheMiddleware{
                redisService: redisService,
                logger:       logger,
        }
}</span>

// Cache returns a middleware function that caches responses based on the provided configuration.
func (cm *CacheMiddleware) Cache(config CacheConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip caching for non-GET requests by default
                if c.Request.Method != http.MethodGet </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Check condition if provided
                <span class="cov0" title="0">if config.Condition != nil &amp;&amp; !config.Condition(c) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Generate cache key
                <span class="cov0" title="0">cacheKey := cm.generateCacheKey(c, config)

                // Try to get cached response
                cachedResponse, appErr := cm.redisService.Get(c.Request.Context(), cacheKey)
                if appErr != nil </span><span class="cov0" title="0">{
                        cm.logger.Error(c.Request.Context(), "Failed to get cached response", map[string]interface{}{
                                "cache_key": cacheKey,
                                "error":     appErr.Error(),
                        })
                        c.Next()
                        return
                }</span>

                // If cache hit, return cached response
                <span class="cov0" title="0">if cachedResponse != "" </span><span class="cov0" title="0">{
                        var cachedData CachedResponse
                        if err := cm.redisService.GetWithJSON(c.Request.Context(), cacheKey, &amp;cachedData); err == nil </span><span class="cov0" title="0">{
                                // Set headers
                                for key, value := range cachedData.Headers </span><span class="cov0" title="0">{
                                        c.Header(key, value)
                                }</span>
                                <span class="cov0" title="0">c.Header("X-Cache", "HIT")
                                c.Data(cachedData.StatusCode, cachedData.ContentType, cachedData.Body)
                                return</span>
                        }
                }

                // Cache miss - proceed with request and cache response
                <span class="cov0" title="0">writer := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        body:          make([]byte, 0),
                        statusCode:    http.StatusOK,
                        headers:       make(map[string]string),
                }
                c.Writer = writer

                c.Next()

                // Cache the response
                cachedData := CachedResponse{
                        Body:        writer.body,
                        StatusCode:  writer.statusCode,
                        ContentType: writer.Header().Get("Content-Type"),
                        Headers:     writer.headers,
                }

                if appErr := cm.redisService.SetWithJSON(c.Request.Context(), cacheKey, cachedData, config.TTL); appErr != nil </span><span class="cov0" title="0">{
                        cm.logger.Error(c.Request.Context(), "Failed to cache response", map[string]interface{}{
                                "cache_key": cacheKey,
                                "error":     appErr.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        cm.logger.Debug(c.Request.Context(), "Response cached successfully", map[string]interface{}{
                                "cache_key": cacheKey,
                                "ttl":       config.TTL.String(),
                        })
                }</span>

                <span class="cov0" title="0">c.Header("X-Cache", "MISS")</span>
        }
}

// CachedResponse represents a cached HTTP response.
type CachedResponse struct {
        Body        []byte            `json:"body"`
        StatusCode  int               `json:"status_code"`
        ContentType string            `json:"content_type"`
        Headers     map[string]string `json:"headers"`
}

// responseWriter wraps gin.ResponseWriter to capture response data.
type responseWriter struct {
        gin.ResponseWriter
        body       []byte
        statusCode int
        headers    map[string]string
}

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        w.body = append(w.body, data...)
        return w.ResponseWriter.Write(data)
}</span>

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriter) Header() http.Header <span class="cov0" title="0">{
        return w.ResponseWriter.Header()
}</span>

// generateCacheKey creates a unique cache key based on the request and configuration.
func (cm *CacheMiddleware) generateCacheKey(c *gin.Context, config CacheConfig) string <span class="cov0" title="0">{
        var keyParts []string

        // Add prefix
        if config.KeyPrefix != "" </span><span class="cov0" title="0">{
                keyParts = append(keyParts, config.KeyPrefix)
        }</span> else<span class="cov0" title="0"> {
                keyParts = append(keyParts, "cache")
        }</span>

        // Add path
        <span class="cov0" title="0">keyParts = append(keyParts, c.Request.URL.Path)

        // Add user ID if requested
        if config.VaryByUser </span><span class="cov0" title="0">{
                userID := cm.getUserID(c)
                if userID != "" </span><span class="cov0" title="0">{
                        keyParts = append(keyParts, fmt.Sprintf("user:%s", userID))
                }</span>
        }

        // Add query parameters if requested
        <span class="cov0" title="0">if config.VaryByQuery &amp;&amp; len(c.Request.URL.RawQuery) &gt; 0 </span><span class="cov0" title="0">{
                keyParts = append(keyParts, "query:"+c.Request.URL.RawQuery)
        }</span>

        // Add specific headers if requested
        <span class="cov0" title="0">for _, headerName := range config.VaryByHeader </span><span class="cov0" title="0">{
                if headerValue := c.GetHeader(headerName); headerValue != "" </span><span class="cov0" title="0">{
                        keyParts = append(keyParts, fmt.Sprintf("header:%s:%s", headerName, headerValue))
                }</span>
        }

        // Create final key
        <span class="cov0" title="0">finalKey := strings.Join(keyParts, ":")

        // Hash the key if it's too long
        if len(finalKey) &gt; 250 </span><span class="cov0" title="0">{
                hash := md5.Sum([]byte(finalKey))
                finalKey = config.KeyPrefix + ":" + hex.EncodeToString(hash[:])
        }</span>

        <span class="cov0" title="0">return finalKey</span>
}

// getUserID attempts to get user ID from various sources in the context.
func (cm *CacheMiddleware) getUserID(c *gin.Context) string <span class="cov0" title="0">{
        // Try direct user_id first
        if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                if id, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        
        // Try from claims
        <span class="cov0" title="0">if claimsInterface, exists := c.Get("claims"); exists </span><span class="cov0" title="0">{
                if claims, ok := claimsInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Handle UUID type
                        if id, ok := claims["ID"].(fmt.Stringer); ok </span><span class="cov0" title="0">{
                                return id.String()
                        }</span>
                        // Handle string type
                        <span class="cov0" title="0">if id, ok := claims["ID"].(string); ok </span><span class="cov0" title="0">{
                                return id
                        }</span>
                }
        }
        
        // Try user_uuid (alternative naming)
        <span class="cov0" title="0">if userUUID, exists := c.Get("user_uuid"); exists </span><span class="cov0" title="0">{
                if id, ok := userUUID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        
        // Try sub claim (JWT standard)
        <span class="cov0" title="0">if sub, exists := c.Get("sub"); exists </span><span class="cov0" title="0">{
                if id, ok := sub.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        
        <span class="cov0" title="0">return ""</span>
}

// ClearCache removes cached responses for a specific pattern.
func (cm *CacheMiddleware) ClearCache(c *gin.Context, pattern string) error <span class="cov0" title="0">{
        // Note: This is a simple implementation. For production, you might want to use Redis SCAN
        // or maintain a separate index of cache keys for more efficient clearing.
        return cm.redisService.Delete(c.Request.Context(), pattern)
}</span>

// Decorator functions for easy usage

// Cache5Min creates a cache middleware with 5 minutes TTL.
func (cm *CacheMiddleware) Cache5Min() gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL: 5 * time.Minute,
        })
}</span>

// Cache15Min creates a cache middleware with 15 minutes TTL.
func (cm *CacheMiddleware) Cache15Min() gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL: 15 * time.Minute,
        })
}</span>

// Cache1Hour creates a cache middleware with 1 hour TTL.
func (cm *CacheMiddleware) Cache1Hour() gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL: 1 * time.Hour,
        })
}</span>

// CacheUserSpecific creates a cache middleware that varies by user.
func (cm *CacheMiddleware) CacheUserSpecific(ttl time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL:        ttl,
                VaryByUser: true,
        })
}</span>

// CacheWithQuery creates a cache middleware that includes query parameters.
func (cm *CacheMiddleware) CacheWithQuery(ttl time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL:         ttl,
                VaryByQuery: true,
        })
}</span>

// CacheConditional creates a conditional cache middleware.
func (cm *CacheMiddleware) CacheConditional(ttl time.Duration, condition func(*gin.Context) bool) gin.HandlerFunc <span class="cov0" title="0">{
        return cm.Cache(CacheConfig{
                TTL:       ttl,
                Condition: condition,
        })
}</span> </pre>
		
		<pre class="file" id="file16" style="display: none">package middlewares

import (
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

// Cors returns a middleware that enables CORS support.
func Cors() gin.HandlerFunc <span class="cov0" title="0">{
        return cors.New(cors.Config{
                AllowOrigins:     []string{"*"},
                AllowMethods:     []string{"POST, OPTIONS, GET, PUT", "DELETE"},
                AllowHeaders:     []string{"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        })
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package middlewares

import (
        "context"
        "net/http"
        "time"

        "github.com/RodolfoBonis/spooliq/core/logger"
        sentrygin "github.com/getsentry/sentry-go/gin"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// contextKey is a custom type for context keys to avoid collisions.
type contextKey string

// MonitoringMiddleware provides monitoring capabilities for the application.
type MonitoringMiddleware struct {
        logger logger.Logger
}

// NewMonitoringMiddleware creates a new MonitoringMiddleware instance.
func NewMonitoringMiddleware(logger logger.Logger) *MonitoringMiddleware <span class="cov0" title="0">{
        return &amp;MonitoringMiddleware{logger: logger}
}</span>

// SentryMiddleware is a middleware for Sentry error tracking.
func (m *MonitoringMiddleware) SentryMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return sentrygin.New(sentrygin.Options{Repanic: true})
}</span>

// LogMiddleware is a middleware for logging requests and responses.
func (m *MonitoringMiddleware) LogMiddleware(ctx *gin.Context) <span class="cov0" title="0">{
        start := time.Now()
        requestID := uuid.NewString()
        ctx.Set("requestID", requestID)
        var responseBody = logger.HandleResponseBody(ctx.Writer)
        var requestBody = logger.
                HandleRequestBody(ctx.Request)
        ctx.Writer = responseBody

        // Adiciona o IP ao contexto do request
        ctxWithIP := context.WithValue(ctx.Request.Context(), contextKey("ip"), ctx.ClientIP())
        ctx.Request = ctx.Request.WithContext(ctxWithIP)

        m.logger.Info(ctx.Request.Context(), "Requisição iniciada", logger.Fields{
                "request_id":   requestID,
                "ip":           ctx.ClientIP(),
                "method":       ctx.Request.Method,
                "url":          ctx.Request.URL.String(),
                "user_agent":   ctx.Request.UserAgent(),
                "request_body": requestBody,
        })

        ctx.Next()

        latency := time.Since(start)
        status := ctx.Writer.Status()
        logFields := logger.Fields{
                "request_id":    requestID,
                "ip":            ctx.ClientIP(),
                "method":        ctx.Request.Method,
                "url":           ctx.Request.URL.String(),
                "user_agent":    ctx.Request.UserAgent(),
                "status":        status,
                "latency_ms":    latency.Milliseconds(),
                "request_body":  requestBody,
                "response_body": responseBody.Body.String(),
        }

        if isSuccessStatusCode(status) </span><span class="cov0" title="0">{
                m.logger.Info(ctx.Request.Context(), "Requisição concluída", logFields)
        }</span> else<span class="cov0" title="0"> {
                m.logger.Error(ctx.Request.Context(), "Requisição falhou", logFields)
        }</span>
}

func isSuccessStatusCode(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        case http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        amqp "github.com/rabbitmq/amqp091-go"
)

// AmqpService provides AMQP messaging capabilities.
type AmqpService struct {
        logger logger.Logger
        cfg    *config.AppConfig
}

// NewAmqpService creates a new AmqpService instance.
func NewAmqpService(logger logger.Logger, cfg *config.AppConfig) *AmqpService <span class="cov0" title="0">{
        return &amp;AmqpService{logger: logger, cfg: cfg}
}</span>

// StartAmqpConnection starts the AMQP connection.
func (s *AmqpService) StartAmqpConnection() (*amqp.Connection, error) <span class="cov0" title="0">{
        connection, err := amqp.Dial(s.cfg.AmqpConnection)
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{"amqp_url": s.cfg.AmqpConnection}, err)
                s.logger.LogError(context.Background(), "Failed to connect to RabbitMQ", appErr)
                return nil, err
        }</span>
        <span class="cov0" title="0">s.logger.Info(context.Background(), "Connected to RabbitMQ", map[string]interface{}{
                "amqp_url": s.cfg.AmqpConnection,
        })
        return connection, nil</span>
}

// StartChannelConnection starts the AMQP channel connection.
func (s *AmqpService) StartChannelConnection() (*amqp.Channel, error) <span class="cov0" title="0">{
        connection, err := s.StartAmqpConnection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">channel, err := connection.Channel()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), nil, err)
                s.logger.LogError(context.Background(), "Failed to open a channel", appErr)
                return nil, err
        }</span>
        <span class="cov0" title="0">s.logger.Info(context.Background(), "AMQP channel opened")
        return channel, nil</span>
}

// SendDataToQueue sends data to the AMQP queue.
func (s *AmqpService) SendDataToQueue(queue string, payload []byte) error <span class="cov0" title="0">{
        channel, err := s.StartChannelConnection()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(context.Background(), "AMQP not available, skipping queue operation", map[string]interface{}{
                        "queue": queue,
                        "error": err.Error(),
                })
                return err
        }</span>

        <span class="cov0" title="0">q, internalError := channel.QueueDeclare(
                queue, // name
                false, // durable
                false, // delete when unused
                false, // exclusive
                false, // no-wait
                nil,   // arguments
        )

        if internalError != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, internalError.Error(), map[string]interface{}{"queue": queue}, internalError)
                s.logger.LogError(context.Background(), "Failed to declare queue", appErr)
                return internalError
        }</span>

        <span class="cov0" title="0">internalError = channel.PublishWithContext(context.Background(),
                "",     // exchange
                q.Name, // routing key
                false,  // mandatory
                false,  // immediate
                amqp.Publishing{
                        ContentType: "application/json",
                        Body:        payload,
                })

        if internalError != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, internalError.Error(), map[string]interface{}{"queue": queue}, internalError)
                s.logger.LogError(context.Background(), "Failed to publish message", appErr)
                return internalError
        }</span>

        <span class="cov0" title="0">s.logger.Info(context.Background(), "Message published to queue", map[string]interface{}{
                "queue":        queue,
                "payload_size": len(payload),
        })
        return nil</span>
}

// ConsumeQueue consumes messages from the AMQP queue.
func (s *AmqpService) ConsumeQueue(queue string) (&lt;-chan amqp.Delivery, error) <span class="cov0" title="0">{
        channel, err := s.StartChannelConnection()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(context.Background(), "AMQP not available, cannot consume queue", map[string]interface{}{
                        "queue": queue,
                        "error": err.Error(),
                })
                return nil, err
        }</span>

        <span class="cov0" title="0">q, internalError := channel.QueueDeclare(
                queue, // name
                false, // durable
                false, // delete when unused
                false, // exclusive
                false, // no-wait
                nil,   // arguments
        )

        if internalError != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, internalError.Error(), map[string]interface{}{"queue": queue}, internalError)
                s.logger.LogError(context.Background(), "Failed to declare queue for consume", appErr)
                return nil, internalError
        }</span>

        <span class="cov0" title="0">msgs, internalError := channel.Consume(
                q.Name, // queue
                "",     // consumer
                true,   // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )

        if internalError != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, internalError.Error(), map[string]interface{}{"queue": queue}, internalError)
                s.logger.LogError(context.Background(), "Failed to start consuming queue", appErr)
                return nil, internalError
        }</span>

        <span class="cov0" title="0">s.logger.Info(context.Background(), "Consuming queue", map[string]interface{}{
                "queue": queue,
        })

        return msgs, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "github.com/Nerzal/gocloak/v13"
        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/logger"
)

// AuthService provides authentication capabilities.
type AuthService struct {
        client *gocloak.GoCloak
        logger logger.Logger
        cfg    *config.AppConfig
}

// NewAuthService creates a new AuthService instance.
func NewAuthService(logger logger.Logger, cfg *config.AppConfig) *AuthService <span class="cov0" title="0">{
        client := gocloak.NewClient(cfg.Keycloak.Host)
        
        return &amp;AuthService{
                client: client,
                logger: logger,
                cfg:    cfg,
        }
}</span>

// GetClient returns the Keycloak client instance.
func (s *AuthService) GetClient() *gocloak.GoCloak <span class="cov0" title="0">{
        return s.client
}</span>

// GetConfig returns the application configuration.
func (s *AuthService) GetConfig() *config.AppConfig <span class="cov0" title="0">{
        return s.cfg
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"

        // Entidades do SpoolIq
        filamentsEntities "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        quotesEntities "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        presetsEntities "github.com/RodolfoBonis/spooliq/features/presets/domain/entities"

        "github.com/jinzhu/gorm"
        // Drivers de banco de dados
        _ "github.com/jinzhu/gorm/dialects/postgres"
        _ "github.com/jinzhu/gorm/dialects/sqlite"
        _ "github.com/lib/pq"
)

// Connector is the global database connector instance.
var Connector *gorm.DB

// ConnectorConfig holds the configuration for the database connector.
type ConnectorConfig struct {
        Driver   string // "postgres" ou "sqlite"
        Host     string
        Port     string
        User     string
        DBName   string
        Password string
        Path     string // Para SQLite
}

func buildConnectorConfig() *ConnectorConfig <span class="cov0" title="0">{
        // Usar driver da configuração ou PostgreSQL como padrão
        driver := config.EnvDBDriver()

        connectorConfig := ConnectorConfig{
                Driver:   driver,
                Host:     config.EnvDBHost(),
                Port:     config.EnvDBPort(),
                User:     config.EnvDBUser(),
                Password: config.EnvDBPassword(),
                DBName:   config.EnvDBName(),
                Path:     config.EnvDBSQLitePath(),
        }
        return &amp;connectorConfig
}</span>

func connectorURL(connectorConfig *ConnectorConfig) string <span class="cov0" title="0">{
        if connectorConfig.Driver == "sqlite" </span><span class="cov0" title="0">{
                return connectorConfig.Path
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "host=%s port=%s user=%s dbname=%s password=%s sslmode=disable",
                connectorConfig.Host,
                connectorConfig.Port,
                connectorConfig.User,
                connectorConfig.DBName,
                connectorConfig.Password,
        )</span>
}

// OpenConnection opens a new database connection.
func OpenConnection(logger logger.Logger) *errors.AppError <span class="cov0" title="0">{
        connConfig := buildConnectorConfig()
        dbConfig := connectorURL(connConfig)

        db, err := gorm.Open(connConfig.Driver,
                dbConfig,
        )

        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrDatabase, err.Error(), map[string]interface{}{"db_config": dbConfig}, err)
                logger.LogError(context.Background(), "Failed to connect to database", appErr)
                return appErr
        }</span>

        <span class="cov0" title="0">environment := config.EnvironmentConfig()
        isDevelopment := environment == entities.Environment.Development

        if isDevelopment </span><span class="cov0" title="0">{
                logger.Info(context.Background(), "Database connection established", map[string]interface{}{
                        "db_config": dbConfig,
                })
        }</span> else<span class="cov0" title="0"> {
                logger.Info(context.Background(), "Database connection established", map[string]interface{}{
                        "host":   connConfig.Host,
                        "port":   connConfig.Port,
                        "dbname": connConfig.DBName,
                        "user":   connConfig.User,
                })
        }</span>

        <span class="cov0" title="0">isProduction := environment == entities.Environment.Production
        db.SingularTable(true)
        db.LogMode(!isProduction)
        db.DB().SetConnMaxLifetime(10 * time.Second)
        db.DB().SetMaxIdleConns(30)
        Connector = db

        go func(dbConfig string) </span><span class="cov0" title="0">{
                var intervals = []time.Duration{3 * time.Second, 3 * time.Second, 15 * time.Second, 30 * time.Second, 60 * time.Second}
                for </span><span class="cov0" title="0">{
                        time.Sleep(60 * time.Second)
                        if e := Connector.DB().Ping(); e != nil </span><span class="cov0" title="0">{
                                appErr := errors.NewAppError(entities.ErrDatabase, e.Error(), nil, e)
                                logger.LogError(context.Background(), "Database ping failed", appErr)
                        L:
                                for i := 0; i &lt; len(intervals); i++ </span><span class="cov0" title="0">{
                                        e2 := RetryHandler(3, func() (bool, error) </span><span class="cov0" title="0">{
                                                var e error
                                                Connector, e = gorm.Open("postgres", dbConfig)
                                                if e != nil </span><span class="cov0" title="0">{
                                                        appErr := errors.NewAppError(entities.ErrDatabase, e.Error(), nil, e)
                                                        logger.LogError(context.Background(), "Database retry failed", appErr)
                                                        return false, e
                                                }</span>
                                                <span class="cov0" title="0">logger.Info(context.Background(), "Database reconnected successfully")
                                                return true, nil</span>
                                        })
                                        <span class="cov0" title="0">if e2 != nil </span><span class="cov0" title="0">{
                                                appErr := errors.NewAppError(entities.ErrDatabase, e2.Error(), nil, e2)
                                                logger.LogError(context.Background(), "Database retry failed, will retry again", appErr)
                                                time.Sleep(intervals[i])
                                                if i == len(intervals)-1 </span><span class="cov0" title="0">{
                                                        i--
                                                }</span>
                                                <span class="cov0" title="0">continue</span>
                                        }
                                        <span class="cov0" title="0">break L</span>
                                }
                        }
                }
        }(dbConfig)

        <span class="cov0" title="0">return nil</span>
}

// RetryHandler handles retry logic for database operations.
func RetryHandler(n int, f func() (bool, error)) error <span class="cov0" title="0">{
        ok, er := f()
        if ok &amp;&amp; er == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if n-1 &gt; 0 </span><span class="cov0" title="0">{
                return RetryHandler(n-1, f)
        }</span>
        <span class="cov0" title="0">return er</span>
}

// RunMigrations runs the database migrations.
func RunMigrations() <span class="cov0" title="0">{
        // Executar migrações automáticas
        Connector.AutoMigrate(
                // Filaments
                &amp;filamentsEntities.Filament{},

                // Quotes e relacionados
                &amp;quotesEntities.Quote{},
                &amp;quotesEntities.QuoteFilamentLine{},
                &amp;quotesEntities.MachineProfile{},
                &amp;quotesEntities.EnergyProfile{},
                &amp;quotesEntities.CostProfile{},
                &amp;quotesEntities.MarginProfile{},

                // Presets
                &amp;presetsEntities.Preset{},
        )
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "github.com/jinzhu/gorm"
        "go.uber.org/fx"
)

// Module provides the fx module for services.
var Module = fx.Module("services",
        fx.Provide(
                NewAmqpService,
                NewRedisService,
                NewAuthService,
                func() *gorm.DB <span class="cov0" title="0">{
                        return Connector
                }</span>,
        ),
) </pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/redis/go-redis/v9"
)

// RedisService provides Redis caching capabilities.
type RedisService struct {
        client *redis.Client
        logger logger.Logger
        cfg    *config.AppConfig
}

// NewRedisService creates a new RedisService instance.
func NewRedisService(logger logger.Logger, cfg *config.AppConfig) *RedisService <span class="cov0" title="0">{
        return &amp;RedisService{
                logger: logger,
                cfg:    cfg,
        }
}</span>

// Init initializes the Redis connection.
func (r *RedisService) Init() *errors.AppError <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%s", r.cfg.RedisHost, r.cfg.RedisPort),
                Password: r.cfg.RedisPassword,
                DB:       r.cfg.RedisDB,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := rdb.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "redis_host": config.EnvRedisHost(),
                        "redis_port": config.EnvRedisPort(),
                }, err)
                r.logger.LogError(context.Background(), "Failed to connect to Redis", appErr)
                return appErr
        }</span>

        <span class="cov0" title="0">r.client = rdb
        r.logger.Info(context.Background(), "Redis connected successfully", map[string]interface{}{
                "redis_host": config.EnvRedisHost(),
                "redis_port": config.EnvRedisPort(),
        })

        return nil</span>
}

// GetClient returns the Redis client instance.
func (r *RedisService) GetClient() *redis.Client <span class="cov0" title="0">{
        return r.client
}</span>

// Set stores a key-value pair with optional expiration.
func (r *RedisService) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *errors.AppError <span class="cov0" title="0">{
        err := r.client.Set(ctx, key, value, expiration).Err()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to set Redis key", appErr)
                return appErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a value by key.
func (r *RedisService) Get(ctx context.Context, key string) (string, *errors.AppError) <span class="cov0" title="0">{
        val, err := r.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // Key does not exist
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to get Redis key", appErr)
                return "", appErr
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Delete removes a key from Redis.
func (r *RedisService) Delete(ctx context.Context, key string) *errors.AppError <span class="cov0" title="0">{
        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to delete Redis key", appErr)
                return appErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in Redis.
func (r *RedisService) Exists(ctx context.Context, key string) (bool, *errors.AppError) <span class="cov0" title="0">{
        count, err := r.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to check Redis key existence", appErr)
                return false, appErr
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// SetWithJSON stores a JSON object with optional expiration.
func (r *RedisService) SetWithJSON(ctx context.Context, key string, value interface{}, expiration time.Duration) *errors.AppError <span class="cov0" title="0">{
        jsonData, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to marshal JSON for Redis", appErr)
                return appErr
        }</span>

        <span class="cov0" title="0">return r.Set(ctx, key, jsonData, expiration)</span>
}

// GetWithJSON retrieves and unmarshals a JSON object.
func (r *RedisService) GetWithJSON(ctx context.Context, key string, dest interface{}) *errors.AppError <span class="cov0" title="0">{
        val, appErr := r.Get(ctx, key)
        if appErr != nil </span><span class="cov0" title="0">{
                return appErr
        }</span>
        <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                return nil // Key does not exist
        }</span>

        <span class="cov0" title="0">err := json.Unmarshal([]byte(val), dest)
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(entities.ErrService, err.Error(), map[string]interface{}{
                        "key": key,
                }, err)
                r.logger.LogError(ctx, "Failed to unmarshal JSON from Redis", appErr)
                return appErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Close closes the Redis connection.
func (r *RedisService) Close() error <span class="cov0" title="0">{
        if r.client != nil </span><span class="cov0" title="0">{
                return r.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
} </pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "context"

        "github.com/RodolfoBonis/spooliq/core/logger"
        filamentsEntities "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        presetsEntities "github.com/RodolfoBonis/spooliq/features/presets/domain/entities"
)

// RunSeeds executa todos os seeds iniciais do sistema
func RunSeeds(logger logger.Logger) <span class="cov0" title="0">{
        ctx := context.Background()

        logger.Info(ctx, "Iniciando seeds do sistema...")

        // Seeds de presets
        seedEnergyPresets(logger)
        seedMachinePresets(logger)

        // Seeds de filamentos
        seedFilaments(logger)

        logger.Info(ctx, "Seeds concluídos com sucesso!")
}</span>

// seedEnergyPresets cria presets de energia/tarifa
func seedEnergyPresets(logger logger.Logger) <span class="cov0" title="0">{
        ctx := context.Background()

        energyPresets := []struct {
                Key  string
                Data presetsEntities.EnergyPreset
        }{
                {
                        Key: "energy_maceio_al_2025",
                        Data: presetsEntities.EnergyPreset{
                                BaseTariff:    0.804,
                                FlagSurcharge: 0,
                                Location:      "Maceió-AL",
                                Year:          2025,
                                Description:   "Tarifa energética padrão para Maceió, Alagoas em 2025",
                        },
                },
                {
                        Key: "energy_sao_paulo_sp_2025",
                        Data: presetsEntities.EnergyPreset{
                                BaseTariff:    0.892,
                                FlagSurcharge: 0,
                                Location:      "São Paulo-SP",
                                Year:          2025,
                                Description:   "Tarifa energética padrão para São Paulo, SP em 2025",
                        },
                },
                {
                        Key: "energy_rio_de_janeiro_rj_2025",
                        Data: presetsEntities.EnergyPreset{
                                BaseTariff:    0.756,
                                FlagSurcharge: 0,
                                Location:      "Rio de Janeiro-RJ",
                                Year:          2025,
                                Description:   "Tarifa energética padrão para Rio de Janeiro, RJ em 2025",
                        },
                },
        }

        for _, presetData := range energyPresets </span><span class="cov0" title="0">{
                var existingPreset presetsEntities.Preset
                result := Connector.Where("key = ?", presetData.Key).First(&amp;existingPreset)

                if result.RecordNotFound() </span><span class="cov0" title="0">{
                        preset := presetsEntities.Preset{
                                Key: presetData.Key,
                        }

                        err := preset.MarshalDataFrom(presetData.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Erro ao serializar preset de energia", map[string]interface{}{
                                        "key":   presetData.Key,
                                        "error": err.Error(),
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := Connector.Create(&amp;preset).Error; err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Erro ao criar preset de energia", map[string]interface{}{
                                        "key":   presetData.Key,
                                        "error": err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info(ctx, "Preset de energia criado", map[string]interface{}{
                                        "key":      presetData.Key,
                                        "location": presetData.Data.Location,
                                })
                        }</span>
                }
        }
}

// seedMachinePresets cria presets de máquinas/impressoras
func seedMachinePresets(logger logger.Logger) <span class="cov0" title="0">{
        ctx := context.Background()

        machinePresets := []struct {
                Key  string
                Data presetsEntities.MachinePreset
        }{
                {
                        Key: "machine_bambulab_a1_combo",
                        Data: presetsEntities.MachinePreset{
                                Name:        "BambuLab A1 Combo",
                                Brand:       "BambuLab",
                                Model:       "A1 Combo",
                                Watt:        95,
                                IdleFactor:  0,
                                Description: "Impressora 3D BambuLab A1 Combo - consumo 95W",
                                URL:         "https://bambulab.com/en/a1",
                        },
                },
                {
                        Key: "machine_ender3_v2",
                        Data: presetsEntities.MachinePreset{
                                Name:        "Creality Ender 3 V2",
                                Brand:       "Creality",
                                Model:       "Ender 3 V2",
                                Watt:        270,
                                IdleFactor:  0.1,
                                Description: "Impressora 3D Creality Ender 3 V2 - consumo 270W",
                                URL:         "https://www.creality.com/products/ender-3-v2-3d-printer",
                        },
                },
                {
                        Key: "machine_prusa_mk4",
                        Data: presetsEntities.MachinePreset{
                                Name:        "Prusa i3 MK4",
                                Brand:       "Prusa Research",
                                Model:       "i3 MK4",
                                Watt:        120,
                                IdleFactor:  0.05,
                                Description: "Impressora 3D Prusa i3 MK4 - consumo 120W",
                                URL:         "https://www.prusa3d.com/product/original-prusa-i3-mk4-3d-printer/",
                        },
                },
        }

        for _, presetData := range machinePresets </span><span class="cov0" title="0">{
                var existingPreset presetsEntities.Preset
                result := Connector.Where("key = ?", presetData.Key).First(&amp;existingPreset)

                if result.RecordNotFound() </span><span class="cov0" title="0">{
                        preset := presetsEntities.Preset{
                                Key: presetData.Key,
                        }

                        err := preset.MarshalDataFrom(presetData.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Erro ao serializar preset de máquina", map[string]interface{}{
                                        "key":   presetData.Key,
                                        "error": err.Error(),
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := Connector.Create(&amp;preset).Error; err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Erro ao criar preset de máquina", map[string]interface{}{
                                        "key":   presetData.Key,
                                        "error": err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info(ctx, "Preset de máquina criado", map[string]interface{}{
                                        "key":  presetData.Key,
                                        "name": presetData.Data.Name,
                                })
                        }</span>
                }
        }
}

// seedFilaments cria filamentos iniciais baseados nos ASINs fornecidos
func seedFilaments(logger logger.Logger) <span class="cov0" title="0">{
        ctx := context.Background()

        filaments := []filamentsEntities.Filament{
                {
                        Name:       "PLA Branco SUNLU",
                        Brand:      "SUNLU",
                        Material:   "PLA",
                        Color:      "Branco",
                        ColorHex:   "#FFFFFF",
                        PricePerKg: 125.0,
                        URL:        "https://www.amazon.com.br/dp/B07PGYHYV8",
                        // OwnerUserID null = catálogo global
                },
                {
                        Name:       "PETG Transparente SUNLU",
                        Brand:      "SUNLU",
                        Material:   "PETG",
                        Color:      "Transparente",
                        ColorHex:   "#F0F0F0",
                        PricePerKg: 139.90,
                        URL:        "https://www.amazon.com.br/dp/B078N8BYX8",
                        // OwnerUserID null = catálogo global
                },
                {
                        Name:       "ABS Preto SUNLU",
                        Brand:      "SUNLU",
                        Material:   "ABS",
                        Color:      "Preto",
                        ColorHex:   "#000000",
                        PricePerKg: 135.0,
                        URL:        "https://www.amazon.com.br/dp/B074DKZP1S",
                        // OwnerUserID null = catálogo global
                },
        }

        for _, filament := range filaments </span><span class="cov0" title="0">{
                var existingFilament filamentsEntities.Filament
                result := Connector.Where("name = ? AND brand = ? AND material = ? AND color = ?",
                        filament.Name, filament.Brand, filament.Material, filament.Color).First(&amp;existingFilament)

                if result.RecordNotFound() </span><span class="cov0" title="0">{
                        if err := Connector.Create(&amp;filament).Error; err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Erro ao criar filamento", map[string]interface{}{
                                        "name":  filament.Name,
                                        "error": err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info(ctx, "Filamento criado", map[string]interface{}{
                                        "name":     filament.Name,
                                        "brand":    filament.Brand,
                                        "material": filament.Material,
                                        "color":    filament.Color,
                                })
                        }</span>
                }
        }
}</pre>
		
		<pre class="file" id="file24" style="display: none">package types

// Array represents a generic array type.
type Array []any

// Contains checks if the array contains a specific element.
func (a *Array) Contains(value any) bool <span class="cov0" title="0">{
        list := *a
        for i := 0; i &lt; len(list); i++ </span><span class="cov0" title="0">{
                if list[i] == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package types

import (
        "runtime"
        "strconv"
        "strings"
)

// StackTrace represents a stack trace for error handling.
type StackTrace []uintptr

func (s *StackTrace) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        stack := *s
        for k := range stack </span><span class="cov0" title="0">{
                v := stack[k] - 1
                f := runtime.FuncForPC(v)
                file, line := f.FileLine(v)

                sb.WriteString(f.Name())
                sb.WriteString("\n\t")
                sb.WriteString(file)
                sb.WriteString(":")
                sb.WriteString(strconv.Itoa(line))
                sb.WriteString("\n")
        }</span>

        <span class="cov0" title="0">result := sb.String()

        return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate user and return JWT tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User Login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/entities.RequestLoginEntity"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful login",
                        "schema": {
                            "$ref": "#/definitions/entities.LoginResponseEntity"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Invalidate the refresh token and logout the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User Logout",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer refresh token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Logout successful",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Refresh the user's access and refresh tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Refresh Login Access Token",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer refresh token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Tokens refreshed",
                        "schema": {
                            "$ref": "#/definitions/entities.LoginResponseEntity"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        },
        "/auth/validate": {
            "post": {
                "description": "Validate the current access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Validate Auth Token",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer access token",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Token is valid",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        },
        "/health_check": {
            "get": {
                "description": "Check if This service is healthy",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "HealthCheck"
                ],
                "summary": "Health Check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        },
        "/system": {
            "get": {
                "description": "Returns the current system status (OS, CPU, memory, GPU, storage, server)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "System"
                ],
                "summary": "Get System Status",
                "responses": {
                    "200": {
                        "description": "System status info",
                        "schema": {
                            "$ref": "#/definitions/entities.SystemStatus"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.HTTPError"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "entities.CPU": {
            "type": "object",
            "properties": {
                "cores": {
                    "type": "integer"
                },
                "model": {
                    "type": "string"
                },
                "threads": {
                    "type": "integer"
                },
                "usage": {
                    "type": "string"
                }
            }
        },
        "entities.GPU": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "boolean"
                },
                "memory": {
                    "type": "string"
                },
                "model": {
                    "type": "string"
                }
            }
        },
        "entities.LoginResponseEntity": {
            "description": "LoginResponseEntity model data",
            "type": "object",
            "properties": {
                "accessToken": {
                    "description": "Token to access this API",
                    "type": "string"
                },
                "expiresIn": {
                    "description": "Time to expires token in int",
                    "type": "integer"
                },
                "refreshToken": {
                    "description": "Token to refresh Access Token",
                    "type": "string"
                }
            }
        },
        "entities.Memory": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "string"
                },
                "percentage": {
                    "type": "string"
                },
                "total": {
                    "type": "string"
                },
                "used": {
                    "type": "string"
                }
            }
        },
        "entities.RequestLoginEntity": {
            "description": "RequestLoginEntity model data",
            "type": "object",
            "properties": {
                "email": {
                    "description": "User email",
                    "type": "string"
                },
                "password": {
                    "description": "User password",
                    "type": "string"
                }
            }
        },
        "entities.Server": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "entities.Storage": {
            "type": "object",
            "properties": {
                "percentage": {
                    "type": "string"
                },
                "total": {
                    "type": "string"
                },
                "used": {
                    "type": "string"
                }
            }
        },
        "entities.SystemStatus": {
            "type": "object",
            "properties": {
                "cpu": {
                    "$ref": "#/definitions/entities.CPU"
                },
                "gpu": {
                    "$ref": "#/definitions/entities.GPU"
                },
                "memory": {
                    "$ref": "#/definitions/entities.Memory"
                },
                "os": {
                    "type": "string"
                },
                "server": {
                    "$ref": "#/definitions/entities.Server"
                },
                "storage": {
                    "$ref": "#/definitions/entities.Storage"
                }
            }
        },
        "errors.HTTPError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "stack_trace": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package auth

import (
        "github.com/RodolfoBonis/spooliq/features/auth/domain/usecases"
        "github.com/gin-gonic/gin"
)

// LoginHandler handles user login requests.
// @Summary User Login
// @Schemes
// @Description Authenticate user and return JWT tokens
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.RequestLoginEntity true "Login credentials"
// @Success 200 {object} entities.LoginResponseEntity "Successful login"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/login [post]
// @Example request {"email": "user@example.com", "password": "string"}
// @Example response {"accessToken": "jwt-token", "refreshToken": "refresh-token", "expiresIn": 3600}
func LoginHandler(authUc usecases.AuthUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authUc.ValidateLogin(c)
        }</span>
}

// RegisterHandler handles user registration requests.
// @Summary User Registration
// @Schemes
// @Description Register a new user account in SpoolIQ
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.RequestRegisterEntity true "Registration data"
// @Success 201 {object} entities.RegisterResponseEntity "Successful registration"
// @Failure 400 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/register [post]
// @Example request {"email": "user@example.com", "password": "SecurePass123", "firstName": "John", "lastName": "Doe"}
// @Example response {"message": "User registered successfully", "userID": "uuid", "email": "user@example.com"}
func RegisterHandler(authUc usecases.AuthUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authUc.RegisterUser(c)
        }</span>
}

// ForgotPasswordHandler handles password reset requests.
// @Summary Password Reset Request
// @Schemes
// @Description Request a password reset for a user account
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.ForgotPasswordRequestEntity true "Password reset request data"
// @Success 200 {object} entities.ForgotPasswordResponseEntity "Password reset request sent"
// @Failure 400 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/forgot-password [post]
// @Example request {"email": "user@example.com"}
// @Example response {"message": "Password reset instructions have been sent to your email", "email": "user@example.com"}
func ForgotPasswordHandler(authUc usecases.AuthUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authUc.ForgotPassword(c)
        }</span>
}

// Routes registers authentication routes for the application.
func Routes(route *gin.RouterGroup, authUC usecases.AuthUseCase, protectFactory func(handler gin.HandlerFunc, role string) gin.HandlerFunc) <span class="cov0" title="0">{
        route.POST("/auth/register", RegisterHandler(authUC))
        route.POST("/auth/forgot-password", ForgotPasswordHandler(authUC))
        route.POST("/login", LoginHandler(authUC))
        route.POST("/logout", protectFactory(authUC.Logout, "user"))
        route.POST("/refresh", protectFactory(authUC.RefreshAuthToken, "user"))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package di

import (
        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/services"
        "github.com/RodolfoBonis/spooliq/features/auth/domain/usecases"
        "go.uber.org/fx"
)

// AuthModule provides the fx module for authentication dependencies.
var AuthModule = fx.Module("auth",
        fx.Provide(
                func(authService *services.AuthService, logger logger.Logger) usecases.AuthUseCase <span class="cov0" title="0">{
                        return usecases.NewAuthUseCase(authService.GetClient(), config.EnvKeyCloak(), logger)
                }</span>,
        ),
)
</pre>
		
		<pre class="file" id="file29" style="display: none">package entities

import (
        "strings"

        "github.com/go-playground/validator/v10"
)

// RequestRegisterEntity represents the registration request payload.
// @Description Registration request data
// @Example {"email": "user@example.com", "password": "SecurePass123", "firstName": "John", "lastName": "Doe"}
type RequestRegisterEntity struct {
        // User email address
        Email string `json:"email" validate:"required,email" example:"user@example.com"`
        // User password (minimum 8 characters)
        Password string `json:"password" validate:"required,min=8" example:"SecurePass123"`
        // User first name
        FirstName string `json:"firstName" validate:"required,min=2" example:"John"`
        // User last name
        LastName string `json:"lastName" validate:"required,min=2" example:"Doe"`
}

// Validate validates the registration entity
func (r *RequestRegisterEntity) Validate() error <span class="cov0" title="0">{
        validate := validator.New()

        // Validate struct
        if err := validate.Struct(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Additional business validations
        <span class="cov0" title="0">r.Email = strings.ToLower(strings.TrimSpace(r.Email))
        r.FirstName = strings.TrimSpace(r.FirstName)
        r.LastName = strings.TrimSpace(r.LastName)

        return nil</span>
}

// RegisterResponseEntity represents the registration response
// @Description Registration response data
type RegisterResponseEntity struct {
        // Success message
        Message string `json:"message" example:"User registered successfully"`
        // User email
        Email string `json:"email" example:"user@example.com"`
        // User ID (UUID)
        UserID string `json:"userID" example:"uuid"`
}

// ForgotPasswordRequestEntity represents the forgot password request payload.
// @Description Forgot password request data
// @Example {"email": "user@example.com"}
type ForgotPasswordRequestEntity struct {
        // User email address
        Email string `json:"email" validate:"required,email" example:"user@example.com"`
}

// Validate validates the forgot password entity
func (r *ForgotPasswordRequestEntity) Validate() error <span class="cov0" title="0">{
        validate := validator.New()

        // Validate struct
        if err := validate.Struct(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Additional business validations
        <span class="cov0" title="0">r.Email = strings.ToLower(strings.TrimSpace(r.Email))

        return nil</span>
}

// ForgotPasswordResponseEntity represents the forgot password response
// @Description Forgot password response data
type ForgotPasswordResponseEntity struct {
        // Success message
        Message string `json:"message" example:"Password reset instructions have been sent to your email"`
        // User email
        Email string `json:"email" example:"user@example.com"`
}</pre>
		
		<pre class="file" id="file30" style="display: none">package usecases

import (
        "net/http"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/auth/domain/entities"
        "github.com/gin-gonic/gin"
)

// ForgotPassword handles password reset requests in SpoolIQ
// @Summary Password Reset Request
// @Schemes
// @Description Request a password reset for a user account
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.ForgotPasswordRequestEntity true "Password reset request data"
// @Success 200 {object} entities.ForgotPasswordResponseEntity "Password reset request sent"
// @Failure 400 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/forgot-password [post]
// @Example request {"email": "user@example.com"}
// @Example response {"message": "Password reset instructions have been sent to your email", "email": "user@example.com"}
func (uc *authUseCaseImpl) ForgotPassword(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        forgotPasswordData := new(entities.ForgotPasswordRequestEntity)

        uc.Logger.Info(ctx, "Password reset request", logger.Fields{
                "ip":         c.ClientIP(),
                "user_agent": c.Request.UserAgent(),
        })

        err := c.BindJSON(&amp;forgotPasswordData)
        if err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrUsecase, err.Error(), nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Invalid forgot password payload", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate forgot password data
        <span class="cov0" title="0">if err := forgotPasswordData.Validate(); err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrEntity, "Forgot password validation failed", nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Forgot password validation failed", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>

        // In a real implementation, this would:
        // 1. Check if user exists in Keycloak
        // 2. Generate a password reset token
        // 3. Send email with reset instructions
        // 4. Store the reset token temporarily

        // For now, we'll return a simulated response
        <span class="cov0" title="0">response := entities.ForgotPasswordResponseEntity{
                Message: "If an account with that email exists, password reset instructions have been sent.",
                Email:   forgotPasswordData.Email,
        }

        uc.Logger.Info(ctx, "Password reset request processed", logger.Fields{
                "email": forgotPasswordData.Email,
        })

        c.JSON(http.StatusOK, response)</span>
}</pre>
		
		<pre class="file" id="file31" style="display: none">package usecases

import (
        "net/http"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/auth/domain/entities"
        "github.com/gin-gonic/gin"
)

// Login validates user credentials and returns access and refresh tokens.
// @Summary User Login
// @Schemes
// @Description Authenticate user and return JWT tokens
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.RequestLoginEntity true "Login credentials"
// @Success 200 {object} entities.LoginResponseEntity "Successful login"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/login [post]
// @Example request {"email": "user@example.com", "password": "string"}
// @Example response {"accessToken": "jwt-token", "refreshToken": "refresh-token", "expiresIn": 3600}

// ValidateLogin realiza a validação do login do usuário.
func (uc *authUseCaseImpl) ValidateLogin(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        loginData := new(entities.RequestLoginEntity)
        uc.Logger.Info(ctx, "Login attempt", logger.Fields{
                "email":      loginData.Email,
                "ip":         c.ClientIP(),
                "user_agent": c.Request.UserAgent(),
        })
        err := c.BindJSON(&amp;loginData)
        if err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrUsecase, err.Error(), nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Invalid login payload", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>
        <span class="cov0" title="0">jwt, err := uc.KeycloakClient.Login(
                c,
                uc.KeycloakAccessData.ClientID,
                uc.KeycloakAccessData.ClientSecret,
                uc.KeycloakAccessData.Realm,
                loginData.Email,
                loginData.Password,
        )
        if err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrInvalidCredentials, "Invalid credentials", nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Login failed: invalid credentials", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>
        <span class="cov0" title="0">uc.Logger.Info(ctx, "Login successful", logger.Fields{
                "email":      loginData.Email,
                "ip":         c.ClientIP(),
                "user_agent": c.Request.UserAgent(),
        })
        c.JSON(http.StatusOK, entities.LoginResponseEntity{
                AccessToken:  jwt.AccessToken,
                RefreshToken: jwt.RefreshToken,
                ExpiresIn:    jwt.ExpiresIn,
        })</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package usecases

import (
        "net/http"
        "strings"

        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/gin-gonic/gin"
)

// Logout invalidates the user's refresh token and ends the session.
// @Summary User Logout
// @Schemes
// @Description Invalidate the refresh token and logout the user
// @Tags Auth
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer refresh token"
// @Success 200 {object} bool "Logout successful"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/logout [post]
// @Example request {"Authorization": "Bearer &lt;refresh-token&gt;"}
// @Example response true
func (uc *authUseCaseImpl) Logout(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        authHeader := c.GetHeader("Authorization")
        if len(authHeader) &lt; 1 </span><span class="cov0" title="0">{
                err := errors.NewAppError(entities.ErrInvalidToken, "Token ausente", nil, nil)
                httpError := err.ToHTTPError()
                uc.Logger.LogError(ctx, "Logout failed: missing token", err)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">refreshToken := strings.Split(authHeader, " ")[1]
        err := uc.KeycloakClient.Logout(
                c,
                uc.KeycloakAccessData.ClientID,
                uc.KeycloakAccessData.ClientSecret,
                uc.KeycloakAccessData.Realm,
                refreshToken,
        )
        if err != nil </span><span class="cov0" title="0">{
                currentError := errors.NewAppError(entities.ErrUsecase, err.Error(), nil, err)
                httpError := currentError.ToHTTPError()
                uc.Logger.LogError(ctx, "Logout falhou", currentError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">uc.Logger.Info(ctx, "Logout successful", logger.Fields{
                "ip": c.ClientIP(),
        })
        c.JSON(http.StatusOK, true)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package usecases

import (
        "net/http"
        "strings"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/auth/domain/entities"
        "github.com/gin-gonic/gin"
)

// RefreshAuthToken renews the user's authentication tokens.
// @Summary Refresh Login Access Token
// @Schemes
// @Description Refresh the user's access and refresh tokens
// @Tags Auth
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer refresh token"
// @Success 200 {object} entities.LoginResponseEntity "Tokens refreshed"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/refresh [post]
// @Example request {"Authorization": "Bearer &lt;refresh-token&gt;"}
// @Example response {"accessToken": "jwt-token", "refreshToken": "refresh-token", "expiresIn": 3600}
func (uc *authUseCaseImpl) RefreshAuthToken(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        authHeader := c.GetHeader("Authorization")
        if len(authHeader) &lt; 1 </span><span class="cov0" title="0">{
                err := errors.NewAppError(coreEntities.ErrInvalidToken, "Token inválido", nil, nil)
                httpError := err.ToHTTPError()
                uc.Logger.LogError(ctx, "Refresh failed: missing token", err)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">refreshToken := strings.Split(authHeader, " ")[1]
        token, err := uc.KeycloakClient.RefreshToken(
                c,
                refreshToken,
                uc.KeycloakAccessData.ClientID,
                uc.KeycloakAccessData.ClientSecret,
                uc.KeycloakAccessData.Realm,
        )
        if err != nil </span><span class="cov0" title="0">{
                currentError := errors.UsecaseError(err.Error())
                httpError := currentError.ToHTTPError()
                uc.Logger.LogError(ctx, "Refresh falhou", currentError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">uc.Logger.Info(ctx, "Token refreshed successfully", logger.Fields{
                "ip": c.ClientIP(),
        })
        c.JSON(http.StatusOK, entities.LoginResponseEntity{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    token.ExpiresIn,
        })</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package usecases

import (
        "net/http"

        "github.com/Nerzal/gocloak/v13"
        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/auth/domain/entities"
        "github.com/gin-gonic/gin"
)

// RegisterUser creates a new user account in SpoolIQ
// @Summary User Registration
// @Schemes
// @Description Register a new user account in SpoolIQ
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body entities.RequestRegisterEntity true "Registration data"
// @Success 201 {object} entities.RegisterResponseEntity "Successful registration"
// @Failure 400 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/register [post]
// @Example request {"email": "user@example.com", "password": "SecurePass123", "firstName": "John", "lastName": "Doe"}
// @Example response {"message": "User registered successfully", "userID": "uuid", "email": "user@example.com"}
func (uc *authUseCaseImpl) RegisterUser(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        registerData := new(entities.RequestRegisterEntity)

        uc.Logger.Info(ctx, "Registration attempt", logger.Fields{
                "ip":         c.ClientIP(),
                "user_agent": c.Request.UserAgent(),
        })

        err := c.BindJSON(&amp;registerData)
        if err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrUsecase, err.Error(), nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Invalid registration payload", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate registration data
        <span class="cov0" title="0">if err := registerData.Validate(); err != nil </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrEntity, "Registration validation failed", nil, err)
                httpError := internalError.ToHTTPError()
                uc.Logger.LogError(ctx, "Registration validation failed", internalError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">existingUsers, err := uc.KeycloakClient.GetUsers(
                ctx,
                "", // We need admin token here - this is a limitation
                uc.KeycloakAccessData.Realm,
                gocloak.GetUsersParams{
                        Email: &amp;registerData.Email,
                        Exact: gocloak.BoolP(true),
                },
        )

        if err == nil &amp;&amp; len(existingUsers) &gt; 0 </span><span class="cov0" title="0">{
                internalError := errors.NewAppError(coreEntities.ErrConflict, "User already exists", nil, nil)
                httpError := internalError.ToHTTPError()
                uc.Logger.Warning(ctx, "Registration attempt with existing email", logger.Fields{
                        "email": registerData.Email,
                })
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                return
        }</span>

        // For now, we'll return a simulated response since we need admin token to create users
        // In a real implementation, this would integrate with the user service or use a public registration flow
        <span class="cov0" title="0">response := entities.RegisterResponseEntity{
                Message: "Registration request received. Account activation pending.",
                Email:   registerData.Email,
                UserID:  "pending", // Would be generated after admin approval or email verification
        }

        uc.Logger.Info(ctx, "Registration request received", logger.Fields{
                "email":      registerData.Email,
                "first_name": registerData.FirstName,
                "last_name":  registerData.LastName,
        })

        c.JSON(http.StatusCreated, response)</span>
}</pre>
		
		<pre class="file" id="file35" style="display: none">package usecases

import (
        "github.com/Nerzal/gocloak/v13"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/gin-gonic/gin"
)

// AuthUseCase define os casos de uso relacionados à autenticação.
type AuthUseCase interface {
        // ValidateLogin realiza a validação do login do usuário.
        ValidateLogin(c *gin.Context)
        // Logout realiza o logout do usuário.
        Logout(c *gin.Context)
        // RefreshAuthToken renova o token de autenticação do usuário.
        RefreshAuthToken(c *gin.Context)
        // ValidateToken valida o token de autenticação atual.
        ValidateToken(c *gin.Context)
        // RegisterUser creates a new user account.
        RegisterUser(c *gin.Context)
        // ForgotPassword handles password reset requests.
        ForgotPassword(c *gin.Context)
}

// authUseCaseImpl é a implementação de AuthUseCase.
type authUseCaseImpl struct {
        KeycloakClient     *gocloak.GoCloak
        KeycloakAccessData entities.KeyCloakDataEntity
        Logger             logger.Logger
}

// NewAuthUseCase cria uma nova instância de AuthUseCase.
func NewAuthUseCase(client *gocloak.GoCloak, keycloakData entities.KeyCloakDataEntity, logger logger.Logger) AuthUseCase <span class="cov0" title="0">{
        return &amp;authUseCaseImpl{
                KeycloakClient:     client,
                KeycloakAccessData: keycloakData,
                Logger:             logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package usecases

import (
        "net/http"
        "strings"

        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/gin-gonic/gin"
)

// ValidateToken checks if the provided access token is valid.
// @Summary Validate Auth Token
// @Schemes
// @Description Validate the current access token
// @Tags Auth
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer access token"
// @Success 200 {object} bool "Token is valid"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /auth/validate [post]
// @Example request {"Authorization": "Bearer &lt;access-token&gt;"}
// @Example response true
func (uc *authUseCaseImpl) ValidateToken(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        authorization := c.GetHeader("Authorization")
        uc.Logger.Info(ctx, "Token validation attempt", logger.Fields{
                "ip": c.ClientIP(),
        })
        token := strings.Split(authorization, " ")[1]
        rptResult, err := uc.KeycloakClient.RetrospectToken(
                c,
                token,
                uc.KeycloakAccessData.ClientID,
                uc.KeycloakAccessData.ClientSecret,
                uc.KeycloakAccessData.Realm,
        )
        if err != nil </span><span class="cov0" title="0">{
                currentError := errors.NewAppError(entities.ErrUsecase, err.Error(), nil, err)
                httpError := currentError.ToHTTPError()
                uc.Logger.LogError(ctx, "Token validation failed", currentError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">isTokenValid := *rptResult.Active
        if !isTokenValid </span><span class="cov0" title="0">{
                currentError := errors.NewAppError(entities.ErrInvalidToken, "Token is invalid", nil, nil)
                httpError := currentError.ToHTTPError()
                uc.Logger.LogError(ctx, "Token is invalid", currentError)
                c.AbortWithStatusJSON(httpError.StatusCode, httpError)
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">uc.Logger.Info(ctx, "Token is valid", logger.Fields{
                "ip": c.ClientIP(),
        })
        c.JSON(http.StatusOK, true)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package entities

// CostBreakdown representa o detalhamento completo de custos de um orçamento
// @Description Detalhamento completo de custos de impressão 3D
type CostBreakdown struct {
        // Entrada de dados
        Filaments []FilamentLineInput `json:"filaments" validate:"required,min=1"`
        Machine   MachineInput        `json:"machine" validate:"required"`
        Energy    EnergyInput         `json:"energy" validate:"required"`
        Costs     CostInput           `json:"costs" validate:"required"`
        Margins   MarginInput         `json:"margins" validate:"required"`

        // Resultados de cálculo
        Results CalculationResults `json:"results"`
}

// FilamentLineInput representa uma linha de filamento para cálculo
// @Description Dados de entrada para linha de filamento
// @Example {"label": "Cor Principal", "grams": 63.53, "meters": null, "price_per_kg": 125.0}
type FilamentLineInput struct {
        Label         string   `json:"label" validate:"required,min=1"`
        Grams         float64  `json:"grams" validate:"required,min=0"`
        Meters        *float64 `json:"meters,omitempty" validate:"omitempty,min=0"`
        PricePerKg    float64  `json:"price_per_kg" validate:"required,min=0"`
        PricePerMeter *float64 `json:"price_per_meter,omitempty" validate:"omitempty,min=0"`
}

// MachineInput representa os dados da impressora para cálculo
// @Description Dados de entrada da impressora
// @Example {"name": "BambuLab A1 Combo", "watt": 95, "idle_factor": 0, "hours_decimal": 7.233}
type MachineInput struct {
        Name         string  `json:"name" validate:"required,min=1"`
        Watt         float64 `json:"watt" validate:"required,min=0"`
        IdleFactor   float64 `json:"idle_factor" validate:"min=0,max=1"`
        HoursDecimal float64 `json:"hours_decimal" validate:"required,min=0"`
}

// EnergyInput representa os dados de energia para cálculo
// @Description Dados de entrada de energia
// @Example {"base_tariff": 0.804, "flag_surcharge": 0}
type EnergyInput struct {
        BaseTariff    float64 `json:"base_tariff" validate:"required,min=0"`
        FlagSurcharge float64 `json:"flag_surcharge" validate:"min=0"`
}

// CostInput representa os custos operacionais para cálculo
// @Description Dados de entrada de custos operacionais
// @Example {"wear_pct": 10, "overhead": 8, "op_rate_per_hour": 30, "op_minutes": 20, "cad_rate_per_hour": 80, "cad_minutes": 0}
type CostInput struct {
        WearPct        float64 `json:"wear_pct" validate:"min=0,max=100"`
        Overhead       float64 `json:"overhead" validate:"min=0"`
        OpRatePerHour  float64 `json:"op_rate_per_hour" validate:"min=0"`
        OpMinutes      float64 `json:"op_minutes" validate:"min=0"`
        CadRatePerHour float64 `json:"cad_rate_per_hour" validate:"min=0"`
        CadMinutes     float64 `json:"cad_minutes" validate:"min=0"`
}

// MarginInput representa as margens para cálculo
// @Description Dados de entrada de margens
// @Example {"only_print_pct": 70, "light_adjust_pct": 90, "full_model_pct": 120, "extra_cad_light_min": 30, "extra_cad_full_min": 90}
type MarginInput struct {
        OnlyPrintPct     float64 `json:"only_print_pct" validate:"min=0"`
        LightAdjustPct   float64 `json:"light_adjust_pct" validate:"min=0"`
        FullModelPct     float64 `json:"full_model_pct" validate:"min=0"`
        ExtraCadLightMin float64 `json:"extra_cad_light_min" validate:"min=0"`
        ExtraCadFullMin  float64 `json:"extra_cad_full_min" validate:"min=0"`
}

// CalculationResults representa os resultados dos cálculos
// @Description Resultados completos dos cálculos
type CalculationResults struct {
        // Custos por linha de filamento
        FilamentCosts []FilamentCostResult `json:"filament_costs"`

        // Energia
        KWh        float64 `json:"kwh"`
        EnergyCost float64 `json:"energy_cost"`

        // Custos agregados
        MaterialsCost float64 `json:"materials_cost"`
        WearCost      float64 `json:"wear_cost"`
        LaborCost     float64 `json:"labor_cost"`
        DirectCost    float64 `json:"direct_cost"`

        // Pacotes de venda
        Packages []PackageResult `json:"packages"`

        // Métricas
        Markup          float64 `json:"markup"`
        EffectiveMargin float64 `json:"effective_margin"`
}

// FilamentCostResult representa o custo calculado de uma linha de filamento
// @Description Resultado do cálculo de custo de filamento
type FilamentCostResult struct {
        Label string  `json:"label"`
        Cost  float64 `json:"cost"`
}

// PackageResult representa um pacote de venda com preço calculado
// @Description Resultado de um pacote de venda
type PackageResult struct {
        Type        string  `json:"type"`        // "only_print", "light_adjust", "full_model"
        Description string  `json:"description"` // Descrição amigável
        Price       float64 `json:"price"`
        Markup      float64 `json:"markup"`
        Margin      float64 `json:"margin"`
}

// CalculateCost calcula o custo de uma linha de filamento baseado nos dados de entrada
func (f *FilamentLineInput) CalculateCost() float64 <span class="cov8" title="1">{
        if f.Meters != nil &amp;&amp; f.PricePerMeter != nil &amp;&amp; *f.Meters &gt; 0 </span><span class="cov8" title="1">{
                // Usar preço por metro se disponível
                return *f.PricePerMeter * *f.Meters
        }</span>
        // Usar preço por kg
        <span class="cov8" title="1">return (f.PricePerKg / 1000) * f.Grams</span>
}

// CalculateKWh calcula o consumo de energia em kWh
func (m *MachineInput) CalculateKWh() float64 <span class="cov8" title="1">{
        effectiveWatt := m.Watt * (1 + m.IdleFactor)
        return (effectiveWatt / 1000) * m.HoursDecimal
}</span>

// CalculateEnergyCost calcula o custo da energia
func (e *EnergyInput) CalculateEnergyCost(kWh float64) float64 <span class="cov8" title="1">{
        totalTariff := e.BaseTariff + e.FlagSurcharge
        return kWh * totalTariff
}</span>

// CalculateWearCost calcula o custo de desgaste
func (c *CostInput) CalculateWearCost(materialsCost float64) float64 <span class="cov8" title="1">{
        return materialsCost * (c.WearPct / 100)
}</span>

// CalculateLaborCost calcula o custo de mão de obra
func (c *CostInput) CalculateLaborCost() float64 <span class="cov8" title="1">{
        opCost := (c.OpRatePerHour * c.OpMinutes) / 60
        cadCost := (c.CadRatePerHour * c.CadMinutes) / 60
        return opCost + cadCost
}</span>

// CalculatePackagePrice calcula o preço de um pacote específico
func (m *MarginInput) CalculatePackagePrice(directCost float64, packageType string) float64 <span class="cov8" title="1">{
        var marginPct float64
        var extraCadMinutes float64

        switch packageType </span>{
        case "only_print":<span class="cov8" title="1">
                marginPct = m.OnlyPrintPct</span>
        case "light_adjust":<span class="cov8" title="1">
                marginPct = m.LightAdjustPct
                extraCadMinutes = m.ExtraCadLightMin</span>
        case "full_model":<span class="cov8" title="1">
                marginPct = m.FullModelPct
                extraCadMinutes = m.ExtraCadFullMin</span>
        default:<span class="cov0" title="0">
                marginPct = m.OnlyPrintPct</span>
        }

        // Custo base com margem
        <span class="cov8" title="1">basePriceWithMargin := directCost * (1 + marginPct/100)

        // Adicionar tempo extra de CAD se houver
        if extraCadMinutes &gt; 0 </span><span class="cov8" title="1">{
                // Assumir taxa de CAD de 80 R$/hora como padrão
                extraCadCost := (80 * extraCadMinutes) / 60
                return basePriceWithMargin + extraCadCost
        }</span>

        <span class="cov8" title="1">return basePriceWithMargin</span>
}

// GetEffectiveMargin calcula a margem efetiva
func GetEffectiveMargin(directCost, finalPrice float64) float64 <span class="cov8" title="1">{
        if directCost &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return ((finalPrice - directCost) / directCost) * 100</span>
}

// GetMarkup calcula o markup
func GetMarkup(directCost, finalPrice float64) float64 <span class="cov8" title="1">{
        if finalPrice &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return ((finalPrice - directCost) / finalPrice) * 100</span>
}</pre>
		
		<pre class="file" id="file38" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/calculation/domain/entities"
)

// CalculationService implementa todas as fórmulas de cálculo do SpoolIq
type CalculationService interface {
        Calculate(ctx context.Context, input entities.CostBreakdown) (*entities.CostBreakdown, error)
}

type calculationServiceImpl struct {
        logger logger.Logger
}

// NewCalculationService cria uma nova instância do serviço de cálculo
func NewCalculationService(logger logger.Logger) CalculationService <span class="cov8" title="1">{
        return &amp;calculationServiceImpl{
                logger: logger,
        }
}</span>

// Calculate executa o cálculo completo baseado nas fórmulas especificadas
func (s *calculationServiceImpl) Calculate(ctx context.Context, input entities.CostBreakdown) (*entities.CostBreakdown, error) <span class="cov8" title="1">{
        s.logger.Info(ctx, "Iniciando cálculo de custos", map[string]interface{}{
                "filament_lines": len(input.Filaments),
                "machine":        input.Machine.Name,
        })

        result := input

        // 1. Calcular custos de filamentos
        filamentCosts, totalFilamentCost := s.calculateFilamentCosts(input.Filaments)

        // 2. Calcular energia
        kWh := input.Machine.CalculateKWh()
        energyCost := input.Energy.CalculateEnergyCost(kWh)

        // 3. Calcular custo dos materiais (fórmula: Σ CustoFilamento_i + CustoEnergia)
        materialsCost := totalFilamentCost + energyCost

        // 4. Calcular custo de desgaste (fórmula: CustoMateriais * (wear_pct/100))
        wearCost := input.Costs.CalculateWearCost(materialsCost)

        // 5. Calcular custo de mão de obra (fórmula: (op_rate_per_hour * op_minutes/60) + (cad_rate_per_hour * cad_minutes/60))
        laborCost := input.Costs.CalculateLaborCost()

        // 6. Calcular custo direto (fórmula: CustoMateriais + CustoDesgaste + overhead + CustoMaoObra)
        directCost := materialsCost + wearCost + input.Costs.Overhead + laborCost

        // 7. Calcular pacotes de venda (fórmula: CustoDireto * (1 + margem/100))
        packages := s.calculatePackages(directCost, input.Margins, input.Costs.CadRatePerHour)

        // 8. Calcular métricas finais
        markup, effectiveMargin := s.calculateMetrics(directCost, packages)

        // Montar resultado
        result.Results = entities.CalculationResults{
                FilamentCosts: filamentCosts,
                KWh:           kWh,
                EnergyCost:    energyCost,
                MaterialsCost: materialsCost,
                WearCost:      wearCost,
                LaborCost:     laborCost,
                DirectCost:    directCost,
                Packages:      packages,
                Markup:        markup,
                EffectiveMargin: effectiveMargin,
        }

        s.logger.Info(ctx, "Cálculo concluído", map[string]interface{}{
                "direct_cost":      directCost,
                "materials_cost":   materialsCost,
                "energy_cost":      energyCost,
                "packages_count":   len(packages),
                "effective_margin": effectiveMargin,
        })

        return &amp;result, nil
}</span>

// calculateFilamentCosts calcula o custo de cada linha de filamento
func (s *calculationServiceImpl) calculateFilamentCosts(filaments []entities.FilamentLineInput) ([]entities.FilamentCostResult, float64) <span class="cov8" title="1">{
        results := make([]entities.FilamentCostResult, len(filaments))
        totalCost := 0.0

        for i, filament := range filaments </span><span class="cov8" title="1">{
                cost := filament.CalculateCost()
                results[i] = entities.FilamentCostResult{
                        Label: filament.Label,
                        Cost:  cost,
                }
                totalCost += cost
        }</span>

        <span class="cov8" title="1">return results, totalCost</span>
}

// calculatePackages calcula os preços dos diferentes pacotes de venda
func (s *calculationServiceImpl) calculatePackages(directCost float64, margins entities.MarginInput, cadRatePerHour float64) []entities.PackageResult <span class="cov8" title="1">{
        packages := []entities.PackageResult{
                {
                        Type:        "only_print",
                        Description: "Somente Impressão",
                        Price:       margins.CalculatePackagePrice(directCost, "only_print"),
                },
                {
                        Type:        "light_adjust",
                        Description: "Impressão + Ajustes Leves",
                        Price:       margins.CalculatePackagePrice(directCost, "light_adjust"),
                },
                {
                        Type:        "full_model",
                        Description: "Impressão + Modelagem Completa",
                        Price:       margins.CalculatePackagePrice(directCost, "full_model"),
                },
        }

        // Calcular markup e margem para cada pacote
        for i := range packages </span><span class="cov8" title="1">{
                packages[i].Markup = entities.GetMarkup(directCost, packages[i].Price)
                packages[i].Margin = entities.GetEffectiveMargin(directCost, packages[i].Price)
        }</span>

        <span class="cov8" title="1">return packages</span>
}

// calculateMetrics calcula as métricas finais baseadas no pacote médio
func (s *calculationServiceImpl) calculateMetrics(directCost float64, packages []entities.PackageResult) (float64, float64) <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        // Usar o pacote de ajustes leves como referência (pacote médio)
        <span class="cov8" title="1">var referencePackage entities.PackageResult
        for _, pkg := range packages </span><span class="cov8" title="1">{
                if pkg.Type == "light_adjust" </span><span class="cov8" title="1">{
                        referencePackage = pkg
                        break</span>
                }
        }

        // Se não encontrou light_adjust, usar o primeiro pacote
        <span class="cov8" title="1">if referencePackage.Type == "" </span><span class="cov0" title="0">{
                referencePackage = packages[0]
        }</span>

        <span class="cov8" title="1">markup := entities.GetMarkup(directCost, referencePackage.Price)
        effectiveMargin := entities.GetEffectiveMargin(directCost, referencePackage.Price)

        return markup, effectiveMargin</span>
}

// ValidateInput valida os dados de entrada para o cálculo
func (s *calculationServiceImpl) ValidateInput(ctx context.Context, input entities.CostBreakdown) error <span class="cov8" title="1">{
        if len(input.Filaments) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("pelo menos uma linha de filamento é obrigatória")
        }</span>

        <span class="cov8" title="1">for i, filament := range input.Filaments </span><span class="cov8" title="1">{
                if filament.Grams &lt;= 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("linha de filamento %d: gramas deve ser maior que zero", i+1)
                }</span>
                <span class="cov8" title="1">if filament.PricePerKg &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("linha de filamento %d: preço por kg deve ser maior que zero", i+1)
                }</span>
                <span class="cov8" title="1">if filament.Meters != nil &amp;&amp; *filament.Meters &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("linha de filamento %d: metros deve ser maior que zero quando especificado", i+1)
                }</span>
                <span class="cov8" title="1">if filament.PricePerMeter != nil &amp;&amp; *filament.PricePerMeter &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("linha de filamento %d: preço por metro deve ser maior que zero quando especificado", i+1)
                }</span>
        }

        <span class="cov8" title="1">if input.Machine.Watt &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("potência da máquina deve ser maior que zero")
        }</span>

        <span class="cov8" title="1">if input.Machine.HoursDecimal &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("tempo de impressão deve ser maior que zero")
        }</span>

        <span class="cov8" title="1">if input.Energy.BaseTariff &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("tarifa base de energia deve ser maior que zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file39" style="display: none">package services

import (
        "bytes"
        "context"
        "encoding/csv"
        "fmt"
        "strconv"

        "github.com/RodolfoBonis/spooliq/features/export/domain/entities"
)

type CSVExportService struct{}

// NewCSVExportService cria uma nova instância do serviço de export CSV
func NewCSVExportService() *CSVExportService <span class="cov0" title="0">{
        return &amp;CSVExportService{}
}</span>

// Generate gera um export em formato CSV
func (s *CSVExportService) Generate(ctx context.Context, data *entities.ExportData) ([]byte, error) <span class="cov0" title="0">{
        if err := data.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        writer := csv.NewWriter(&amp;buf)

        // Escrever cabeçalho de metadados
        if err := s.writeMetadata(writer, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Escrever dados da quote
        <span class="cov0" title="0">if err := s.writeQuoteData(writer, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Escrever linhas de filamento
        <span class="cov0" title="0">if err := s.writeFilamentLines(writer, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Escrever perfis
        <span class="cov0" title="0">if err := s.writeProfiles(writer, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Escrever cálculos se disponíveis
        <span class="cov0" title="0">if data.Calculation != nil </span><span class="cov0" title="0">{
                if err := s.writeCalculationData(writer, data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, entities.ErrExportGeneration
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *CSVExportService) writeMetadata(writer *csv.Writer, data *entities.ExportData) error <span class="cov0" title="0">{
        // Seção de metadados
        records := [][]string{
                {"=== METADADOS ==="},
                {"Data de Geração", data.Metadata.GeneratedAt.Format("02/01/2006 15:04:05")},
                {"Gerado por", data.Metadata.GeneratedBy},
                {"Formato", string(data.Metadata.Format)},
                {"Versão", data.Metadata.Version},
                {"Sistema", data.Metadata.SystemInfo.AppName + " " + data.Metadata.SystemInfo.AppVersion},
                {""},
        }

        return writer.WriteAll(records)
}</span>

func (s *CSVExportService) writeQuoteData(writer *csv.Writer, data *entities.ExportData) error <span class="cov0" title="0">{
        // Seção da quote
        records := [][]string{
                {"=== ORÇAMENTO ==="},
                {"ID", strconv.FormatUint(uint64(data.Quote.ID), 10)},
                {"Título", data.Quote.Title},
                {"Observações", data.Quote.Notes},
                {"Proprietário", data.Quote.OwnerUserID},
                {"Criado em", data.Quote.CreatedAt.Format("02/01/2006 15:04:05")},
                {"Atualizado em", data.Quote.UpdatedAt.Format("02/01/2006 15:04:05")},
                {""},
        }

        return writer.WriteAll(records)
}</span>

func (s *CSVExportService) writeFilamentLines(writer *csv.Writer, data *entities.ExportData) error <span class="cov0" title="0">{
        if len(data.Quote.FilamentLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Seção de filamentos
        <span class="cov0" title="0">records := [][]string{
                {"=== FILAMENTOS ==="},
                {"Nome", "Marca", "Material", "Cor", "Cor Hex", "Preço/Kg", "Preço/Metro", "Peso (g)", "Comprimento (m)"},
        }

        for _, line := range data.Quote.FilamentLines </span><span class="cov0" title="0">{
                pricePerMeter := ""
                if line.FilamentSnapshotPricePerMeter != nil </span><span class="cov0" title="0">{
                        pricePerMeter = fmt.Sprintf("%.4f", *line.FilamentSnapshotPricePerMeter)
                }</span>

                <span class="cov0" title="0">lengthMeters := ""
                if line.LengthMeters != nil </span><span class="cov0" title="0">{
                        lengthMeters = fmt.Sprintf("%.3f", *line.LengthMeters)
                }</span>

                <span class="cov0" title="0">record := []string{
                        line.FilamentSnapshotName,
                        line.FilamentSnapshotBrand,
                        line.FilamentSnapshotMaterial,
                        line.FilamentSnapshotColor,
                        line.FilamentSnapshotColorHex,
                        fmt.Sprintf("%.2f", line.FilamentSnapshotPricePerKg),
                        pricePerMeter,
                        fmt.Sprintf("%.3f", line.WeightGrams),
                        lengthMeters,
                }
                records = append(records, record)</span>
        }

        <span class="cov0" title="0">records = append(records, []string{""})
        return writer.WriteAll(records)</span>
}

func (s *CSVExportService) writeProfiles(writer *csv.Writer, data *entities.ExportData) error <span class="cov0" title="0">{
        var records [][]string

        // Perfil da máquina
        if data.Quote.MachineProfile != nil </span><span class="cov0" title="0">{
                mp := data.Quote.MachineProfile
                records = append(records, [][]string{
                        {"=== PERFIL DA MÁQUINA ==="},
                        {"Nome", mp.Name},
                        {"Marca", mp.Brand},
                        {"Modelo", mp.Model},
                        {"Potência (W)", fmt.Sprintf("%.0f", mp.Watt)},
                        {"Fator Ocioso", fmt.Sprintf("%.2f", mp.IdleFactor)},
                        {"Descrição", mp.Description},
                        {"URL", mp.URL},
                        {""},
                }...)
        }</span>

        // Perfil de energia
        <span class="cov0" title="0">if data.Quote.EnergyProfile != nil </span><span class="cov0" title="0">{
                ep := data.Quote.EnergyProfile
                records = append(records, [][]string{
                        {"=== PERFIL DE ENERGIA ==="},
                        {"Tarifa Base", fmt.Sprintf("%.3f", ep.BaseTariff)},
                        {"Taxa Bandeira", fmt.Sprintf("%.3f", ep.FlagSurcharge)},
                        {"Localização", ep.Location},
                        {"Ano", strconv.Itoa(ep.Year)},
                        {"Descrição", ep.Description},
                        {""},
                }...)
        }</span>

        // Perfil de custos
        <span class="cov0" title="0">if data.Quote.CostProfile != nil </span><span class="cov0" title="0">{
                cp := data.Quote.CostProfile
                records = append(records, [][]string{
                        {"=== PERFIL DE CUSTOS ==="},
                        {"Desgaste (%)", fmt.Sprintf("%.2f", cp.WearPercentage)},
                        {"Custos Fixos", fmt.Sprintf("%.2f", cp.OverheadAmount)},
                        {"Descrição", cp.Description},
                        {""},
                }...)
        }</span>

        // Perfil de margens
        <span class="cov0" title="0">if data.Quote.MarginProfile != nil </span><span class="cov0" title="0">{
                mp := data.Quote.MarginProfile
                records = append(records, [][]string{
                        {"=== PERFIL DE MARGENS ==="},
                        {"Margem Só Impressão (%)", fmt.Sprintf("%.2f", mp.PrintingOnlyMargin)},
                        {"Margem Impressão Plus (%)", fmt.Sprintf("%.2f", mp.PrintingPlusMargin)},
                        {"Margem Serviço Completo (%)", fmt.Sprintf("%.2f", mp.FullServiceMargin)},
                        {"Taxa Operador (R$/h)", fmt.Sprintf("%.2f", mp.OperatorRatePerHour)},
                        {"Taxa Modelador (R$/h)", fmt.Sprintf("%.2f", mp.ModelerRatePerHour)},
                        {"Descrição", mp.Description},
                        {""},
                }...)
        }</span>

        <span class="cov0" title="0">if len(records) &gt; 0 </span><span class="cov0" title="0">{
                return writer.WriteAll(records)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *CSVExportService) writeCalculationData(writer *csv.Writer, data *entities.ExportData) error <span class="cov0" title="0">{
        calc := data.Calculation

        records := [][]string{
                {"=== RESULTADOS DOS CÁLCULOS ==="},
                {"Custo de Materiais", fmt.Sprintf("R$ %.2f", calc.MaterialsCost)},
                {"Custo de Energia", fmt.Sprintf("R$ %.2f", calc.EnergyCost)},
                {"Custo de Desgaste", fmt.Sprintf("R$ %.2f", calc.WearCost)},
                {"Custo de Mão de Obra", fmt.Sprintf("R$ %.2f", calc.LaborCost)},
                {"Custo Direto Total", fmt.Sprintf("R$ %.2f", calc.DirectCost)},
                {"Energia Consumida", fmt.Sprintf("%.3f kWh", calc.KWh)},
                {"Markup", fmt.Sprintf("%.2f%%", calc.Markup)},
                {"Margem Efetiva", fmt.Sprintf("%.2f%%", calc.EffectiveMargin)},
                {""},
        }

        // Custos detalhados por filamento
        if len(calc.FilamentCosts) &gt; 0 </span><span class="cov0" title="0">{
                records = append(records, []string{"=== CUSTOS POR FILAMENTO ==="})
                records = append(records, []string{"Filamento", "Custo"})

                for _, fc := range calc.FilamentCosts </span><span class="cov0" title="0">{
                        records = append(records, []string{
                                fc.Label,
                                fmt.Sprintf("R$ %.2f", fc.Cost),
                        })
                }</span>
                <span class="cov0" title="0">records = append(records, []string{""})</span>
        }

        // Pacotes de preços
        <span class="cov0" title="0">if len(calc.Packages) &gt; 0 </span><span class="cov0" title="0">{
                records = append(records, []string{"=== PACOTES DE PREÇOS ==="})
                records = append(records, []string{"Tipo", "Descrição", "Preço", "Markup", "Margem"})

                for _, pkg := range calc.Packages </span><span class="cov0" title="0">{
                        records = append(records, []string{
                                pkg.Type,
                                pkg.Description,
                                fmt.Sprintf("R$ %.2f", pkg.Price),
                                fmt.Sprintf("%.2f%%", pkg.Markup),
                                fmt.Sprintf("%.2f%%", pkg.Margin),
                        })
                }</span>
        }

        <span class="cov0" title="0">return writer.WriteAll(records)</span>
}

// GetContentType retorna o content type para CSV
func (s *CSVExportService) GetContentType() string <span class="cov0" title="0">{
        return "text/csv"
}</span>

// GetFileExtension retorna a extensão para arquivos CSV
func (s *CSVExportService) GetFileExtension() string <span class="cov0" title="0">{
        return "csv"
}</pre>
		
		<pre class="file" id="file40" style="display: none">package services

import (
        "context"
        "encoding/json"

        "github.com/RodolfoBonis/spooliq/features/export/domain/entities"
)

type JSONExportService struct{}

// NewJSONExportService cria uma nova instância do serviço de export JSON
func NewJSONExportService() *JSONExportService <span class="cov0" title="0">{
        return &amp;JSONExportService{}
}</span>

// Generate gera um export em formato JSON
func (s *JSONExportService) Generate(ctx context.Context, data *entities.ExportData) ([]byte, error) <span class="cov0" title="0">{
        if err := data.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Estrutura otimizada para JSON export
        <span class="cov0" title="0">exportJSON := map[string]interface{}{
                "metadata": data.Metadata,
                "quote": map[string]interface{}{
                        "id":           data.Quote.ID,
                        "title":        data.Quote.Title,
                        "notes":        data.Quote.Notes,
                        "owner_user_id": data.Quote.OwnerUserID,
                        "created_at":   data.Quote.CreatedAt,
                        "updated_at":   data.Quote.UpdatedAt,
                        "filament_lines": data.Quote.FilamentLines,
                        "machine_profile": data.Quote.MachineProfile,
                        "energy_profile": data.Quote.EnergyProfile,
                        "cost_profile": data.Quote.CostProfile,
                        "margin_profile": data.Quote.MarginProfile,
                },
        }

        // Adicionar cálculos se disponíveis
        if data.Calculation != nil </span><span class="cov0" title="0">{
                exportJSON["calculation"] = data.Calculation
        }</span>

        // Serializar para JSON com formatação bonita
        <span class="cov0" title="0">jsonData, err := json.MarshalIndent(exportJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, entities.ErrExportGeneration
        }</span>

        <span class="cov0" title="0">return jsonData, nil</span>
}

// GetContentType retorna o content type para JSON
func (s *JSONExportService) GetContentType() string <span class="cov0" title="0">{
        return "application/json"
}</span>

// GetFileExtension retorna a extensão para arquivos JSON
func (s *JSONExportService) GetFileExtension() string <span class="cov0" title="0">{
        return "json"
}</pre>
		
		<pre class="file" id="file41" style="display: none">package services

import (
        "bytes"
        "context"
        "fmt"
        "strconv"

        "github.com/jung-kurt/gofpdf"
        "github.com/RodolfoBonis/spooliq/features/export/domain/entities"
)

type PDFExportService struct{}

// NewPDFExportService cria uma nova instância do serviço de export PDF
func NewPDFExportService() *PDFExportService <span class="cov0" title="0">{
        return &amp;PDFExportService{}
}</span>

// Generate gera um export em formato PDF
func (s *PDFExportService) Generate(ctx context.Context, data *entities.ExportData) ([]byte, error) <span class="cov0" title="0">{
        if err := data.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Criar novo documento PDF
        <span class="cov0" title="0">pdf := gofpdf.New("P", "mm", "A4", "")
        pdf.AddPage()

        // Adicionar header
        s.addHeader(pdf, data)

        // Adicionar informações da quote
        s.addQuoteInfo(pdf, data)

        // Adicionar filamentos
        s.addFilamentLines(pdf, data)

        // Adicionar perfis
        s.addProfiles(pdf, data)

        // Adicionar cálculos se disponíveis
        if data.Calculation != nil </span><span class="cov0" title="0">{
                s.addCalculationResults(pdf, data)
        }</span>

        // Adicionar footer
        <span class="cov0" title="0">s.addFooter(pdf, data)

        // Gerar o PDF em buffer
        var buf bytes.Buffer
        err := pdf.Output(&amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, entities.ErrExportGeneration
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *PDFExportService) addHeader(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        // Título principal
        pdf.SetFont("Arial", "B", 20)
        pdf.SetTextColor(0, 100, 150)
        pdf.Cell(0, 15, "SpoolIQ - Orçamento de Impressão 3D")
        pdf.Ln(20)

        // Informações do documento
        pdf.SetFont("Arial", "", 10)
        pdf.SetTextColor(100, 100, 100)
        pdf.Cell(50, 5, "Gerado em: "+data.Metadata.GeneratedAt.Format("02/01/2006 15:04:05"))
        pdf.Ln(5)
        pdf.Cell(50, 5, "Por: "+data.Metadata.GeneratedBy)
        pdf.Ln(10)

        // Linha separadora
        pdf.SetDrawColor(200, 200, 200)
        pdf.Line(10, pdf.GetY(), 200, pdf.GetY())
        pdf.Ln(10)
}</span>

func (s *PDFExportService) addQuoteInfo(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        // Seção de informações da quote
        pdf.SetFont("Arial", "B", 14)
        pdf.SetTextColor(0, 0, 0)
        pdf.Cell(0, 8, "Informações do Orçamento")
        pdf.Ln(12)

        pdf.SetFont("Arial", "", 10)

        // ID e Título
        pdf.Cell(30, 6, "ID:")
        pdf.SetFont("Arial", "B", 10)
        pdf.Cell(0, 6, strconv.FormatUint(uint64(data.Quote.ID), 10))
        pdf.Ln(8)

        pdf.SetFont("Arial", "", 10)
        pdf.Cell(30, 6, "Título:")
        pdf.SetFont("Arial", "B", 10)
        pdf.Cell(0, 6, data.Quote.Title)
        pdf.Ln(8)

        // Datas
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(30, 6, "Criado em:")
        pdf.Cell(50, 6, data.Quote.CreatedAt.Format("02/01/2006 15:04:05"))
        pdf.Cell(30, 6, "Atualizado em:")
        pdf.Cell(0, 6, data.Quote.UpdatedAt.Format("02/01/2006 15:04:05"))
        pdf.Ln(8)

        // Observações se houver
        if data.Quote.Notes != "" </span><span class="cov0" title="0">{
                pdf.Cell(30, 6, "Observações:")
                pdf.Ln(6)
                pdf.SetFont("Arial", "I", 9)
                pdf.MultiCell(0, 5, data.Quote.Notes, "0", "L", false)
                pdf.Ln(5)
        }</span>

        <span class="cov0" title="0">pdf.Ln(5)</span>
}

func (s *PDFExportService) addFilamentLines(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        if len(data.Quote.FilamentLines) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Título da seção
        <span class="cov0" title="0">pdf.SetFont("Arial", "B", 14)
        pdf.Cell(0, 8, "Filamentos")
        pdf.Ln(12)

        // Cabeçalho da tabela
        pdf.SetFont("Arial", "B", 9)
        pdf.SetFillColor(230, 230, 230)

        colWidths := []float64{50, 25, 20, 25, 25, 25}
        headers := []string{"Nome", "Marca", "Material", "Cor", "Peso (g)", "Preço/Kg"}

        for i, header := range headers </span><span class="cov0" title="0">{
                pdf.CellFormat(colWidths[i], 8, header, "1", 0, "C", true, 0, "")
        }</span>
        <span class="cov0" title="0">pdf.Ln(8)

        // Dados dos filamentos
        pdf.SetFont("Arial", "", 8)
        pdf.SetFillColor(255, 255, 255)

        for _, line := range data.Quote.FilamentLines </span><span class="cov0" title="0">{
                values := []string{
                        s.truncateString(line.FilamentSnapshotName, 25),
                        s.truncateString(line.FilamentSnapshotBrand, 15),
                        s.truncateString(line.FilamentSnapshotMaterial, 10),
                        s.truncateString(line.FilamentSnapshotColor, 15),
                        fmt.Sprintf("%.1f", line.WeightGrams),
                        fmt.Sprintf("R$ %.2f", line.FilamentSnapshotPricePerKg),
                }

                for i, value := range values </span><span class="cov0" title="0">{
                        pdf.CellFormat(colWidths[i], 6, value, "1", 0, "C", false, 0, "")
                }</span>
                <span class="cov0" title="0">pdf.Ln(6)</span>
        }

        <span class="cov0" title="0">pdf.Ln(8)</span>
}

func (s *PDFExportService) addProfiles(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        // Perfil da máquina
        if data.Quote.MachineProfile != nil </span><span class="cov0" title="0">{
                s.addProfileSection(pdf, "Perfil da Máquina", [][]string{
                        {"Nome", data.Quote.MachineProfile.Name},
                        {"Marca", data.Quote.MachineProfile.Brand},
                        {"Modelo", data.Quote.MachineProfile.Model},
                        {"Potência", fmt.Sprintf("%.0f W", data.Quote.MachineProfile.Watt)},
                        {"Fator Ocioso", fmt.Sprintf("%.2f", data.Quote.MachineProfile.IdleFactor)},
                })
        }</span>

        // Perfil de energia
        <span class="cov0" title="0">if data.Quote.EnergyProfile != nil </span><span class="cov0" title="0">{
                s.addProfileSection(pdf, "Perfil de Energia", [][]string{
                        {"Tarifa Base", fmt.Sprintf("R$ %.3f/kWh", data.Quote.EnergyProfile.BaseTariff)},
                        {"Taxa Bandeira", fmt.Sprintf("R$ %.3f/kWh", data.Quote.EnergyProfile.FlagSurcharge)},
                        {"Localização", data.Quote.EnergyProfile.Location},
                        {"Ano", strconv.Itoa(data.Quote.EnergyProfile.Year)},
                })
        }</span>

        // Perfil de custos
        <span class="cov0" title="0">if data.Quote.CostProfile != nil </span><span class="cov0" title="0">{
                s.addProfileSection(pdf, "Perfil de Custos", [][]string{
                        {"Desgaste", fmt.Sprintf("%.2f%%", data.Quote.CostProfile.WearPercentage)},
                        {"Custos Fixos", fmt.Sprintf("R$ %.2f", data.Quote.CostProfile.OverheadAmount)},
                })
        }</span>

        // Perfil de margens
        <span class="cov0" title="0">if data.Quote.MarginProfile != nil </span><span class="cov0" title="0">{
                s.addProfileSection(pdf, "Perfil de Margens", [][]string{
                        {"Só Impressão", fmt.Sprintf("%.2f%%", data.Quote.MarginProfile.PrintingOnlyMargin)},
                        {"Impressão Plus", fmt.Sprintf("%.2f%%", data.Quote.MarginProfile.PrintingPlusMargin)},
                        {"Serviço Completo", fmt.Sprintf("%.2f%%", data.Quote.MarginProfile.FullServiceMargin)},
                        {"Taxa Operador", fmt.Sprintf("R$ %.2f/h", data.Quote.MarginProfile.OperatorRatePerHour)},
                        {"Taxa Modelador", fmt.Sprintf("R$ %.2f/h", data.Quote.MarginProfile.ModelerRatePerHour)},
                })
        }</span>
}

func (s *PDFExportService) addProfileSection(pdf *gofpdf.Fpdf, title string, data [][]string) <span class="cov0" title="0">{
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(0, 8, title)
        pdf.Ln(10)

        pdf.SetFont("Arial", "", 9)
        for _, row := range data </span><span class="cov0" title="0">{
                pdf.Cell(50, 6, row[0]+":")
                pdf.Cell(0, 6, row[1])
                pdf.Ln(6)
        }</span>
        <span class="cov0" title="0">pdf.Ln(5)</span>
}

func (s *PDFExportService) addCalculationResults(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        calc := data.Calculation

        // Verificar se há espaço suficiente na página
        if pdf.GetY() &gt; 200 </span><span class="cov0" title="0">{
                pdf.AddPage()
        }</span>

        // Título da seção
        <span class="cov0" title="0">pdf.SetFont("Arial", "B", 14)
        pdf.Cell(0, 8, "Resultados dos Cálculos")
        pdf.Ln(12)

        // Custos principais
        pdf.SetFont("Arial", "B", 10)
        pdf.SetFillColor(240, 240, 240)

        costs := [][]string{
                {"Custo de Materiais", fmt.Sprintf("R$ %.2f", calc.MaterialsCost)},
                {"Custo de Energia", fmt.Sprintf("R$ %.2f", calc.EnergyCost)},
                {"Custo de Desgaste", fmt.Sprintf("R$ %.2f", calc.WearCost)},
                {"Custo de Mão de Obra", fmt.Sprintf("R$ %.2f", calc.LaborCost)},
        }

        for _, cost := range costs </span><span class="cov0" title="0">{
                pdf.CellFormat(80, 8, cost[0], "1", 0, "L", true, 0, "")
                pdf.CellFormat(40, 8, cost[1], "1", 1, "R", true, 0, "")
        }</span>

        // Custo direto total
        <span class="cov0" title="0">pdf.SetFont("Arial", "B", 12)
        pdf.SetFillColor(200, 220, 255)
        pdf.CellFormat(80, 10, "CUSTO DIRETO TOTAL", "1", 0, "L", true, 0, "")
        pdf.CellFormat(40, 10, fmt.Sprintf("R$ %.2f", calc.DirectCost), "1", 1, "R", true, 0, "")

        pdf.Ln(8)

        // Pacotes se disponíveis
        if len(calc.Packages) &gt; 0 </span><span class="cov0" title="0">{
                pdf.SetFont("Arial", "B", 12)
                pdf.Cell(0, 8, "Pacotes de Preços")
                pdf.Ln(10)

                pdf.SetFont("Arial", "B", 9)
                pdf.SetFillColor(230, 230, 230)

                // Cabeçalho
                pdf.CellFormat(50, 8, "Tipo de Serviço", "1", 0, "C", true, 0, "")
                pdf.CellFormat(40, 8, "Preço", "1", 0, "C", true, 0, "")
                pdf.CellFormat(30, 8, "Margem", "1", 1, "C", true, 0, "")

                // Dados dos pacotes
                pdf.SetFont("Arial", "", 9)
                pdf.SetFillColor(255, 255, 255)

                for _, pkg := range calc.Packages </span><span class="cov0" title="0">{
                        pdf.CellFormat(50, 6, pkg.Description, "1", 0, "L", false, 0, "")
                        pdf.CellFormat(40, 6, fmt.Sprintf("R$ %.2f", pkg.Price), "1", 0, "R", false, 0, "")
                        pdf.CellFormat(30, 6, fmt.Sprintf("%.1f%%", pkg.Margin), "1", 1, "R", false, 0, "")
                }</span>
        }
}

func (s *PDFExportService) addFooter(pdf *gofpdf.Fpdf, data *entities.ExportData) <span class="cov0" title="0">{
        // Posicionar no final da página
        pdf.SetY(-20)

        // Linha separadora
        pdf.SetDrawColor(200, 200, 200)
        pdf.Line(10, pdf.GetY(), 200, pdf.GetY())
        pdf.Ln(5)

        // Informações do sistema
        pdf.SetFont("Arial", "I", 8)
        pdf.SetTextColor(100, 100, 100)
        pdf.Cell(0, 5, fmt.Sprintf("Gerado por %s %s - %s",
                data.Metadata.SystemInfo.AppName,
                data.Metadata.SystemInfo.AppVersion,
                data.Metadata.SystemInfo.Generator))
}</span>

func (s *PDFExportService) truncateString(str string, maxLen int) string <span class="cov0" title="0">{
        if len(str) &lt;= maxLen </span><span class="cov0" title="0">{
                return str
        }</span>
        <span class="cov0" title="0">return str[:maxLen-3] + "..."</span>
}

// GetContentType retorna o content type para PDF
func (s *PDFExportService) GetContentType() string <span class="cov0" title="0">{
        return "application/pdf"
}</span>

// GetFileExtension retorna a extensão para arquivos PDF
func (s *PDFExportService) GetFileExtension() string <span class="cov0" title="0">{
        return "pdf"
}</pre>
		
		<pre class="file" id="file42" style="display: none">package di

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"

        "github.com/RodolfoBonis/spooliq/features/export/domain/services"
        "github.com/RodolfoBonis/spooliq/features/export/presentation/handlers"
)

// Module provides the export feature module
var Module = fx.Module("export",
        fx.Provide(
                services.NewExportService,
                handlers.NewExportHandler,
        ),
        fx.Invoke(RegisterExportRoutes),
)

// RegisterExportRoutes registra as rotas de export
func RegisterExportRoutes(r *gin.Engine, handler *handlers.ExportHandler) <span class="cov0" title="0">{
        v1 := r.Group("/v1")
        </span><span class="cov0" title="0">{
                // Endpoints para export de quotes
                quotes := v1.Group("/quotes")
                </span><span class="cov0" title="0">{
                        quotes.POST("/:id/export/pdf", handler.ExportQuotePDF)
                        quotes.POST("/:id/export/csv", handler.ExportQuoteCSV)
                        quotes.POST("/:id/export/json", handler.ExportQuoteJSON)
                }</span>

                // Endpoints gerais de export
                <span class="cov0" title="0">exports := v1.Group("/exports")
                </span><span class="cov0" title="0">{
                        exports.GET("/formats", handler.GetSupportedFormats)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file43" style="display: none">package entities

import (
        "time"

        quoteEntities "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        calculationEntities "github.com/RodolfoBonis/spooliq/features/calculation/domain/entities"
)

// ExportFormat define os formatos de export suportados
type ExportFormat string

const (
        ExportFormatPDF  ExportFormat = "pdf"
        ExportFormatCSV  ExportFormat = "csv"
        ExportFormatJSON ExportFormat = "json"
)

// ExportData contém todos os dados necessários para gerar um export
type ExportData struct {
        Quote       *quoteEntities.Quote                       `json:"quote"`
        Calculation *calculationEntities.CalculationResults    `json:"calculation,omitempty"`
        Metadata    *ExportMetadata                            `json:"metadata"`
}

// ExportMetadata contém metadados sobre o export
type ExportMetadata struct {
        GeneratedAt   time.Time    `json:"generated_at"`
        GeneratedBy   string       `json:"generated_by"`
        Format        ExportFormat `json:"format"`
        Version       string       `json:"version"`
        SystemInfo    SystemInfo   `json:"system_info"`
}

// SystemInfo contém informações do sistema
type SystemInfo struct {
        AppName    string `json:"app_name"`
        AppVersion string `json:"app_version"`
        Generator  string `json:"generator"`
}

// ExportRequest representa uma solicitação de export
type ExportRequest struct {
        QuoteID           uint         `json:"quote_id" validate:"required"`
        Format            ExportFormat `json:"format" validate:"required,oneof=pdf csv json"`
        IncludeCalculation bool         `json:"include_calculation"`
        CustomTitle       string       `json:"custom_title,omitempty"`
        Notes             string       `json:"notes,omitempty"`
}

// ExportResult representa o resultado de um export
type ExportResult struct {
        Data        []byte       `json:"data"`
        ContentType string       `json:"content_type"`
        Filename    string       `json:"filename"`
        Size        int64        `json:"size"`
        Format      ExportFormat `json:"format"`
}

// IsValidFormat verifica se o formato é válido
func (f ExportFormat) IsValid() bool <span class="cov0" title="0">{
        switch f </span>{
        case ExportFormatPDF, ExportFormatCSV, ExportFormatJSON:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetContentType retorna o Content-Type HTTP para o formato
func (f ExportFormat) GetContentType() string <span class="cov0" title="0">{
        switch f </span>{
        case ExportFormatPDF:<span class="cov0" title="0">
                return "application/pdf"</span>
        case ExportFormatCSV:<span class="cov0" title="0">
                return "text/csv"</span>
        case ExportFormatJSON:<span class="cov0" title="0">
                return "application/json"</span>
        default:<span class="cov0" title="0">
                return "application/octet-stream"</span>
        }
}

// GetFileExtension retorna a extensão do arquivo para o formato
func (f ExportFormat) GetFileExtension() string <span class="cov0" title="0">{
        switch f </span>{
        case ExportFormatPDF:<span class="cov0" title="0">
                return "pdf"</span>
        case ExportFormatCSV:<span class="cov0" title="0">
                return "csv"</span>
        case ExportFormatJSON:<span class="cov0" title="0">
                return "json"</span>
        default:<span class="cov0" title="0">
                return "bin"</span>
        }
}

// Validate valida os dados de export
func (ed *ExportData) Validate() error <span class="cov0" title="0">{
        if ed.Quote == nil </span><span class="cov0" title="0">{
                return ErrInvalidExportData
        }</span>

        <span class="cov0" title="0">if ed.Metadata == nil </span><span class="cov0" title="0">{
                return ErrMissingMetadata
        }</span>

        <span class="cov0" title="0">if !ed.Metadata.Format.IsValid() </span><span class="cov0" title="0">{
                return ErrInvalidFormat
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GenerateFilename gera um nome de arquivo baseado na quote e formato
func (ed *ExportData) GenerateFilename() string <span class="cov0" title="0">{
        timestamp := ed.Metadata.GeneratedAt.Format("20060102_150405")
        quoteTitle := "orcamento"

        if ed.Quote.Title != "" </span><span class="cov0" title="0">{
                quoteTitle = ed.Quote.Title
        }</span>

        <span class="cov0" title="0">return sanitizeFilename(quoteTitle + "_" + timestamp + "." + ed.Metadata.Format.GetFileExtension())</span>
}

// sanitizeFilename remove caracteres inválidos do nome do arquivo
func sanitizeFilename(filename string) string <span class="cov0" title="0">{
        // Implementação simples - em produção usar biblioteca mais robusta
        invalidChars := []string{"/", "\\", ":", "*", "?", "\"", "&lt;", "&gt;", "|"}
        result := filename

        for _, char := range invalidChars </span><span class="cov0" title="0">{
                result = replaceAll(result, char, "_")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// replaceAll substitui todas as ocorrências de old por new em s
func replaceAll(s, old, new string) string <span class="cov0" title="0">{
        result := ""
        for _, char := range s </span><span class="cov0" title="0">{
                if string(char) == old </span><span class="cov0" title="0">{
                        result += new
                }</span> else<span class="cov0" title="0"> {
                        result += string(char)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Erros específicos do domínio de export
var (
        ErrInvalidExportData = &amp;ExportError{Code: "INVALID_EXPORT_DATA", Message: "Dados de export inválidos"}
        ErrMissingMetadata   = &amp;ExportError{Code: "MISSING_METADATA", Message: "Metadados obrigatórios ausentes"}
        ErrInvalidFormat     = &amp;ExportError{Code: "INVALID_FORMAT", Message: "Formato de export inválido"}
        ErrExportGeneration  = &amp;ExportError{Code: "EXPORT_GENERATION", Message: "Erro ao gerar export"}
)

// ExportError representa um erro específico do domínio de export
type ExportError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}

func (e *ExportError) Error() string <span class="cov0" title="0">{
        return e.Message
}</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "context"
        "time"

        "github.com/RodolfoBonis/spooliq/features/export/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/export/data/services"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/repositories"
        quoteEntities "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        calculationServices "github.com/RodolfoBonis/spooliq/features/calculation/domain/services"
        calculationEntities "github.com/RodolfoBonis/spooliq/features/calculation/domain/entities"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/go-playground/validator/v10"
)

type exportServiceImpl struct {
        quoteRepo          repositories.QuoteRepository
        calculationService calculationServices.CalculationService
        logger             logger.Logger
        validator          *validator.Validate
        jsonService        *services.JSONExportService
        csvService         *services.CSVExportService
        pdfService         *services.PDFExportService
}

// NewExportService cria uma nova instância do serviço de export
func NewExportService(
        quoteRepo repositories.QuoteRepository,
        calculationService calculationServices.CalculationService,
        logger logger.Logger,
) ExportService <span class="cov0" title="0">{
        return &amp;exportServiceImpl{
                quoteRepo:          quoteRepo,
                calculationService: calculationService,
                logger:             logger,
                validator:          validator.New(),
                jsonService:        services.NewJSONExportService(),
                csvService:         services.NewCSVExportService(),
                pdfService:         services.NewPDFExportService(),
        }
}</span>

func (s *exportServiceImpl) ExportQuote(ctx context.Context, request *entities.ExportRequest, userID string) (*entities.ExportResult, error) <span class="cov0" title="0">{
        // Validar request
        if err := s.ValidateRequest(request); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Export request validation failed", err)
                return nil, err
        }</span>

        // Buscar quote com dados completos
        <span class="cov0" title="0">quote, err := s.quoteRepo.GetWithFilamentLines(ctx, request.QuoteID, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get quote for export", err)
                return nil, err
        }</span>

        // Preparar dados de export
        <span class="cov0" title="0">exportData := &amp;entities.ExportData{
                Quote: quote,
                Metadata: &amp;entities.ExportMetadata{
                        GeneratedAt: time.Now(),
                        GeneratedBy: userID,
                        Format:      request.Format,
                        Version:     "1.0",
                        SystemInfo: entities.SystemInfo{
                                AppName:    "SpoolIQ",
                                AppVersion: "1.0.0",
                                Generator:  "Export Service",
                        },
                },
        }

        // Incluir cálculos se solicitado
        if request.IncludeCalculation </span><span class="cov0" title="0">{
                calculationData, err := s.performCalculation(ctx, quote)
                if err != nil </span><span class="cov0" title="0">{
                        // Log do erro mas continua sem os cálculos
                        s.logger.Warning(ctx, "Failed to calculate quote for export, continuing without calculations", map[string]interface{}{
                                "quote_id": request.QuoteID,
                                "error":    err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        exportData.Calculation = calculationData
                }</span>
        }

        // Gerar export baseado no formato
        <span class="cov0" title="0">var data []byte
        switch request.Format </span>{
        case entities.ExportFormatJSON:<span class="cov0" title="0">
                data, err = s.jsonService.Generate(ctx, exportData)</span>
        case entities.ExportFormatCSV:<span class="cov0" title="0">
                data, err = s.csvService.Generate(ctx, exportData)</span>
        case entities.ExportFormatPDF:<span class="cov0" title="0">
                data, err = s.pdfService.Generate(ctx, exportData)</span>
        default:<span class="cov0" title="0">
                return nil, entities.ErrInvalidFormat</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to generate export", err)
                return nil, err
        }</span>

        // Criar resultado
        <span class="cov0" title="0">result := &amp;entities.ExportResult{
                Data:        data,
                ContentType: request.Format.GetContentType(),
                Filename:    exportData.GenerateFilename(),
                Size:        int64(len(data)),
                Format:      request.Format,
        }

        s.logger.Info(ctx, "Export generated successfully", map[string]interface{}{
                "quote_id": request.QuoteID,
                "format":   string(request.Format),
                "size":     result.Size,
                "filename": result.Filename,
                "user_id":  userID,
        })

        return result, nil</span>
}

func (s *exportServiceImpl) GetSupportedFormats() []entities.ExportFormat <span class="cov0" title="0">{
        return []entities.ExportFormat{
                entities.ExportFormatJSON,
                entities.ExportFormatCSV,
                entities.ExportFormatPDF,
        }
}</span>

func (s *exportServiceImpl) ValidateRequest(request *entities.ExportRequest) error <span class="cov0" title="0">{
        if request == nil </span><span class="cov0" title="0">{
                return entities.ErrInvalidExportData
        }</span>

        // Validar usando validator
        <span class="cov0" title="0">if err := s.validator.Struct(request); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validar formato específico
        <span class="cov0" title="0">if !request.Format.IsValid() </span><span class="cov0" title="0">{
                return entities.ErrInvalidFormat
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performCalculation executa o cálculo para incluir nos exports
func (s *exportServiceImpl) performCalculation(ctx context.Context, quote *quoteEntities.Quote) (*calculationEntities.CalculationResults, error) <span class="cov0" title="0">{
        // Preparar input de cálculo básico com dados disponíveis
        calculationInput := calculationEntities.CostBreakdown{}

        // Converter filament lines
        for _, line := range quote.FilamentLines </span><span class="cov0" title="0">{
                filament := calculationEntities.FilamentLineInput{
                        Label:      line.FilamentSnapshotName + " " + line.FilamentSnapshotColor,
                        Grams:      line.WeightGrams,
                        PricePerKg: line.FilamentSnapshotPricePerKg,
                }
                if line.LengthMeters != nil </span><span class="cov0" title="0">{
                        meters := *line.LengthMeters
                        filament.Meters = &amp;meters
                }</span>
                <span class="cov0" title="0">if line.FilamentSnapshotPricePerMeter != nil </span><span class="cov0" title="0">{
                        pricePerMeter := *line.FilamentSnapshotPricePerMeter
                        filament.PricePerMeter = &amp;pricePerMeter
                }</span>
                <span class="cov0" title="0">calculationInput.Filaments = append(calculationInput.Filaments, filament)</span>
        }

        // Machine profile
        <span class="cov0" title="0">if quote.MachineProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Machine = calculationEntities.MachineInput{
                        Name:         quote.MachineProfile.Name,
                        Watt:         quote.MachineProfile.Watt,
                        IdleFactor:   quote.MachineProfile.IdleFactor,
                        HoursDecimal: 1.0, // Valor padrão para export
                }
        }</span>

        // Energy profile
        <span class="cov0" title="0">if quote.EnergyProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Energy = calculationEntities.EnergyInput{
                        BaseTariff:    quote.EnergyProfile.BaseTariff,
                        FlagSurcharge: quote.EnergyProfile.FlagSurcharge,
                }
        }</span>

        // Cost profile
        <span class="cov0" title="0">if quote.CostProfile != nil &amp;&amp; quote.MarginProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Costs = calculationEntities.CostInput{
                        WearPct:        quote.CostProfile.WearPercentage,
                        Overhead:       quote.CostProfile.OverheadAmount,
                        OpRatePerHour:  quote.MarginProfile.OperatorRatePerHour,
                        OpMinutes:      0.0, // Valor padrão para export
                        CadRatePerHour: quote.MarginProfile.ModelerRatePerHour,
                        CadMinutes:     0.0, // Valor padrão para export
                }
        }</span>

        // Margin profile
        <span class="cov0" title="0">if quote.MarginProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Margins = calculationEntities.MarginInput{
                        OnlyPrintPct:     quote.MarginProfile.PrintingOnlyMargin,
                        LightAdjustPct:   quote.MarginProfile.PrintingPlusMargin,
                        FullModelPct:     quote.MarginProfile.FullServiceMargin,
                        ExtraCadLightMin: 30.0, // Valor padrão
                        ExtraCadFullMin:  90.0, // Valor padrão
                }
        }</span>

        // Executar cálculo
        <span class="cov0" title="0">result, err := s.calculationService.Calculate(ctx, calculationInput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;result.Results, nil</span>
}</pre>
		
		<pre class="file" id="file45" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/RodolfoBonis/spooliq/features/export/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/export/domain/services"
        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/go-playground/validator/v10"
)

type ExportHandler struct {
        exportService services.ExportService
        logger        logger.Logger
        validator     *validator.Validate
}

// NewExportHandler cria uma nova instância do handler de export
func NewExportHandler(
        exportService services.ExportService,
        logger logger.Logger,
) *ExportHandler <span class="cov0" title="0">{
        return &amp;ExportHandler{
                exportService: exportService,
                logger:        logger,
                validator:     validator.New(),
        }
}</span>

// ExportQuotePDF exporta uma quote em formato PDF
// @Summary Export quote as PDF
// @Description Exports a quote and its calculation results as PDF
// @Tags exports
// @Accept json
// @Produce application/pdf
// @Param id path int true "Quote ID"
// @Param request body ExportRequestDTO true "Export options"
// @Success 200 {file} binary "PDF file"
// @Failure 400 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /quotes/{id}/export/pdf [post]
func (h *ExportHandler) ExportQuotePDF(c *gin.Context) <span class="cov0" title="0">{
        h.exportQuote(c, entities.ExportFormatPDF)
}</span>

// ExportQuoteCSV exporta uma quote em formato CSV
// @Summary Export quote as CSV
// @Description Exports a quote and its calculation results as CSV
// @Tags exports
// @Accept json
// @Produce text/csv
// @Param id path int true "Quote ID"
// @Param request body ExportRequestDTO true "Export options"
// @Success 200 {file} binary "CSV file"
// @Failure 400 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /quotes/{id}/export/csv [post]
func (h *ExportHandler) ExportQuoteCSV(c *gin.Context) <span class="cov0" title="0">{
        h.exportQuote(c, entities.ExportFormatCSV)
}</span>

// ExportQuoteJSON exporta uma quote em formato JSON
// @Summary Export quote as JSON
// @Description Exports a quote and its calculation results as JSON
// @Tags exports
// @Accept json
// @Produce application/json
// @Param id path int true "Quote ID"
// @Param request body ExportRequestDTO true "Export options"
// @Success 200 {file} binary "JSON file"
// @Failure 400 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /quotes/{id}/export/json [post]
func (h *ExportHandler) ExportQuoteJSON(c *gin.Context) <span class="cov0" title="0">{
        h.exportQuote(c, entities.ExportFormatJSON)
}</span>

// GetSupportedFormats retorna os formatos de export suportados
// @Summary Get supported export formats
// @Description Returns the list of supported export formats
// @Tags exports
// @Produce json
// @Success 200 {object} SupportedFormatsResponse
// @Router /exports/formats [get]
func (h *ExportHandler) GetSupportedFormats(c *gin.Context) <span class="cov0" title="0">{
        formats := h.exportService.GetSupportedFormats()

        response := SupportedFormatsResponse{
                Formats: make([]FormatInfo, len(formats)),
        }

        for i, format := range formats </span><span class="cov0" title="0">{
                response.Formats[i] = FormatInfo{
                        Format:      string(format),
                        ContentType: format.GetContentType(),
                        Extension:   format.GetFileExtension(),
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

func (h *ExportHandler) exportQuote(c *gin.Context, format entities.ExportFormat) <span class="cov0" title="0">{
        // Obter ID da quote
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "ID inválido", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Invalid quote ID for export", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Obter dados da request
        <span class="cov0" title="0">var req ExportRequestDTO
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Formato de requisição inválido", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind export request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validar request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Falha na validação dos dados", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Validation failed for export request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Obter user ID
        <span class="cov0" title="0">userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated for export", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Criar request de export
        <span class="cov0" title="0">exportRequest := &amp;entities.ExportRequest{
                QuoteID:           uint(id),
                Format:            format,
                IncludeCalculation: req.IncludeCalculation,
                CustomTitle:       req.CustomTitle,
                Notes:             req.Notes,
        }

        // Executar export
        result, err := h.exportService.ExportQuote(c.Request.Context(), exportRequest, userID)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrService, "Erro ao gerar export", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to export quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Configurar headers de download
        <span class="cov0" title="0">c.Header("Content-Type", result.ContentType)
        c.Header("Content-Disposition", "attachment; filename=\""+result.Filename+"\"")
        c.Header("Content-Length", strconv.FormatInt(result.Size, 10))

        // Enviar arquivo
        c.Data(http.StatusOK, result.ContentType, result.Data)

        h.logger.Info(c.Request.Context(), "Quote exported successfully", map[string]interface{}{
                "quote_id": id,
                "format":   string(format),
                "size":     result.Size,
                "filename": result.Filename,
                "user_id":  userID,
        })</span>
}

// DTOs para requests e responses

type ExportRequestDTO struct {
        IncludeCalculation bool   `json:"include_calculation"`
        CustomTitle       string `json:"custom_title,omitempty"`
        Notes             string `json:"notes,omitempty"`
}

type SupportedFormatsResponse struct {
        Formats []FormatInfo `json:"formats"`
}

type FormatInfo struct {
        Format      string `json:"format"`
        ContentType string `json:"content_type"`
        Extension   string `json:"extension"`
}</pre>
		
		<pre class="file" id="file46" style="display: none">package repositories

import (
        "context"
        "errors"

        "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/repositories"
        "github.com/jinzhu/gorm"
)

type filamentRepositoryImpl struct {
        db *gorm.DB
}

func NewFilamentRepository(db *gorm.DB) repositories.FilamentRepository <span class="cov0" title="0">{
        return &amp;filamentRepositoryImpl{db: db}
}</span>

func (r *filamentRepositoryImpl) Create(ctx context.Context, filament *entities.Filament) error <span class="cov0" title="0">{
        return r.db.Create(filament).Error
}</span>

func (r *filamentRepositoryImpl) GetByID(ctx context.Context, id uint, userID *string) (*entities.Filament, error) <span class="cov0" title="0">{
        var filament entities.Filament
        query := r.db

        if userID != nil </span><span class="cov0" title="0">{
                query = query.Where("(owner_user_id IS NULL OR owner_user_id = ?)", *userID)
        }</span> else<span class="cov0" title="0"> {
                query = query.Where("owner_user_id IS NULL")
        }</span>

        <span class="cov0" title="0">err := query.Where("id = ?", id).First(&amp;filament).Error
        if err != nil </span><span class="cov0" title="0">{
                if gorm.IsRecordNotFoundError(err) </span><span class="cov0" title="0">{
                        return nil, errors.New("filament not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;filament, nil</span>
}

func (r *filamentRepositoryImpl) GetAll(ctx context.Context, userID *string) ([]*entities.Filament, error) <span class="cov0" title="0">{
        var filaments []*entities.Filament
        query := r.db

        if userID != nil </span><span class="cov0" title="0">{
                query = query.Where("(owner_user_id IS NULL OR owner_user_id = ?)", *userID)
        }</span> else<span class="cov0" title="0"> {
                query = query.Where("owner_user_id IS NULL")
        }</span>

        <span class="cov0" title="0">err := query.Order("created_at DESC").Find(&amp;filaments).Error
        return filaments, err</span>
}

func (r *filamentRepositoryImpl) Update(ctx context.Context, filament *entities.Filament, userID *string) error <span class="cov0" title="0">{
        if userID == nil </span><span class="cov0" title="0">{
                return errors.New("cannot update filament: user authentication required")
        }</span>

        <span class="cov0" title="0">result := r.db.Where("owner_user_id = ?", *userID).Where("id = ?", filament.ID).Updates(filament)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("filament not found or access denied")
        }</span>

        <span class="cov0" title="0">return r.db.Where("id = ?", filament.ID).First(filament).Error</span>
}

func (r *filamentRepositoryImpl) Delete(ctx context.Context, id uint, userID *string) error <span class="cov0" title="0">{
        if userID == nil </span><span class="cov0" title="0">{
                return errors.New("cannot delete filament: user authentication required")
        }</span>

        <span class="cov0" title="0">result := r.db.Where("owner_user_id = ?", *userID).Where("id = ?", id).Delete(&amp;entities.Filament{})
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("filament not found or access denied")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *filamentRepositoryImpl) GetByOwner(ctx context.Context, userID string) ([]*entities.Filament, error) <span class="cov0" title="0">{
        var filaments []*entities.Filament
        err := r.db.Where("owner_user_id = ?", userID).Order("created_at DESC").Find(&amp;filaments).Error
        return filaments, err
}</span>

func (r *filamentRepositoryImpl) GetGlobal(ctx context.Context) ([]*entities.Filament, error) <span class="cov0" title="0">{
        var filaments []*entities.Filament
        err := r.db.Where("owner_user_id IS NULL").Order("created_at DESC").Find(&amp;filaments).Error
        return filaments, err
}</pre>
		
		<pre class="file" id="file47" style="display: none">package di

import (
        "github.com/RodolfoBonis/spooliq/core/logger"
        data_repositories "github.com/RodolfoBonis/spooliq/features/filaments/data/repositories"
        domain_repositories "github.com/RodolfoBonis/spooliq/features/filaments/domain/repositories"
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases"
        "go.uber.org/fx"
        "github.com/jinzhu/gorm"
)

var FilamentsModule = fx.Module("filaments",
        fx.Provide(
                func(db *gorm.DB) domain_repositories.FilamentRepository <span class="cov0" title="0">{
                        return data_repositories.NewFilamentRepository(db)
                }</span>,
                func(filamentRepo domain_repositories.FilamentRepository, logger logger.Logger) usecases.FilamentUseCase <span class="cov0" title="0">{
                        return usecases.NewFilamentUseCase(filamentRepo, logger)
                }</span>,
        ),
)</pre>
		
		<pre class="file" id="file48" style="display: none">package entities

import (
        "time"

        "github.com/jinzhu/gorm"
)

// Filament representa um filamento para impressão 3D
// @Description Filamento para impressão 3D
// @Example {"id": 1, "name": "PLA Branco", "brand": "SUNLU", "material": "PLA", "color": "Branco", "price_per_kg": 125.0, "url": "https://amazon.com.br/dp/B07PGYHYV8"}
type Filament struct {
        ID             uint       `gorm:"primary_key;auto_increment" json:"id"`
        Name           string     `gorm:"type:varchar(255);not null" json:"name" validate:"required,min=1,max=255"`
        Brand          string     `gorm:"type:varchar(255);not null" json:"brand" validate:"required,min=1,max=255"`
        Material       string     `gorm:"type:varchar(100);not null" json:"material" validate:"required,min=1,max=100"`
        Color          string     `gorm:"type:varchar(100);not null" json:"color" validate:"required,min=1,max=100"`
        ColorHex       string     `gorm:"type:varchar(7)" json:"color_hex" validate:"omitempty,hexcolor"`
        PricePerKg     float64    `gorm:"type:decimal(10,2);not null" json:"price_per_kg" validate:"required,min=0"`
        PricePerMeter  *float64   `gorm:"type:decimal(10,4)" json:"price_per_meter,omitempty" validate:"omitempty,min=0"`
        URL            string     `gorm:"type:text" json:"url" validate:"omitempty,url"`
        OwnerUserID    *string    `gorm:"type:varchar(255);index" json:"owner_user_id,omitempty"` // null = catálogo global (admin), string = Keycloak User ID
        CreatedAt      time.Time  `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
        UpdatedAt      time.Time  `gorm:"default:CURRENT_TIMESTAMP" json:"updated_at"`
        DeletedAt      *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}

// TableName especifica o nome da tabela para o GORM
func (Filament) TableName() string <span class="cov0" title="0">{
        return "filaments"
}</span>

// BeforeCreate é um hook do GORM executado antes de criar um filamento
func (f *Filament) BeforeCreate(scope *gorm.Scope) error <span class="cov0" title="0">{
        f.CreatedAt = time.Now()
        f.UpdatedAt = time.Now()
        return nil
}</span>

// BeforeUpdate é um hook do GORM executado antes de atualizar um filamento
func (f *Filament) BeforeUpdate(scope *gorm.Scope) error <span class="cov0" title="0">{
        f.UpdatedAt = time.Now()
        return nil
}</span>

// IsGlobal verifica se o filamento é do catálogo global (sem dono)
func (f *Filament) IsGlobal() bool <span class="cov0" title="0">{
        return f.OwnerUserID == nil
}</span>

// CanUserAccess verifica se um usuário pode acessar este filamento
func (f *Filament) CanUserAccess(userID string, isAdmin bool) bool <span class="cov0" title="0">{
        // Admin pode acessar tudo
        if isAdmin </span><span class="cov0" title="0">{
                return true
        }</span>
        // Filamentos globais são acessíveis a todos
        <span class="cov0" title="0">if f.IsGlobal() </span><span class="cov0" title="0">{
                return true
        }</span>
        // Usuário pode acessar seus próprios filamentos
        <span class="cov0" title="0">return f.OwnerUserID != nil &amp;&amp; *f.OwnerUserID == userID</span>
}</pre>
		
		<pre class="file" id="file49" style="display: none">package usecases

import (
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        "github.com/gin-gonic/gin"
)

type FilamentUseCase interface {
        CreateFilament(c *gin.Context)
        GetFilament(c *gin.Context)
        GetAllFilaments(c *gin.Context)
        UpdateFilament(c *gin.Context)
        DeleteFilament(c *gin.Context)
        GetUserFilaments(c *gin.Context)
        GetGlobalFilaments(c *gin.Context)
}

type CreateFilamentRequest struct {
        Name          string   `json:"name" validate:"required,min=1,max=255"`
        Brand         string   `json:"brand" validate:"required,min=1,max=255"`
        Material      string   `json:"material" validate:"required,min=1,max=100"`
        Color         string   `json:"color" validate:"required,min=1,max=100"`
        ColorHex      string   `json:"color_hex,omitempty" validate:"omitempty,hexcolor"`
        PricePerKg    float64  `json:"price_per_kg" validate:"required,min=0"`
        PricePerMeter *float64 `json:"price_per_meter,omitempty" validate:"omitempty,min=0"`
        URL           string   `json:"url,omitempty" validate:"omitempty,url"`
}

type UpdateFilamentRequest struct {
        Name          string   `json:"name" validate:"required,min=1,max=255"`
        Brand         string   `json:"brand" validate:"required,min=1,max=255"`
        Material      string   `json:"material" validate:"required,min=1,max=100"`
        Color         string   `json:"color" validate:"required,min=1,max=100"`
        ColorHex      string   `json:"color_hex,omitempty" validate:"omitempty,hexcolor"`
        PricePerKg    float64  `json:"price_per_kg" validate:"required,min=0"`
        PricePerMeter *float64 `json:"price_per_meter,omitempty" validate:"omitempty,min=0"`
        URL           string   `json:"url,omitempty" validate:"omitempty,url"`
}

type FilamentResponse struct {
        ID            uint     `json:"id"`
        Name          string   `json:"name"`
        Brand         string   `json:"brand"`
        Material      string   `json:"material"`
        Color         string   `json:"color"`
        ColorHex      string   `json:"color_hex,omitempty"`
        PricePerKg    float64  `json:"price_per_kg"`
        PricePerMeter *float64 `json:"price_per_meter,omitempty"`
        URL           string   `json:"url,omitempty"`
        OwnerUserID   *string  `json:"owner_user_id,omitempty"`
        CreatedAt     string   `json:"created_at"`
        UpdatedAt     string   `json:"updated_at"`
}

func ToFilamentResponse(filament *entities.Filament) *FilamentResponse <span class="cov0" title="0">{
        return &amp;FilamentResponse{
                ID:            filament.ID,
                Name:          filament.Name,
                Brand:         filament.Brand,
                Material:      filament.Material,
                Color:         filament.Color,
                ColorHex:      filament.ColorHex,
                PricePerKg:    filament.PricePerKg,
                PricePerMeter: filament.PricePerMeter,
                URL:           filament.URL,
                OwnerUserID:   filament.OwnerUserID,
                CreatedAt:     filament.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:     filament.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package usecases

import (
        "net/http"
        "strconv"

        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/repositories"
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

type filamentUseCaseImpl struct {
        filamentRepo repositories.FilamentRepository
        logger       logger.Logger
        validator    *validator.Validate
}

func NewFilamentUseCase(filamentRepo repositories.FilamentRepository, logger logger.Logger) FilamentUseCase <span class="cov0" title="0">{
        return &amp;filamentUseCaseImpl{
                filamentRepo: filamentRepo,
                logger:       logger,
                validator:    validator.New(),
        }
}</span>

func (uc *filamentUseCaseImpl) CreateFilament(c *gin.Context) <span class="cov0" title="0">{
        var request CreateFilamentRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.InvalidRequestResponse(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := uc.validator.Struct(request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.ValidationErrorResponse(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        var ownerUserID *string
        if userID != "" </span><span class="cov0" title="0">{
                ownerUserID = &amp;userID
        }</span>

        <span class="cov0" title="0">filament := &amp;entities.Filament{
                Name:          request.Name,
                Brand:         request.Brand,
                Material:      request.Material,
                Color:         request.Color,
                ColorHex:      request.ColorHex,
                PricePerKg:    request.PricePerKg,
                PricePerMeter: request.PricePerMeter,
                URL:           request.URL,
                OwnerUserID:   ownerUserID,
        }

        if err := uc.filamentRepo.Create(c.Request.Context(), filament); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to create filament", map[string]interface{}{
                        "error": err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToCreateFilament))
                return
        }</span>

        <span class="cov0" title="0">response := ToFilamentResponse(filament)
        c.JSON(http.StatusCreated, response)</span>
}

func (uc *filamentUseCaseImpl) GetFilament(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.ErrorResponse("ID do filamento inválido"))
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        var userIDPtr *string
        if userID != "" </span><span class="cov0" title="0">{
                userIDPtr = &amp;userID
        }</span>

        <span class="cov0" title="0">filament, err := uc.filamentRepo.GetByID(c.Request.Context(), uint(id), userIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to get filament", map[string]interface{}{
                        "filament_id": id,
                        "error":       err.Error(),
                })
                c.JSON(http.StatusNotFound, errors.ErrorResponse(errors.ErrorMessages.FilamentNotFound))
                return
        }</span>

        <span class="cov0" title="0">response := ToFilamentResponse(filament)
        c.JSON(http.StatusOK, response)</span>
}

func (uc *filamentUseCaseImpl) GetAllFilaments(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        var userIDPtr *string
        if userID != "" </span><span class="cov0" title="0">{
                userIDPtr = &amp;userID
        }</span>

        <span class="cov0" title="0">filaments, err := uc.filamentRepo.GetAll(c.Request.Context(), userIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to get filaments", map[string]interface{}{
                        "error": err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToGetFilaments))
                return
        }</span>

        <span class="cov0" title="0">responses := make([]*FilamentResponse, 0, len(filaments))
        for _, filament := range filaments </span><span class="cov0" title="0">{
                responses = append(responses, ToFilamentResponse(filament))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"filaments": responses})</span>
}

func (uc *filamentUseCaseImpl) UpdateFilament(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.ErrorResponse("ID do filamento inválido"))
                return
        }</span>

        <span class="cov0" title="0">var request UpdateFilamentRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.InvalidRequestResponse(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := uc.validator.Struct(request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.ValidationErrorResponse(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        var userIDPtr *string
        if userID != "" </span><span class="cov0" title="0">{
                userIDPtr = &amp;userID
        }</span>

        <span class="cov0" title="0">filament := &amp;entities.Filament{
                ID:            uint(id),
                Name:          request.Name,
                Brand:         request.Brand,
                Material:      request.Material,
                Color:         request.Color,
                ColorHex:      request.ColorHex,
                PricePerKg:    request.PricePerKg,
                PricePerMeter: request.PricePerMeter,
                URL:           request.URL,
        }

        if err := uc.filamentRepo.Update(c.Request.Context(), filament, userIDPtr); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to update filament", map[string]interface{}{
                        "filament_id": id,
                        "error":       err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToUpdateFilament))
                return
        }</span>

        <span class="cov0" title="0">response := ToFilamentResponse(filament)
        c.JSON(http.StatusOK, response)</span>
}

func (uc *filamentUseCaseImpl) DeleteFilament(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.ErrorResponse("ID do filamento inválido"))
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        var userIDPtr *string
        if userID != "" </span><span class="cov0" title="0">{
                userIDPtr = &amp;userID
        }</span>

        <span class="cov0" title="0">if err := uc.filamentRepo.Delete(c.Request.Context(), uint(id), userIDPtr); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to delete filament", map[string]interface{}{
                        "filament_id": id,
                        "error":       err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToDeleteFilament))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusNoContent, nil)</span>
}

func (uc *filamentUseCaseImpl) GetUserFilaments(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, errors.ErrorResponse(errors.ErrorMessages.UserNotAuthenticated))
                return
        }</span>

        <span class="cov0" title="0">filaments, err := uc.filamentRepo.GetByOwner(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to get user filaments", map[string]interface{}{
                        "user_id": userID,
                        "error":   err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToGetUserFilaments))
                return
        }</span>

        <span class="cov0" title="0">responses := make([]*FilamentResponse, 0, len(filaments))
        for _, filament := range filaments </span><span class="cov0" title="0">{
                responses = append(responses, ToFilamentResponse(filament))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"filaments": responses})</span>
}

func (uc *filamentUseCaseImpl) GetGlobalFilaments(c *gin.Context) <span class="cov0" title="0">{
        filaments, err := uc.filamentRepo.GetGlobal(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error(c.Request.Context(), "Failed to get global filaments", map[string]interface{}{
                        "error": err.Error(),
                })
                c.JSON(http.StatusInternalServerError, errors.ErrorResponse(errors.ErrorMessages.FailedToGetGlobalFilaments))
                return
        }</span>

        <span class="cov0" title="0">responses := make([]*FilamentResponse, 0, len(filaments))
        for _, filament := range filaments </span><span class="cov0" title="0">{
                responses = append(responses, ToFilamentResponse(filament))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"filaments": responses})</span>
}</pre>
		
		<pre class="file" id="file51" style="display: none">package filaments

import (
        "github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases"
        "github.com/gin-gonic/gin"
)

// CreateFilamentHandler handles creating a new filament.
// @Summary Create Filament
// @Schemes
// @Description Create a new filament record
// @Tags Filaments
// @Accept json
// @Produce json
// @Param request body usecases.CreateFilamentRequest true "Filament data"
// @Success 201 {object} usecases.FilamentResponse "Successfully created filament"
// @Failure 400 {object} gin.H
// @Failure 401 {object} gin.H
// @Failure 500 {object} gin.H
// @Router /filaments [post]
// @Security Bearer
func CreateFilamentHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.CreateFilament(c)
        }</span>
}

// GetFilamentHandler handles getting a filament by ID.
// @Summary Get Filament
// @Schemes
// @Description Get a filament by its ID
// @Tags Filaments
// @Accept json
// @Produce json
// @Param id path int true "Filament ID"
// @Success 200 {object} usecases.FilamentResponse "Successfully retrieved filament"
// @Failure 400 {object} gin.H
// @Failure 404 {object} gin.H
// @Failure 500 {object} gin.H
// @Router /filaments/{id} [get]
func GetFilamentHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.GetFilament(c)
        }</span>
}

// GetAllFilamentsHandler handles getting all accessible filaments.
// @Summary Get All Filaments
// @Schemes
// @Description Get all filaments accessible to the user (global + user's own)
// @Tags Filaments
// @Accept json
// @Produce json
// @Success 200 {object} gin.H{filaments=[]usecases.FilamentResponse} "Successfully retrieved filaments"
// @Failure 500 {object} gin.H
// @Router /filaments [get]
func GetAllFilamentsHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.GetAllFilaments(c)
        }</span>
}

// UpdateFilamentHandler handles updating a filament.
// @Summary Update Filament
// @Schemes
// @Description Update an existing filament (only user's own filaments)
// @Tags Filaments
// @Accept json
// @Produce json
// @Param id path int true "Filament ID"
// @Param request body usecases.UpdateFilamentRequest true "Updated filament data"
// @Success 200 {object} usecases.FilamentResponse "Successfully updated filament"
// @Failure 400 {object} gin.H
// @Failure 401 {object} gin.H
// @Failure 404 {object} gin.H
// @Failure 500 {object} gin.H
// @Router /filaments/{id} [put]
// @Security Bearer
func UpdateFilamentHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.UpdateFilament(c)
        }</span>
}

// DeleteFilamentHandler handles deleting a filament.
// @Summary Delete Filament
// @Schemes
// @Description Delete a filament (only user's own filaments)
// @Tags Filaments
// @Accept json
// @Produce json
// @Param id path int true "Filament ID"
// @Success 204 "Successfully deleted filament"
// @Failure 400 {object} gin.H
// @Failure 401 {object} gin.H
// @Failure 404 {object} gin.H
// @Failure 500 {object} gin.H
// @Router /filaments/{id} [delete]
// @Security Bearer
func DeleteFilamentHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.DeleteFilament(c)
        }</span>
}

// GetUserFilamentsHandler handles getting user's own filaments.
// @Summary Get User Filaments
// @Schemes
// @Description Get all filaments owned by the authenticated user
// @Tags Filaments
// @Accept json
// @Produce json
// @Success 200 {object} gin.H{filaments=[]usecases.FilamentResponse} "Successfully retrieved user filaments"
// @Failure 401 {object} gin.H
// @Failure 500 {object} gin.H
// @Router /filaments/my [get]
// @Security Bearer
func GetUserFilamentsHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.GetUserFilaments(c)
        }</span>
}

// GetGlobalFilamentsHandler handles getting global filaments.
// @Summary Get Global Filaments
// @Schemes
// @Description Get all global filaments (not owned by any user)
// @Tags Filaments
// @Accept json
// @Produce json
// @Success 200 {object} gin.H{filaments=[]usecases.FilamentResponse} "Successfully retrieved global filaments"
// @Failure 500 {object} gin.H
// @Router /filaments/global [get]
func GetGlobalFilamentsHandler(filamentsUc usecases.FilamentUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                filamentsUc.GetGlobalFilaments(c)
        }</span>
}

// Routes registers filament routes for the application.
func Routes(route *gin.RouterGroup, filamentsUC usecases.FilamentUseCase, protectFactory func(handler gin.HandlerFunc, role string) gin.HandlerFunc) <span class="cov0" title="0">{
        filaments := route.Group("/filaments")

        // Public routes (can be accessed without authentication, but will show different data based on auth status)
        filaments.GET("", GetAllFilamentsHandler(filamentsUC))
        filaments.GET("/global", GetGlobalFilamentsHandler(filamentsUC))
        filaments.GET("/:id", GetFilamentHandler(filamentsUC))

        // Protected routes (require authentication)
        filaments.POST("", protectFactory(CreateFilamentHandler(filamentsUC), "user"))
        filaments.GET("/my", protectFactory(GetUserFilamentsHandler(filamentsUC), "user"))
        filaments.PUT("/:id", protectFactory(UpdateFilamentHandler(filamentsUC), "user"))
        filaments.DELETE("/:id", protectFactory(DeleteFilamentHandler(filamentsUC), "user"))
}</pre>
		
		<pre class="file" id="file52" style="display: none">package repositories

import (
        "context"
        "fmt"
        "strings"

        "github.com/jinzhu/gorm"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/repositories"
)

type presetRepositoryImpl struct {
        db     *gorm.DB
        logger logger.Logger
}

// NewPresetRepository creates a new preset repository implementation
func NewPresetRepository(db *gorm.DB, logger logger.Logger) repositories.PresetRepository <span class="cov0" title="0">{
        return &amp;presetRepositoryImpl{
                db:     db,
                logger: logger,
        }
}</span>

// GetEnergyLocations retrieves all available energy preset locations
func (r *presetRepositoryImpl) GetEnergyLocations(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        var presets []entities.Preset
        err := r.db.Where("key LIKE ?", "energy_%").Find(&amp;presets).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get energy presets", err)
                return nil, fmt.Errorf("failed to get energy presets: %w", err)
        }</span>

        <span class="cov0" title="0">locationMap := make(map[string]bool)
        var locations []string

        for _, preset := range presets </span><span class="cov0" title="0">{
                var energyPreset entities.EnergyPreset
                if err := preset.UnmarshalDataTo(&amp;energyPreset); err != nil </span><span class="cov0" title="0">{
                        r.logger.Warning(ctx, "Failed to unmarshal energy preset", map[string]interface{}{
                                "preset_key": preset.Key,
                                "error":      err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">if energyPreset.Location != "" &amp;&amp; !locationMap[energyPreset.Location] </span><span class="cov0" title="0">{
                        locationMap[energyPreset.Location] = true
                        locations = append(locations, energyPreset.Location)
                }</span>
        }

        <span class="cov0" title="0">return locations, nil</span>
}

// GetEnergyPresets retrieves energy presets, optionally filtered by location
func (r *presetRepositoryImpl) GetEnergyPresets(ctx context.Context, location string) ([]*entities.Preset, error) <span class="cov0" title="0">{
        query := r.db.Where("key LIKE ?", "energy_%")

        var presets []*entities.Preset
        err := query.Find(&amp;presets).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get energy presets", err)
                return nil, fmt.Errorf("failed to get energy presets: %w", err)
        }</span>

        // Filter by location if specified
        <span class="cov0" title="0">if location != "" </span><span class="cov0" title="0">{
                var filteredPresets []*entities.Preset
                for _, preset := range presets </span><span class="cov0" title="0">{
                        var energyPreset entities.EnergyPreset
                        if err := preset.UnmarshalDataTo(&amp;energyPreset); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.EqualFold(energyPreset.Location, location) </span><span class="cov0" title="0">{
                                filteredPresets = append(filteredPresets, preset)
                        }</span>
                }
                <span class="cov0" title="0">return filteredPresets, nil</span>
        }

        <span class="cov0" title="0">return presets, nil</span>
}

// GetMachinePresets retrieves all machine presets
func (r *presetRepositoryImpl) GetMachinePresets(ctx context.Context) ([]*entities.Preset, error) <span class="cov0" title="0">{
        var presets []*entities.Preset
        err := r.db.Where("key LIKE ?", "machine_%").Find(&amp;presets).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get machine presets", err)
                return nil, fmt.Errorf("failed to get machine presets: %w", err)
        }</span>

        <span class="cov0" title="0">return presets, nil</span>
}

// GetPresetByKey retrieves a preset by its key
func (r *presetRepositoryImpl) GetPresetByKey(ctx context.Context, key string) (*entities.Preset, error) <span class="cov0" title="0">{
        var preset entities.Preset
        err := r.db.Where("key = ?", key).First(&amp;preset).Error
        if err != nil </span><span class="cov0" title="0">{
                if gorm.IsRecordNotFoundError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("preset not found: %s", key)
                }</span>
                <span class="cov0" title="0">r.logger.LogError(ctx, "Failed to get preset by key", err)
                return nil, fmt.Errorf("failed to get preset: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;preset, nil</span>
}

// CreatePreset creates a new preset
func (r *presetRepositoryImpl) CreatePreset(ctx context.Context, preset *entities.Preset) error <span class="cov0" title="0">{
        // Check if preset with same key already exists
        var existingPreset entities.Preset
        err := r.db.Where("key = ?", preset.Key).First(&amp;existingPreset).Error
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("preset with key '%s' already exists", preset.Key)
        }</span>
        <span class="cov0" title="0">if !gorm.IsRecordNotFoundError(err) </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to check existing preset", err)
                return fmt.Errorf("failed to check existing preset: %w", err)
        }</span>

        <span class="cov0" title="0">err = r.db.Create(preset).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to create preset", err)
                return fmt.Errorf("failed to create preset: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info(ctx, "Preset created successfully", map[string]interface{}{
                "preset_key": preset.Key,
        })

        return nil</span>
}

// UpdatePreset updates an existing preset
func (r *presetRepositoryImpl) UpdatePreset(ctx context.Context, preset *entities.Preset) error <span class="cov0" title="0">{
        err := r.db.Save(preset).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to update preset", err)
                return fmt.Errorf("failed to update preset: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info(ctx, "Preset updated successfully", map[string]interface{}{
                "preset_key": preset.Key,
        })

        return nil</span>
}

// DeletePreset deletes a preset by key
func (r *presetRepositoryImpl) DeletePreset(ctx context.Context, key string) error <span class="cov0" title="0">{
        result := r.db.Where("key = ?", key).Delete(&amp;entities.Preset{})
        if result.Error != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to delete preset", result.Error)
                return fmt.Errorf("failed to delete preset: %w", result.Error)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("preset not found: %s", key)
        }</span>

        <span class="cov0" title="0">r.logger.Info(ctx, "Preset deleted successfully", map[string]interface{}{
                "preset_key": key,
        })

        return nil</span>
}

// GetPresetsByKeyPrefix retrieves presets that start with the given key prefix
func (r *presetRepositoryImpl) GetPresetsByKeyPrefix(ctx context.Context, keyPrefix string) ([]*entities.Preset, error) <span class="cov0" title="0">{
        var presets []*entities.Preset
        err := r.db.Where("key LIKE ?", keyPrefix+"%").Find(&amp;presets).Error
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get presets by key prefix", err)
                return nil, fmt.Errorf("failed to get presets: %w", err)
        }</span>

        <span class="cov0" title="0">return presets, nil</span>
}</pre>
		
		<pre class="file" id="file53" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/repositories"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/services"
        "github.com/go-playground/validator/v10"
)

type presetServiceImpl struct {
        presetRepo repositories.PresetRepository
        logger     logger.Logger
        validator  *validator.Validate
}

// NewPresetService creates a new preset service implementation
func NewPresetService(
        presetRepo repositories.PresetRepository,
        logger logger.Logger,
) services.PresetService <span class="cov0" title="0">{
        return &amp;presetServiceImpl{
                presetRepo: presetRepo,
                logger:     logger,
                validator:  validator.New(),
        }
}</span>

// GetEnergyLocations retrieves all available energy locations
func (s *presetServiceImpl) GetEnergyLocations(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        locations, err := s.presetRepo.GetEnergyLocations(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get energy locations", err)
                return nil, fmt.Errorf("failed to get energy locations: %w", err)
        }</span>

        <span class="cov0" title="0">return locations, nil</span>
}

// GetMachinePresets retrieves all machine presets with parsed data
func (s *presetServiceImpl) GetMachinePresets(ctx context.Context) ([]*entities.MachinePreset, error) <span class="cov0" title="0">{
        presets, err := s.presetRepo.GetMachinePresets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get machine presets", err)
                return nil, fmt.Errorf("failed to get machine presets: %w", err)
        }</span>

        <span class="cov0" title="0">var machinePresets []*entities.MachinePreset
        for _, preset := range presets </span><span class="cov0" title="0">{
                var machinePreset entities.MachinePreset
                if err := preset.UnmarshalDataTo(&amp;machinePreset); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warning(ctx, "Failed to unmarshal machine preset", map[string]interface{}{
                                "preset_key": preset.Key,
                                "error":      err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">machinePresets = append(machinePresets, &amp;machinePreset)</span>
        }

        <span class="cov0" title="0">return machinePresets, nil</span>
}

// GetEnergyPresets retrieves energy presets, optionally filtered by location
func (s *presetServiceImpl) GetEnergyPresets(ctx context.Context, location string) ([]*entities.EnergyPreset, error) <span class="cov0" title="0">{
        presets, err := s.presetRepo.GetEnergyPresets(ctx, location)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get energy presets", err)
                return nil, fmt.Errorf("failed to get energy presets: %w", err)
        }</span>

        <span class="cov0" title="0">var energyPresets []*entities.EnergyPreset
        for _, preset := range presets </span><span class="cov0" title="0">{
                var energyPreset entities.EnergyPreset
                if err := preset.UnmarshalDataTo(&amp;energyPreset); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warning(ctx, "Failed to unmarshal energy preset", map[string]interface{}{
                                "preset_key": preset.Key,
                                "error":      err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">energyPresets = append(energyPresets, &amp;energyPreset)</span>
        }

        <span class="cov0" title="0">return energyPresets, nil</span>
}

// CreateEnergyPreset creates a new energy preset (admin only)
func (s *presetServiceImpl) CreateEnergyPreset(ctx context.Context, preset *entities.EnergyPreset, requesterID string) error <span class="cov0" title="0">{
        // Validate admin permissions
        if err := s.ValidateAdminPermissions(ctx, requesterID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate preset data
        <span class="cov0" title="0">if err := s.validator.Struct(preset); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Energy preset validation failed", err)
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Generate unique key
        <span class="cov0" title="0">key := s.generateEnergyPresetKey(preset)

        // Create preset entity
        presetEntity := &amp;entities.Preset{
                Key: key,
        }

        if err := presetEntity.MarshalDataFrom(preset); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to marshal energy preset data", err)
                return fmt.Errorf("failed to marshal preset data: %w", err)
        }</span>

        // Create in repository
        <span class="cov0" title="0">if err := s.presetRepo.CreatePreset(ctx, presetEntity); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to create energy preset", err)
                return fmt.Errorf("failed to create energy preset: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Energy preset created successfully", map[string]interface{}{
                "preset_key":   key,
                "location":     preset.Location,
                "year":         preset.Year,
                "requester_id": requesterID,
        })

        return nil</span>
}

// CreateMachinePreset creates a new machine preset (admin only)
func (s *presetServiceImpl) CreateMachinePreset(ctx context.Context, preset *entities.MachinePreset, requesterID string) error <span class="cov0" title="0">{
        // Validate admin permissions
        if err := s.ValidateAdminPermissions(ctx, requesterID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate preset data
        <span class="cov0" title="0">if err := s.validator.Struct(preset); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Machine preset validation failed", err)
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Generate unique key
        <span class="cov0" title="0">key := s.generateMachinePresetKey(preset)

        // Create preset entity
        presetEntity := &amp;entities.Preset{
                Key: key,
        }

        if err := presetEntity.MarshalDataFrom(preset); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to marshal machine preset data", err)
                return fmt.Errorf("failed to marshal preset data: %w", err)
        }</span>

        // Create in repository
        <span class="cov0" title="0">if err := s.presetRepo.CreatePreset(ctx, presetEntity); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to create machine preset", err)
                return fmt.Errorf("failed to create machine preset: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Machine preset created successfully", map[string]interface{}{
                "preset_key":   key,
                "name":         preset.Name,
                "brand":        preset.Brand,
                "model":        preset.Model,
                "requester_id": requesterID,
        })

        return nil</span>
}

// UpdatePreset updates an existing preset (admin only)
func (s *presetServiceImpl) UpdatePreset(ctx context.Context, key string, data interface{}, requesterID string) error <span class="cov0" title="0">{
        // Validate admin permissions
        if err := s.ValidateAdminPermissions(ctx, requesterID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get existing preset
        <span class="cov0" title="0">preset, err := s.presetRepo.GetPresetByKey(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get preset for update", err)
                return fmt.Errorf("failed to get preset: %w", err)
        }</span>

        // Validate new data
        <span class="cov0" title="0">if err := s.validator.Struct(data); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Preset update data validation failed", err)
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Marshal new data
        <span class="cov0" title="0">if err := preset.MarshalDataFrom(data); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to marshal updated preset data", err)
                return fmt.Errorf("failed to marshal preset data: %w", err)
        }</span>

        // Update in repository
        <span class="cov0" title="0">if err := s.presetRepo.UpdatePreset(ctx, preset); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to update preset", err)
                return fmt.Errorf("failed to update preset: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Preset updated successfully", map[string]interface{}{
                "preset_key":   key,
                "requester_id": requesterID,
        })

        return nil</span>
}

// DeletePreset deletes a preset (admin only)
func (s *presetServiceImpl) DeletePreset(ctx context.Context, key string, requesterID string) error <span class="cov0" title="0">{
        // Validate admin permissions
        if err := s.ValidateAdminPermissions(ctx, requesterID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete from repository
        <span class="cov0" title="0">if err := s.presetRepo.DeletePreset(ctx, key); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to delete preset", err)
                return fmt.Errorf("failed to delete preset: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Preset deleted successfully", map[string]interface{}{
                "preset_key":   key,
                "requester_id": requesterID,
        })

        return nil</span>
}

// ValidateAdminPermissions validates if user has admin permissions
// TODO: Implement proper admin validation using middleware or user service
func (s *presetServiceImpl) ValidateAdminPermissions(ctx context.Context, userID string) error <span class="cov0" title="0">{
        // For now, we'll implement this validation at the handler level via middleware
        // This is a simplified placeholder to avoid circular dependencies
        if userID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("admin permissions required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (s *presetServiceImpl) generateEnergyPresetKey(preset *entities.EnergyPreset) string <span class="cov0" title="0">{
        // Generate key like: energy_maceio_al_2025
        location := strings.ToLower(strings.ReplaceAll(preset.Location, " ", "_"))
        location = strings.ReplaceAll(location, "-", "_")
        return fmt.Sprintf("energy_%s_%d", location, preset.Year)
}</span>

func (s *presetServiceImpl) generateMachinePresetKey(preset *entities.MachinePreset) string <span class="cov0" title="0">{
        // Generate key like: machine_ender3_v2_creality
        name := strings.ToLower(strings.ReplaceAll(preset.Name, " ", "_"))
        brand := strings.ToLower(strings.ReplaceAll(preset.Brand, " ", "_"))
        model := strings.ToLower(strings.ReplaceAll(preset.Model, " ", "_"))

        timestamp := time.Now().Unix()
        return fmt.Sprintf("machine_%s_%s_%s_%d", name, brand, model, timestamp)
}</pre>
		
		<pre class="file" id="file54" style="display: none">package di

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"

        presetRepositories "github.com/RodolfoBonis/spooliq/features/presets/data/repositories"
        presetServices "github.com/RodolfoBonis/spooliq/features/presets/data/services"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/repositories"
        domainServices "github.com/RodolfoBonis/spooliq/features/presets/domain/services"
        "github.com/RodolfoBonis/spooliq/features/presets/presentation/handlers"
)

// Module provides the presets feature module
var Module = fx.Module("presets",
        fx.Provide(
                // Repositories
                fx.Annotate(
                        presetRepositories.NewPresetRepository,
                        fx.As(new(repositories.PresetRepository)),
                ),

                // Services
                fx.Annotate(
                        presetServices.NewPresetService,
                        fx.As(new(domainServices.PresetService)),
                ),

                // Handlers
                handlers.NewPresetHandler,
        ),
        fx.Invoke(RegisterPresetRoutes),
)

// RegisterPresetRoutes registers the preset routes
func RegisterPresetRoutes(r *gin.Engine, handler *handlers.PresetHandler) <span class="cov0" title="0">{
        v1 := r.Group("/v1")
        </span><span class="cov0" title="0">{
                // Preset endpoints
                presets := v1.Group("/presets")
                </span><span class="cov0" title="0">{
                        // Public endpoints for reading presets
                        presets.GET("/energy/locations", handler.GetEnergyLocations)  // GET /v1/presets/energy/locations
                        presets.GET("/machines", handler.GetMachinePresets)           // GET /v1/presets/machines
                        presets.GET("/energy", handler.GetEnergyPresets)              // GET /v1/presets/energy

                        // Admin endpoints for managing presets
                        presets.POST("", handler.CreatePreset)          // POST /v1/presets (admin)
                        presets.PUT("/:key", handler.UpdatePreset)      // PUT /v1/presets/{key} (admin)
                        presets.DELETE("/:key", handler.DeletePreset)   // DELETE /v1/presets/{key} (admin)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file55" style="display: none">package entities

import (
        "encoding/json"
        "time"

        "github.com/jinzhu/gorm"
)

// Preset representa um preset de configuração (tarifas, máquinas, etc.)
// @Description Preset de configuração do sistema
// @Example {"id": 1, "key": "energy_maceio_al_2025", "data": {"base_tariff": 0.804, "flag_surcharge": 0, "location": "Maceió-AL", "year": 2025}}
type Preset struct {
        ID        uint      `gorm:"primary_key;auto_increment" json:"id"`
        Key       string    `gorm:"type:varchar(255);unique_index;not null" json:"key" validate:"required,min=1,max=255"`
        Data      string    `gorm:"type:text;not null" json:"data" validate:"required"` // JSON blob
        CreatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
        UpdatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"updated_at"`
        DeletedAt *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}

// TableName especifica o nome da tabela para o GORM
func (Preset) TableName() string <span class="cov0" title="0">{
        return "presets"
}</span>

// BeforeCreate é um hook do GORM executado antes de criar um preset
func (p *Preset) BeforeCreate(scope *gorm.Scope) error <span class="cov0" title="0">{
        p.CreatedAt = time.Now()
        p.UpdatedAt = time.Now()
        return nil
}</span>

// BeforeUpdate é um hook do GORM executado antes de atualizar um preset
func (p *Preset) BeforeUpdate(scope *gorm.Scope) error <span class="cov0" title="0">{
        p.UpdatedAt = time.Now()
        return nil
}</span>

// GetDataAsMap retorna os dados do preset como um map
func (p *Preset) GetDataAsMap() (map[string]interface{}, error) <span class="cov0" title="0">{
        var data map[string]interface{}
        err := json.Unmarshal([]byte(p.Data), &amp;data)
        return data, err
}</span>

// SetDataFromMap define os dados do preset a partir de um map
func (p *Preset) SetDataFromMap(data map[string]interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p.Data = string(jsonData)
        return nil</span>
}

// UnmarshalDataTo deserializa os dados para uma estrutura específica
func (p *Preset) UnmarshalDataTo(target interface{}) error <span class="cov0" title="0">{
        return json.Unmarshal([]byte(p.Data), target)
}</span>

// MarshalDataFrom serializa dados de uma estrutura específica
func (p *Preset) MarshalDataFrom(source interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.Marshal(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p.Data = string(jsonData)
        return nil</span>
}

// Estruturas específicas para diferentes tipos de presets

// EnergyPreset representa um preset de tarifa energética
type EnergyPreset struct {
        BaseTariff    float64 `json:"base_tariff" validate:"required,min=0"`
        FlagSurcharge float64 `json:"flag_surcharge" validate:"min=0"`
        Location      string  `json:"location" validate:"required"`
        Year          int     `json:"year" validate:"required,min=2020"`
        Description   string  `json:"description,omitempty"`
}

// MachinePreset representa um preset de máquina/impressora
type MachinePreset struct {
        Name        string  `json:"name" validate:"required"`
        Brand       string  `json:"brand" validate:"required"`
        Model       string  `json:"model" validate:"required"`
        Watt        float64 `json:"watt" validate:"required,min=0"`
        IdleFactor  float64 `json:"idle_factor" validate:"min=0,max=1"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty"`
}</pre>
		
		<pre class="file" id="file56" style="display: none">package dto

import (
        "github.com/RodolfoBonis/spooliq/features/presets/domain/entities"
)

// EnergyLocationResponse represents energy locations in API responses
type EnergyLocationResponse struct {
        Locations []string `json:"locations"`
}

// MachinePresetResponse represents machine preset in API responses
type MachinePresetResponse struct {
        Name        string  `json:"name"`
        Brand       string  `json:"brand"`
        Model       string  `json:"model"`
        Watt        float64 `json:"watt"`
        IdleFactor  float64 `json:"idle_factor"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty"`
}

// EnergyPresetResponse represents energy preset in API responses
type EnergyPresetResponse struct {
        BaseTariff    float64 `json:"base_tariff"`
        FlagSurcharge float64 `json:"flag_surcharge"`
        Location      string  `json:"location"`
        Year          int     `json:"year"`
        Description   string  `json:"description,omitempty"`
}

// CreateEnergyPresetRequest represents request to create energy preset
type CreateEnergyPresetRequest struct {
        BaseTariff    float64 `json:"base_tariff" validate:"required,min=0"`
        FlagSurcharge float64 `json:"flag_surcharge" validate:"min=0"`
        Location      string  `json:"location" validate:"required"`
        Year          int     `json:"year" validate:"required,min=2020"`
        Description   string  `json:"description,omitempty"`
}

// CreateMachinePresetRequest represents request to create machine preset
type CreateMachinePresetRequest struct {
        Name        string  `json:"name" validate:"required"`
        Brand       string  `json:"brand" validate:"required"`
        Model       string  `json:"model" validate:"required"`
        Watt        float64 `json:"watt" validate:"required,min=0"`
        IdleFactor  float64 `json:"idle_factor" validate:"min=0,max=1"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty"`
}

// UpdatePresetRequest represents request to update any preset
type UpdatePresetRequest struct {
        Data interface{} `json:"data" validate:"required"`
}

// MachinePresetsResponse represents machine presets list response
type MachinePresetsResponse struct {
        Machines []MachinePresetResponse `json:"machines"`
}

// EnergyPresetsResponse represents energy presets list response
type EnergyPresetsResponse struct {
        Presets []EnergyPresetResponse `json:"presets"`
}

// Conversion methods

// ToEnergyPresetEntity converts CreateEnergyPresetRequest to domain entity
func (req *CreateEnergyPresetRequest) ToEntity() *entities.EnergyPreset <span class="cov0" title="0">{
        return &amp;entities.EnergyPreset{
                BaseTariff:    req.BaseTariff,
                FlagSurcharge: req.FlagSurcharge,
                Location:      req.Location,
                Year:          req.Year,
                Description:   req.Description,
        }
}</span>

// ToMachinePresetEntity converts CreateMachinePresetRequest to domain entity
func (req *CreateMachinePresetRequest) ToEntity() *entities.MachinePreset <span class="cov0" title="0">{
        return &amp;entities.MachinePreset{
                Name:        req.Name,
                Brand:       req.Brand,
                Model:       req.Model,
                Watt:        req.Watt,
                IdleFactor:  req.IdleFactor,
                Description: req.Description,
                URL:         req.URL,
        }
}</span>

// FromMachinePresetEntity converts domain entity to response DTO
func FromMachinePresetEntity(entity *entities.MachinePreset) MachinePresetResponse <span class="cov0" title="0">{
        return MachinePresetResponse{
                Name:        entity.Name,
                Brand:       entity.Brand,
                Model:       entity.Model,
                Watt:        entity.Watt,
                IdleFactor:  entity.IdleFactor,
                Description: entity.Description,
                URL:         entity.URL,
        }
}</span>

// FromEnergyPresetEntity converts domain entity to response DTO
func FromEnergyPresetEntity(entity *entities.EnergyPreset) EnergyPresetResponse <span class="cov0" title="0">{
        return EnergyPresetResponse{
                BaseTariff:    entity.BaseTariff,
                FlagSurcharge: entity.FlagSurcharge,
                Location:      entity.Location,
                Year:          entity.Year,
                Description:   entity.Description,
        }
}</span>

// FromMachinePresetEntities converts slice of domain entities to response DTOs
func FromMachinePresetEntities(entities []*entities.MachinePreset) []MachinePresetResponse <span class="cov0" title="0">{
        responses := make([]MachinePresetResponse, len(entities))
        for i, entity := range entities </span><span class="cov0" title="0">{
                responses[i] = FromMachinePresetEntity(entity)
        }</span>
        <span class="cov0" title="0">return responses</span>
}

// FromEnergyPresetEntities converts slice of domain entities to response DTOs
func FromEnergyPresetEntities(entities []*entities.EnergyPreset) []EnergyPresetResponse <span class="cov0" title="0">{
        responses := make([]EnergyPresetResponse, len(entities))
        for i, entity := range entities </span><span class="cov0" title="0">{
                responses[i] = FromEnergyPresetEntity(entity)
        }</span>
        <span class="cov0" title="0">return responses</span>
}</pre>
		
		<pre class="file" id="file57" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/presets/domain/services"
        "github.com/RodolfoBonis/spooliq/features/presets/presentation/dto"
)

type PresetHandler struct {
        presetService services.PresetService
        logger        logger.Logger
        validator     *validator.Validate
}

// NewPresetHandler creates a new preset handler
func NewPresetHandler(
        presetService services.PresetService,
        logger logger.Logger,
) *PresetHandler <span class="cov0" title="0">{
        return &amp;PresetHandler{
                presetService: presetService,
                logger:        logger,
                validator:     validator.New(),
        }
}</span>

// GetEnergyLocations retrieves all available energy preset locations
// @Summary Get energy locations
// @Description Retrieves all available locations for energy presets
// @Tags presets
// @Produce json
// @Success 200 {object} dto.EnergyLocationResponse
// @Failure 500 {object} errors.HTTPError
// @Router /presets/energy/locations [get]
func (h *PresetHandler) GetEnergyLocations(c *gin.Context) <span class="cov0" title="0">{
        locations, err := h.presetService.GetEnergyLocations(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrService, "Failed to get energy locations", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get energy locations", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">response := dto.EnergyLocationResponse{
                Locations: locations,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetMachinePresets retrieves all machine presets
// @Summary Get machine presets
// @Description Retrieves all available machine presets
// @Tags presets
// @Produce json
// @Success 200 {object} dto.MachinePresetsResponse
// @Failure 500 {object} errors.HTTPError
// @Router /presets/machines [get]
func (h *PresetHandler) GetMachinePresets(c *gin.Context) <span class="cov0" title="0">{
        machines, err := h.presetService.GetMachinePresets(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrService, "Failed to get machine presets", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get machine presets", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">response := dto.MachinePresetsResponse{
                Machines: dto.FromMachinePresetEntities(machines),
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetEnergyPresets retrieves energy presets, optionally filtered by location
// @Summary Get energy presets
// @Description Retrieves energy presets, optionally filtered by location
// @Tags presets
// @Produce json
// @Param location query string false "Filter by location"
// @Success 200 {object} dto.EnergyPresetsResponse
// @Failure 500 {object} errors.HTTPError
// @Router /presets/energy [get]
func (h *PresetHandler) GetEnergyPresets(c *gin.Context) <span class="cov0" title="0">{
        location := c.Query("location")

        presets, err := h.presetService.GetEnergyPresets(c.Request.Context(), location)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrService, "Failed to get energy presets", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get energy presets", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">response := dto.EnergyPresetsResponse{
                Presets: dto.FromEnergyPresetEntities(presets),
        }

        c.JSON(http.StatusOK, response)</span>
}

// CreatePreset creates a new preset (admin only)
// @Summary Create preset
// @Description Creates a new energy or machine preset (admin only)
// @Tags presets
// @Accept json
// @Produce json
// @Param type query string true "Preset type: 'energy' or 'machine'"
// @Param request body interface{} true "Preset data (CreateEnergyPresetRequest or CreateMachinePresetRequest)"
// @Success 201 "Preset created successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /presets [post]
// @Security BearerAuth
func (h *PresetHandler) CreatePreset(c *gin.Context) <span class="cov0" title="0">{
        presetType := c.Query("type")
        if presetType == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Preset type is required (energy or machine)", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Preset type not specified", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">switch presetType </span>{
        case "energy":<span class="cov0" title="0">
                h.createEnergyPreset(c, requesterID)</span>
        case "machine":<span class="cov0" title="0">
                h.createMachinePreset(c, requesterID)</span>
        default:<span class="cov0" title="0">
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid preset type. Must be 'energy' or 'machine'", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Invalid preset type", appError)
                c.JSON(httpError.StatusCode, httpError)
                return</span>
        }
}

func (h *PresetHandler) createEnergyPreset(c *gin.Context, requesterID string) <span class="cov0" title="0">{
        // Bind request
        var req dto.CreateEnergyPresetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind energy preset request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Energy preset request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to domain entity
        <span class="cov0" title="0">energyPreset := req.ToEntity()

        // Create preset
        err := h.presetService.CreateEnergyPreset(c.Request.Context(), energyPreset, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to create energy preset", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info(c.Request.Context(), "Energy preset created successfully", map[string]interface{}{
                "location":     energyPreset.Location,
                "year":         energyPreset.Year,
                "requester_id": requesterID,
        })

        c.Status(http.StatusCreated)</span>
}

func (h *PresetHandler) createMachinePreset(c *gin.Context, requesterID string) <span class="cov0" title="0">{
        // Bind request
        var req dto.CreateMachinePresetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind machine preset request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Machine preset request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to domain entity
        <span class="cov0" title="0">machinePreset := req.ToEntity()

        // Create preset
        err := h.presetService.CreateMachinePreset(c.Request.Context(), machinePreset, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to create machine preset", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info(c.Request.Context(), "Machine preset created successfully", map[string]interface{}{
                "name":         machinePreset.Name,
                "brand":        machinePreset.Brand,
                "model":        machinePreset.Model,
                "requester_id": requesterID,
        })

        c.Status(http.StatusCreated)</span>
}

// UpdatePreset updates an existing preset (admin only)
// @Summary Update preset
// @Description Updates an existing preset by key (admin only)
// @Tags presets
// @Accept json
// @Produce json
// @Param key path string true "Preset key"
// @Param request body dto.UpdatePresetRequest true "Updated preset data"
// @Success 200 "Preset updated successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /presets/{key} [put]
// @Security BearerAuth
func (h *PresetHandler) UpdatePreset(c *gin.Context) <span class="cov0" title="0">{
        key := c.Param("key")
        if key == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Preset key is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Preset key not provided", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">var req dto.UpdatePresetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind update preset request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Update preset
        <span class="cov0" title="0">err := h.presetService.UpdatePreset(c.Request.Context(), key, req.Data, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to update preset", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

// DeletePreset deletes a preset (admin only)
// @Summary Delete preset
// @Description Deletes a preset by key (admin only)
// @Tags presets
// @Param key path string true "Preset key"
// @Success 204 "Preset deleted successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /presets/{key} [delete]
// @Security BearerAuth
func (h *PresetHandler) DeletePreset(c *gin.Context) <span class="cov0" title="0">{
        key := c.Param("key")
        if key == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Preset key is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Preset key not provided", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Delete preset
        <span class="cov0" title="0">err := h.presetService.DeletePreset(c.Request.Context(), key, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to delete preset", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// Helper methods

func (h *PresetHandler) mapDomainError(err error) *errors.AppError <span class="cov0" title="0">{
        errMsg := err.Error()

        switch </span>{
        case contains(errMsg, "not found"):<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrNotFound, "Preset not found", nil, err)</span>
        case contains(errMsg, "already exists"):<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrConflict, "Preset already exists", nil, err)</span>
        case contains(errMsg, "admin permissions required"):<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrUnauthorized, "Admin permissions required", nil, err)</span>
        case contains(errMsg, "validation failed"):<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)</span>
        default:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrService, "Internal server error", nil, err)</span>
        }
}

func contains(str, substr string) bool <span class="cov0" title="0">{
        return len(str) &gt;= len(substr) &amp;&amp; (str == substr || (len(str) &gt; len(substr) &amp;&amp; (str[:len(substr)] == substr || str[len(str)-len(substr):] == substr || contains(str[1:], substr))))
}</pre>
		
		<pre class="file" id="file58" style="display: none">package mappers

import (
        "github.com/RodolfoBonis/spooliq/features/quotes/data/models"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/quotes/presentation/dto"
)

// ModelToEntity converte QuoteModel para Quote entity
func ModelToEntity(model *models.QuoteModel) *entities.Quote <span class="cov0" title="0">{
        if model == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">entity := &amp;entities.Quote{
                ID:          model.ID,
                Title:       model.Title,
                Notes:       model.Notes,
                OwnerUserID: model.OwnerUserID,
                CreatedAt:   model.CreatedAt,
                UpdatedAt:   model.UpdatedAt,
        }

        // Convert filament lines
        if len(model.FilamentLines) &gt; 0 </span><span class="cov0" title="0">{
                entity.FilamentLines = make([]entities.QuoteFilamentLine, 0, len(model.FilamentLines))
                for _, lineModel := range model.FilamentLines </span><span class="cov0" title="0">{
                        entity.FilamentLines = append(entity.FilamentLines, entities.QuoteFilamentLine{
                                ID:                            lineModel.ID,
                                QuoteID:                       lineModel.QuoteID,
                                FilamentSnapshotName:          lineModel.FilamentSnapshotName,
                                FilamentSnapshotBrand:         lineModel.FilamentSnapshotBrand,
                                FilamentSnapshotMaterial:      lineModel.FilamentSnapshotMaterial,
                                FilamentSnapshotColor:         lineModel.FilamentSnapshotColor,
                                FilamentSnapshotColorHex:      lineModel.FilamentSnapshotColorHex,
                                FilamentSnapshotPricePerKg:    lineModel.FilamentSnapshotPricePerKg,
                                FilamentSnapshotPricePerMeter: lineModel.FilamentSnapshotPricePerMeter,
                                FilamentSnapshotURL:           lineModel.FilamentSnapshotURL,
                                WeightGrams:                   lineModel.WeightGrams,
                                LengthMeters:                  lineModel.LengthMeters,
                                CreatedAt:                     lineModel.CreatedAt,
                                UpdatedAt:                     lineModel.UpdatedAt,
                        })
                }</span>
        }

        // Convert profiles
        <span class="cov0" title="0">if model.MachineProfile != nil </span><span class="cov0" title="0">{
                entity.MachineProfile = &amp;entities.MachineProfile{
                        ID:          model.MachineProfile.ID,
                        QuoteID:     model.MachineProfile.QuoteID,
                        Name:        model.MachineProfile.Name,
                        Brand:       model.MachineProfile.Brand,
                        Model:       model.MachineProfile.Model,
                        Watt:        model.MachineProfile.Watt,
                        IdleFactor:  model.MachineProfile.IdleFactor,
                        Description: model.MachineProfile.Description,
                        URL:         model.MachineProfile.URL,
                        CreatedAt:   model.MachineProfile.CreatedAt,
                        UpdatedAt:   model.MachineProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if model.EnergyProfile != nil </span><span class="cov0" title="0">{
                entity.EnergyProfile = &amp;entities.EnergyProfile{
                        ID:            model.EnergyProfile.ID,
                        QuoteID:       model.EnergyProfile.QuoteID,
                        BaseTariff:    model.EnergyProfile.BaseTariff,
                        FlagSurcharge: model.EnergyProfile.FlagSurcharge,
                        Location:      model.EnergyProfile.Location,
                        Year:          model.EnergyProfile.Year,
                        Description:   model.EnergyProfile.Description,
                        CreatedAt:     model.EnergyProfile.CreatedAt,
                        UpdatedAt:     model.EnergyProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if model.CostProfile != nil </span><span class="cov0" title="0">{
                entity.CostProfile = &amp;entities.CostProfile{
                        ID:             model.CostProfile.ID,
                        QuoteID:        model.CostProfile.QuoteID,
                        WearPercentage: model.CostProfile.WearPercentage,
                        OverheadAmount: model.CostProfile.OverheadAmount,
                        Description:    model.CostProfile.Description,
                        CreatedAt:      model.CostProfile.CreatedAt,
                        UpdatedAt:      model.CostProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if model.MarginProfile != nil </span><span class="cov0" title="0">{
                entity.MarginProfile = &amp;entities.MarginProfile{
                        ID:                    model.MarginProfile.ID,
                        QuoteID:               model.MarginProfile.QuoteID,
                        PrintingOnlyMargin:    model.MarginProfile.PrintingOnlyMargin,
                        PrintingPlusMargin:    model.MarginProfile.PrintingPlusMargin,
                        FullServiceMargin:     model.MarginProfile.FullServiceMargin,
                        OperatorRatePerHour:   model.MarginProfile.OperatorRatePerHour,
                        ModelerRatePerHour:    model.MarginProfile.ModelerRatePerHour,
                        Description:           model.MarginProfile.Description,
                        CreatedAt:             model.MarginProfile.CreatedAt,
                        UpdatedAt:             model.MarginProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">return entity</span>
}

// EntityToModel converte Quote entity para QuoteModel
func EntityToModel(entity *entities.Quote) *models.QuoteModel <span class="cov0" title="0">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">model := &amp;models.QuoteModel{
                ID:          entity.ID,
                Title:       entity.Title,
                Notes:       entity.Notes,
                OwnerUserID: entity.OwnerUserID,
                CreatedAt:   entity.CreatedAt,
                UpdatedAt:   entity.UpdatedAt,
        }

        // Convert filament lines
        if len(entity.FilamentLines) &gt; 0 </span><span class="cov0" title="0">{
                model.FilamentLines = make([]models.QuoteFilamentLineModel, 0, len(entity.FilamentLines))
                for _, lineEntity := range entity.FilamentLines </span><span class="cov0" title="0">{
                        model.FilamentLines = append(model.FilamentLines, models.QuoteFilamentLineModel{
                                ID:                            lineEntity.ID,
                                QuoteID:                       lineEntity.QuoteID,
                                FilamentSnapshotName:          lineEntity.FilamentSnapshotName,
                                FilamentSnapshotBrand:         lineEntity.FilamentSnapshotBrand,
                                FilamentSnapshotMaterial:      lineEntity.FilamentSnapshotMaterial,
                                FilamentSnapshotColor:         lineEntity.FilamentSnapshotColor,
                                FilamentSnapshotColorHex:      lineEntity.FilamentSnapshotColorHex,
                                FilamentSnapshotPricePerKg:    lineEntity.FilamentSnapshotPricePerKg,
                                FilamentSnapshotPricePerMeter: lineEntity.FilamentSnapshotPricePerMeter,
                                FilamentSnapshotURL:           lineEntity.FilamentSnapshotURL,
                                WeightGrams:                   lineEntity.WeightGrams,
                                LengthMeters:                  lineEntity.LengthMeters,
                                CreatedAt:                     lineEntity.CreatedAt,
                                UpdatedAt:                     lineEntity.UpdatedAt,
                        })
                }</span>
        }

        // Convert profiles
        <span class="cov0" title="0">if entity.MachineProfile != nil </span><span class="cov0" title="0">{
                model.MachineProfile = &amp;models.MachineProfileModel{
                        ID:          entity.MachineProfile.ID,
                        QuoteID:     entity.MachineProfile.QuoteID,
                        Name:        entity.MachineProfile.Name,
                        Brand:       entity.MachineProfile.Brand,
                        Model:       entity.MachineProfile.Model,
                        Watt:        entity.MachineProfile.Watt,
                        IdleFactor:  entity.MachineProfile.IdleFactor,
                        Description: entity.MachineProfile.Description,
                        URL:         entity.MachineProfile.URL,
                        CreatedAt:   entity.MachineProfile.CreatedAt,
                        UpdatedAt:   entity.MachineProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if entity.EnergyProfile != nil </span><span class="cov0" title="0">{
                model.EnergyProfile = &amp;models.EnergyProfileModel{
                        ID:            entity.EnergyProfile.ID,
                        QuoteID:       entity.EnergyProfile.QuoteID,
                        BaseTariff:    entity.EnergyProfile.BaseTariff,
                        FlagSurcharge: entity.EnergyProfile.FlagSurcharge,
                        Location:      entity.EnergyProfile.Location,
                        Year:          entity.EnergyProfile.Year,
                        Description:   entity.EnergyProfile.Description,
                        CreatedAt:     entity.EnergyProfile.CreatedAt,
                        UpdatedAt:     entity.EnergyProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if entity.CostProfile != nil </span><span class="cov0" title="0">{
                model.CostProfile = &amp;models.CostProfileModel{
                        ID:             entity.CostProfile.ID,
                        QuoteID:        entity.CostProfile.QuoteID,
                        WearPercentage: entity.CostProfile.WearPercentage,
                        OverheadAmount: entity.CostProfile.OverheadAmount,
                        Description:    entity.CostProfile.Description,
                        CreatedAt:      entity.CostProfile.CreatedAt,
                        UpdatedAt:      entity.CostProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">if entity.MarginProfile != nil </span><span class="cov0" title="0">{
                model.MarginProfile = &amp;models.MarginProfileModel{
                        ID:                    entity.MarginProfile.ID,
                        QuoteID:               entity.MarginProfile.QuoteID,
                        PrintingOnlyMargin:    entity.MarginProfile.PrintingOnlyMargin,
                        PrintingPlusMargin:    entity.MarginProfile.PrintingPlusMargin,
                        FullServiceMargin:     entity.MarginProfile.FullServiceMargin,
                        OperatorRatePerHour:   entity.MarginProfile.OperatorRatePerHour,
                        ModelerRatePerHour:    entity.MarginProfile.ModelerRatePerHour,
                        Description:           entity.MarginProfile.Description,
                        CreatedAt:             entity.MarginProfile.CreatedAt,
                        UpdatedAt:             entity.MarginProfile.UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">return model</span>
}

// CreateRequestToEntity converte CreateQuoteRequest para Quote entity
// Note: This function now only handles the basic quote data.
// Filament line processing with snapshots should be handled in the service layer.
func CreateRequestToEntity(req *dto.CreateQuoteRequest, ownerUserID string) *entities.Quote <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">entity := &amp;entities.Quote{
                Title:       req.Title,
                Notes:       req.Notes,
                OwnerUserID: ownerUserID,
        }

        // Note: FilamentLines are now processed separately in the service layer
        // to support both automatic snapshots and manual snapshot data

        // Convert profiles
        if req.MachineProfile != nil </span><span class="cov0" title="0">{
                entity.MachineProfile = &amp;entities.MachineProfile{
                        Name:        req.MachineProfile.Name,
                        Brand:       req.MachineProfile.Brand,
                        Model:       req.MachineProfile.Model,
                        Watt:        req.MachineProfile.Watt,
                        IdleFactor:  req.MachineProfile.IdleFactor,
                        Description: req.MachineProfile.Description,
                        URL:         req.MachineProfile.URL,
                }
        }</span>

        <span class="cov0" title="0">if req.EnergyProfile != nil </span><span class="cov0" title="0">{
                entity.EnergyProfile = &amp;entities.EnergyProfile{
                        BaseTariff:    req.EnergyProfile.BaseTariff,
                        FlagSurcharge: req.EnergyProfile.FlagSurcharge,
                        Location:      req.EnergyProfile.Location,
                        Year:          req.EnergyProfile.Year,
                        Description:   req.EnergyProfile.Description,
                }
        }</span>

        <span class="cov0" title="0">if req.CostProfile != nil </span><span class="cov0" title="0">{
                entity.CostProfile = &amp;entities.CostProfile{
                        WearPercentage: req.CostProfile.WearPercentage,
                        OverheadAmount: req.CostProfile.OverheadAmount,
                        Description:    req.CostProfile.Description,
                }
        }</span>

        <span class="cov0" title="0">if req.MarginProfile != nil </span><span class="cov0" title="0">{
                entity.MarginProfile = &amp;entities.MarginProfile{
                        PrintingOnlyMargin:  req.MarginProfile.PrintingOnlyMargin,
                        PrintingPlusMargin:  req.MarginProfile.PrintingPlusMargin,
                        FullServiceMargin:   req.MarginProfile.FullServiceMargin,
                        OperatorRatePerHour: req.MarginProfile.OperatorRatePerHour,
                        ModelerRatePerHour:  req.MarginProfile.ModelerRatePerHour,
                        Description:         req.MarginProfile.Description,
                }
        }</span>

        <span class="cov0" title="0">return entity</span>
}

// ModelsToEntities converte slice de QuoteModel para slice de Quote entities
func ModelsToEntities(models []*models.QuoteModel) []*entities.Quote <span class="cov0" title="0">{
        if models == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">entities := make([]*entities.Quote, 0, len(models))
        for _, model := range models </span><span class="cov0" title="0">{
                entities = append(entities, ModelToEntity(model))
        }</span>
        <span class="cov0" title="0">return entities</span>
}</pre>
		
		<pre class="file" id="file59" style="display: none">package models

import (
        "time"

        "github.com/jinzhu/gorm"
)

// QuoteModel representa um orçamento de impressão 3D no banco de dados
type QuoteModel struct {
        ID          uint       `gorm:"primary_key;auto_increment"`
        Title       string     `gorm:"type:varchar(255);not null"`
        Notes       string     `gorm:"type:text"`
        OwnerUserID string     `gorm:"type:varchar(255);not null;index"` // Keycloak User ID
        CreatedAt   time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt   time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt   *time.Time `gorm:"index"`

        // Relacionamentos
        FilamentLines  []QuoteFilamentLineModel `gorm:"foreignkey:QuoteID"`
        MachineProfile *MachineProfileModel     `gorm:"foreignkey:QuoteID"`
        EnergyProfile  *EnergyProfileModel      `gorm:"foreignkey:QuoteID"`
        CostProfile    *CostProfileModel        `gorm:"foreignkey:QuoteID"`
        MarginProfile  *MarginProfileModel      `gorm:"foreignkey:QuoteID"`
}

// TableName especifica o nome da tabela para o GORM
func (QuoteModel) TableName() string <span class="cov0" title="0">{
        return "quotes"
}</span>

// BeforeCreate é um hook do GORM executado antes de criar um orçamento
func (q *QuoteModel) BeforeCreate(scope *gorm.Scope) error <span class="cov0" title="0">{
        q.CreatedAt = time.Now()
        q.UpdatedAt = time.Now()
        return nil
}</span>

// BeforeUpdate é um hook do GORM executado antes de atualizar um orçamento
func (q *QuoteModel) BeforeUpdate(scope *gorm.Scope) error <span class="cov0" title="0">{
        q.UpdatedAt = time.Now()
        return nil
}</span>

// QuoteFilamentLineModel representa uma linha de filamento no banco de dados
type QuoteFilamentLineModel struct {
        ID      uint `gorm:"primary_key;auto_increment"`
        QuoteID uint `gorm:"not null;index"`

        // Snapshot dos dados do filamento (para preservar histórico)
        FilamentSnapshotName          string     `gorm:"type:varchar(255);not null"`
        FilamentSnapshotBrand         string     `gorm:"type:varchar(255);not null"`
        FilamentSnapshotMaterial      string     `gorm:"type:varchar(100);not null"`
        FilamentSnapshotColor         string     `gorm:"type:varchar(100);not null"`
        FilamentSnapshotColorHex      string     `gorm:"type:varchar(7)"`
        FilamentSnapshotPricePerKg    float64    `gorm:"type:decimal(10,2);not null"`
        FilamentSnapshotPricePerMeter *float64   `gorm:"type:decimal(10,4)"`
        FilamentSnapshotURL           string     `gorm:"type:text"`
        WeightGrams                   float64    `gorm:"type:decimal(10,3);not null"`
        LengthMeters                  *float64   `gorm:"type:decimal(10,3)"`
        CreatedAt                     time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt                     time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt                     *time.Time `gorm:"index"`
}

// TableName especifica o nome da tabela para o GORM
func (QuoteFilamentLineModel) TableName() string <span class="cov0" title="0">{
        return "quote_filament_lines"
}</span>

// MachineProfileModel representa um perfil de máquina no banco de dados
type MachineProfileModel struct {
        ID          uint       `gorm:"primary_key;auto_increment"`
        QuoteID     uint       `gorm:"not null;index"`
        Name        string     `gorm:"type:varchar(255);not null"`
        Brand       string     `gorm:"type:varchar(255);not null"`
        Model       string     `gorm:"type:varchar(255);not null"`
        Watt        float64    `gorm:"type:decimal(10,2);not null"`
        IdleFactor  float64    `gorm:"type:decimal(5,4);not null;default:0"`
        Description string     `gorm:"type:text"`
        URL         string     `gorm:"type:text"`
        CreatedAt   time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt   time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt   *time.Time `gorm:"index"`
}

// TableName especifica o nome da tabela para o GORM
func (MachineProfileModel) TableName() string <span class="cov0" title="0">{
        return "machine_profiles"
}</span>

// EnergyProfileModel representa um perfil de energia no banco de dados
type EnergyProfileModel struct {
        ID            uint       `gorm:"primary_key;auto_increment"`
        QuoteID       uint       `gorm:"not null;index"`
        BaseTariff    float64    `gorm:"type:decimal(10,4);not null"`
        FlagSurcharge float64    `gorm:"type:decimal(10,4);not null;default:0"`
        Location      string     `gorm:"type:varchar(255);not null"`
        Year          int        `gorm:"not null"`
        Description   string     `gorm:"type:text"`
        CreatedAt     time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt     time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt     *time.Time `gorm:"index"`
}

// TableName especifica o nome da tabela para o GORM
func (EnergyProfileModel) TableName() string <span class="cov0" title="0">{
        return "energy_profiles"
}</span>

// CostProfileModel representa um perfil de custos no banco de dados
type CostProfileModel struct {
        ID               uint       `gorm:"primary_key;auto_increment"`
        QuoteID          uint       `gorm:"not null;index"`
        WearPercentage   float64    `gorm:"type:decimal(5,2);not null;default:0"`
        OverheadAmount   float64    `gorm:"type:decimal(10,2);not null;default:0"`
        Description      string     `gorm:"type:text"`
        CreatedAt        time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt        time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt        *time.Time `gorm:"index"`
}

// TableName especifica o nome da tabela para o GORM
func (CostProfileModel) TableName() string <span class="cov0" title="0">{
        return "cost_profiles"
}</span>

// MarginProfileModel representa um perfil de margens no banco de dados
type MarginProfileModel struct {
        ID                    uint       `gorm:"primary_key;auto_increment"`
        QuoteID               uint       `gorm:"not null;index"`
        PrintingOnlyMargin    float64    `gorm:"type:decimal(8,2);not null;default:0"`
        PrintingPlusMargin    float64    `gorm:"type:decimal(8,2);not null;default:0"`
        FullServiceMargin     float64    `gorm:"type:decimal(8,2);not null;default:0"`
        OperatorRatePerHour   float64    `gorm:"type:decimal(10,2);not null;default:0"`
        ModelerRatePerHour    float64    `gorm:"type:decimal(10,2);not null;default:0"`
        Description           string     `gorm:"type:text"`
        CreatedAt             time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt             time.Time  `gorm:"default:CURRENT_TIMESTAMP"`
        DeletedAt             *time.Time `gorm:"index"`
}

// TableName especifica o nome da tabela para o GORM
func (MarginProfileModel) TableName() string <span class="cov0" title="0">{
        return "margin_profiles"
}</pre>
		
		<pre class="file" id="file60" style="display: none">package repositories

import (
        "context"

        "github.com/RodolfoBonis/spooliq/features/quotes/data/mappers"
        "github.com/RodolfoBonis/spooliq/features/quotes/data/models"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/repositories"
        "github.com/jinzhu/gorm"
)

type quoteRepositoryImpl struct {
        db *gorm.DB
}

func NewQuoteRepository(db *gorm.DB) repositories.QuoteRepository <span class="cov0" title="0">{
        return &amp;quoteRepositoryImpl{
                db: db,
        }
}</span>

func (r *quoteRepositoryImpl) Create(ctx context.Context, quote *entities.Quote) error <span class="cov0" title="0">{
        // Convert entity to model
        model := mappers.EntityToModel(quote)

        tx := r.db.Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Create quote
        <span class="cov0" title="0">if err := tx.Create(model).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Update entity with generated ID
        <span class="cov0" title="0">quote.ID = model.ID

        // Update filament lines with quote ID and their IDs
        for i := range quote.FilamentLines </span><span class="cov0" title="0">{
                quote.FilamentLines[i].QuoteID = model.ID
                quote.FilamentLines[i].ID = model.FilamentLines[i].ID
        }</span>

        // Update profiles with quote ID and their IDs
        <span class="cov0" title="0">if quote.MachineProfile != nil &amp;&amp; model.MachineProfile != nil </span><span class="cov0" title="0">{
                quote.MachineProfile.QuoteID = model.ID
                quote.MachineProfile.ID = model.MachineProfile.ID
        }</span>
        <span class="cov0" title="0">if quote.EnergyProfile != nil &amp;&amp; model.EnergyProfile != nil </span><span class="cov0" title="0">{
                quote.EnergyProfile.QuoteID = model.ID
                quote.EnergyProfile.ID = model.EnergyProfile.ID
        }</span>
        <span class="cov0" title="0">if quote.CostProfile != nil &amp;&amp; model.CostProfile != nil </span><span class="cov0" title="0">{
                quote.CostProfile.QuoteID = model.ID
                quote.CostProfile.ID = model.CostProfile.ID
        }</span>
        <span class="cov0" title="0">if quote.MarginProfile != nil &amp;&amp; model.MarginProfile != nil </span><span class="cov0" title="0">{
                quote.MarginProfile.QuoteID = model.ID
                quote.MarginProfile.ID = model.MarginProfile.ID
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *quoteRepositoryImpl) GetByID(ctx context.Context, id uint, userID string) (*entities.Quote, error) <span class="cov0" title="0">{
        var model models.QuoteModel

        err := r.db.Preload("FilamentLines").
                Preload("MachineProfile").
                Preload("EnergyProfile").
                Preload("CostProfile").
                Preload("MarginProfile").
                Where("id = ? AND owner_user_id = ?", id, userID).
                First(&amp;model).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert model to entity
        <span class="cov0" title="0">return mappers.ModelToEntity(&amp;model), nil</span>
}

func (r *quoteRepositoryImpl) GetByUser(ctx context.Context, userID string) ([]*entities.Quote, error) <span class="cov0" title="0">{
        var models []*models.QuoteModel

        err := r.db.Preload("FilamentLines").
                Preload("MachineProfile").
                Preload("EnergyProfile").
                Preload("CostProfile").
                Preload("MarginProfile").
                Where("owner_user_id = ?", userID).
                Find(&amp;models).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert models to entities
        <span class="cov0" title="0">return mappers.ModelsToEntities(models), nil</span>
}

func (r *quoteRepositoryImpl) Update(ctx context.Context, quote *entities.Quote, userID string) error <span class="cov0" title="0">{
        // Convert entity to model
        model := mappers.EntityToModel(quote)

        tx := r.db.Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Check if user owns the quote
        <span class="cov0" title="0">var existingModel models.QuoteModel
        if err := tx.Where("id = ? AND owner_user_id = ?", model.ID, userID).First(&amp;existingModel).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Update quote
        <span class="cov0" title="0">if err := tx.Model(&amp;existingModel).Updates(model).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Delete existing filament lines and create new ones
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", model.ID).Delete(&amp;models.QuoteFilamentLineModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">for _, line := range model.FilamentLines </span><span class="cov0" title="0">{
                line.QuoteID = model.ID
                line.ID = 0 // Reset ID to create new
                if err := tx.Create(&amp;line).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        // Update or create profiles
        <span class="cov0" title="0">if model.MachineProfile != nil </span><span class="cov0" title="0">{
                model.MachineProfile.QuoteID = model.ID
                if err := tx.Where("quote_id = ?", model.ID).Assign(model.MachineProfile).FirstOrCreate(&amp;models.MachineProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">if model.EnergyProfile != nil </span><span class="cov0" title="0">{
                model.EnergyProfile.QuoteID = model.ID
                if err := tx.Where("quote_id = ?", model.ID).Assign(model.EnergyProfile).FirstOrCreate(&amp;models.EnergyProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">if model.CostProfile != nil </span><span class="cov0" title="0">{
                model.CostProfile.QuoteID = model.ID
                if err := tx.Where("quote_id = ?", model.ID).Assign(model.CostProfile).FirstOrCreate(&amp;models.CostProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">if model.MarginProfile != nil </span><span class="cov0" title="0">{
                model.MarginProfile.QuoteID = model.ID
                if err := tx.Where("quote_id = ?", model.ID).Assign(model.MarginProfile).FirstOrCreate(&amp;models.MarginProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *quoteRepositoryImpl) Delete(ctx context.Context, id uint, userID string) error <span class="cov0" title="0">{
        tx := r.db.Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Check if user owns the quote
        <span class="cov0" title="0">var model models.QuoteModel
        if err := tx.Where("id = ? AND owner_user_id = ?", id, userID).First(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Soft delete related records
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", id).Delete(&amp;models.QuoteFilamentLineModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", id).Delete(&amp;models.MachineProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", id).Delete(&amp;models.EnergyProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", id).Delete(&amp;models.CostProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if err := tx.Where("quote_id = ?", id).Delete(&amp;models.MarginProfileModel{}).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Soft delete quote
        <span class="cov0" title="0">if err := tx.Delete(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *quoteRepositoryImpl) GetWithFilamentLines(ctx context.Context, id uint, userID string) (*entities.Quote, error) <span class="cov0" title="0">{
        // This is the same as GetByID since we always preload filament lines
        return r.GetByID(ctx, id, userID)
}</pre>
		
		<pre class="file" id="file61" style="display: none">package di

import (
        calculationDI "github.com/RodolfoBonis/spooliq/features/calculation/di"
        quotesRepositories "github.com/RodolfoBonis/spooliq/features/quotes/data/repositories"
        quotesUseCases "github.com/RodolfoBonis/spooliq/features/quotes/domain/usecases"
        quotesHandlers "github.com/RodolfoBonis/spooliq/features/quotes/presentation/handlers"
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"
)

var QuotesModule = fx.Module("quotes",
        // Include calculation service
        calculationDI.Module,

        // Repositories
        fx.Provide(quotesRepositories.NewQuoteRepository),

        // Use Cases
        fx.Provide(quotesUseCases.NewQuoteUseCase),

        // Handlers
        fx.Provide(quotesHandlers.NewQuoteHandler),

        // Register routes
        fx.Invoke(RegisterQuoteRoutes),
)

func RegisterQuoteRoutes(
        handler *quotesHandlers.QuoteHandler,
        router *gin.Engine,
) <span class="cov0" title="0">{
        quotesGroup := router.Group("/v1/quotes")
        </span><span class="cov0" title="0">{
                quotesGroup.POST("", handler.CreateQuote)
                quotesGroup.GET("", handler.GetUserQuotes)
                quotesGroup.GET("/:id", handler.GetQuote)
                quotesGroup.PUT("/:id", handler.UpdateQuote)
                quotesGroup.DELETE("/:id", handler.DeleteQuote)
                quotesGroup.POST("/:id/duplicate", handler.DuplicateQuote)
                quotesGroup.POST("/:id/calculate", handler.CalculateQuote)
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package entities

import "time"

// Quote representa um orçamento de impressão 3D (Entity pura de domínio)
type Quote struct {
        ID          uint
        Title       string
        Notes       string
        OwnerUserID string
        CreatedAt   time.Time
        UpdatedAt   time.Time

        // Relacionamentos
        FilamentLines []QuoteFilamentLine
        MachineProfile *MachineProfile
        EnergyProfile  *EnergyProfile
        CostProfile    *CostProfile
        MarginProfile  *MarginProfile
}

// CanUserAccess verifica se um usuário pode acessar este orçamento (regra de negócio)
func (q *Quote) CanUserAccess(userID string, isAdmin bool) bool <span class="cov0" title="0">{
        // Admin pode acessar tudo
        if isAdmin </span><span class="cov0" title="0">{
                return true
        }</span>
        // Usuário pode acessar apenas seus próprios orçamentos
        <span class="cov0" title="0">return q.OwnerUserID == userID</span>
}

// IsValid valida se o orçamento está válido (regra de negócio)
func (q *Quote) IsValid() bool <span class="cov0" title="0">{
        if q.Title == "" || len(q.Title) &gt; 255 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if q.OwnerUserID == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if len(q.FilamentLines) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// CalculateTotalWeight calcula o peso total dos filamentos (regra de negócio)
func (q *Quote) CalculateTotalWeight() float64 <span class="cov0" title="0">{
        total := 0.0
        for _, line := range q.FilamentLines </span><span class="cov0" title="0">{
                total += line.WeightGrams
        }</span>
        <span class="cov0" title="0">return total</span>
}

// QuoteFilamentLine representa uma linha de filamento de orçamento (Entity pura)
type QuoteFilamentLine struct {
        ID      uint
        QuoteID uint

        // Snapshot dos dados do filamento (para preservar histórico)
        FilamentSnapshotName          string
        FilamentSnapshotBrand         string
        FilamentSnapshotMaterial      string
        FilamentSnapshotColor         string
        FilamentSnapshotColorHex      string
        FilamentSnapshotPricePerKg    float64
        FilamentSnapshotPricePerMeter *float64
        FilamentSnapshotURL           string
        WeightGrams                   float64
        LengthMeters                  *float64
        CreatedAt                     time.Time
        UpdatedAt                     time.Time
}

// CalculateCost calcula o custo desta linha de filamento (regra de negócio)
func (fl *QuoteFilamentLine) CalculateCost() float64 <span class="cov0" title="0">{
        // Preço por kg convertido para gramas
        pricePerGram := fl.FilamentSnapshotPricePerKg / 1000.0
        return fl.WeightGrams * pricePerGram
}</span>

// MachineProfile representa um perfil de máquina (Entity pura)
type MachineProfile struct {
        ID          uint
        QuoteID     uint
        Name        string
        Brand       string
        Model       string
        Watt        float64
        IdleFactor  float64
        Description string
        URL         string
        CreatedAt   time.Time
        UpdatedAt   time.Time
}

// CalculateEnergyConsumption calcula o consumo de energia por hora (regra de negócio)
func (mp *MachineProfile) CalculateEnergyConsumption(printTimeHours float64) float64 <span class="cov0" title="0">{
        activeTime := printTimeHours
        idleTime := printTimeHours * mp.IdleFactor
        totalTimeHours := activeTime + idleTime

        // Watts para kWh
        return (mp.Watt * totalTimeHours) / 1000.0
}</span>

// EnergyProfile representa um perfil de energia (Entity pura)
type EnergyProfile struct {
        ID            uint
        QuoteID       uint
        BaseTariff    float64
        FlagSurcharge float64
        Location      string
        Year          int
        Description   string
        CreatedAt     time.Time
        UpdatedAt     time.Time
}

// CalculateEnergyCost calcula o custo da energia (regra de negócio)
func (ep *EnergyProfile) CalculateEnergyCost(kWhConsumed float64) float64 <span class="cov0" title="0">{
        totalTariff := ep.BaseTariff + ep.FlagSurcharge
        return kWhConsumed * totalTariff
}</span>

// CostProfile representa um perfil de custos (Entity pura)
type CostProfile struct {
        ID               uint
        QuoteID          uint
        WearPercentage   float64
        OverheadAmount   float64
        Description      string
        CreatedAt        time.Time
        UpdatedAt        time.Time
}

// CalculateWearCost calcula o custo de desgaste (regra de negócio)
func (cp *CostProfile) CalculateWearCost(materialCost float64) float64 <span class="cov0" title="0">{
        return materialCost * (cp.WearPercentage / 100.0)
}</span>

// MarginProfile representa um perfil de margens (Entity pura)
type MarginProfile struct {
        ID                    uint
        QuoteID               uint
        PrintingOnlyMargin    float64
        PrintingPlusMargin    float64
        FullServiceMargin     float64
        OperatorRatePerHour   float64
        ModelerRatePerHour    float64
        Description           string
        CreatedAt             time.Time
        UpdatedAt             time.Time
}

// CalculateLaborCost calcula o custo de mão de obra (regra de negócio)
func (mp *MarginProfile) CalculateLaborCost(operatorMinutes, modelerMinutes float64) float64 <span class="cov0" title="0">{
        operatorHours := operatorMinutes / 60.0
        modelerHours := modelerMinutes / 60.0

        operatorCost := operatorHours * mp.OperatorRatePerHour
        modelerCost := modelerHours * mp.ModelerRatePerHour

        return operatorCost + modelerCost
}</span>

// GetMarginByServiceType retorna a margem baseada no tipo de serviço (regra de negócio)
func (mp *MarginProfile) GetMarginByServiceType(serviceType string) float64 <span class="cov0" title="0">{
        switch serviceType </span>{
        case "printing_only":<span class="cov0" title="0">
                return mp.PrintingOnlyMargin</span>
        case "printing_plus":<span class="cov0" title="0">
                return mp.PrintingPlusMargin</span>
        case "full_service":<span class="cov0" title="0">
                return mp.FullServiceMargin</span>
        default:<span class="cov0" title="0">
                return 0.0</span>
        }
}</pre>
		
		<pre class="file" id="file63" style="display: none">package services

import (
        "context"
        "fmt"

        filamentEntities "github.com/RodolfoBonis/spooliq/features/filaments/domain/entities"
        quotesEntities "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/quotes/presentation/dto"
)

// SnapshotService handles creation of price snapshots from current filament data
type SnapshotService interface {
        // CreateFilamentSnapshot creates a QuoteFilamentLine from a filament ID and request data
        CreateFilamentSnapshot(ctx context.Context, req *dto.CreateFilamentLineRequest, userID string) (*quotesEntities.QuoteFilamentLine, error)

        // ValidateFilamentAccess validates if a user can access a filament for snapshotting
        ValidateFilamentAccess(ctx context.Context, filamentID uint, userID string, isAdmin bool) error
}

type snapshotServiceImpl struct {
        filamentRepo FilamentRepository // We'll need to create this interface
}

// FilamentRepository defines the interface for accessing filament data
type FilamentRepository interface {
        GetByID(ctx context.Context, id uint) (*filamentEntities.Filament, error)
}

// NewSnapshotService creates a new snapshot service
func NewSnapshotService(filamentRepo FilamentRepository) SnapshotService <span class="cov0" title="0">{
        return &amp;snapshotServiceImpl{
                filamentRepo: filamentRepo,
        }
}</span>

// CreateFilamentSnapshot creates a QuoteFilamentLine from either filament ID or manual data
func (s *snapshotServiceImpl) CreateFilamentSnapshot(ctx context.Context, req *dto.CreateFilamentLineRequest, userID string) (*quotesEntities.QuoteFilamentLine, error) <span class="cov0" title="0">{
        // Validate the request first
        if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid request: %w", err)
        }</span>

        <span class="cov0" title="0">var line quotesEntities.QuoteFilamentLine

        // Set the always-required fields
        line.WeightGrams = req.WeightGrams
        line.LengthMeters = req.LengthMeters

        // Handle automatic snapshot from filament ID
        if req.FilamentID != nil </span><span class="cov0" title="0">{
                filament, err := s.filamentRepo.GetByID(ctx, *req.FilamentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get filament %d: %w", *req.FilamentID, err)
                }</span>

                // Validate user access to the filament
                // Note: We'll assume isAdmin=false for now, this should be passed from the calling service
                <span class="cov0" title="0">if !filament.CanUserAccess(userID, false) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user %s does not have access to filament %d", userID, *req.FilamentID)
                }</span>

                // Create snapshot from current filament data
                <span class="cov0" title="0">line.FilamentSnapshotName = filament.Name
                line.FilamentSnapshotBrand = filament.Brand
                line.FilamentSnapshotMaterial = filament.Material
                line.FilamentSnapshotColor = filament.Color
                line.FilamentSnapshotColorHex = filament.ColorHex
                line.FilamentSnapshotPricePerKg = filament.PricePerKg
                line.FilamentSnapshotPricePerMeter = filament.PricePerMeter
                line.FilamentSnapshotURL = filament.URL</span>
        } else<span class="cov0" title="0"> {
                // Use manual snapshot data
                line.FilamentSnapshotName = req.FilamentSnapshotName
                line.FilamentSnapshotBrand = req.FilamentSnapshotBrand
                line.FilamentSnapshotMaterial = req.FilamentSnapshotMaterial
                line.FilamentSnapshotColor = req.FilamentSnapshotColor
                line.FilamentSnapshotColorHex = req.FilamentSnapshotColorHex
                line.FilamentSnapshotPricePerKg = req.FilamentSnapshotPricePerKg
                line.FilamentSnapshotPricePerMeter = req.FilamentSnapshotPricePerMeter
                line.FilamentSnapshotURL = req.FilamentSnapshotURL
        }</span>

        <span class="cov0" title="0">return &amp;line, nil</span>
}

// ValidateFilamentAccess validates if a user can access a filament for snapshotting
func (s *snapshotServiceImpl) ValidateFilamentAccess(ctx context.Context, filamentID uint, userID string, isAdmin bool) error <span class="cov0" title="0">{
        filament, err := s.filamentRepo.GetByID(ctx, filamentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("filament not found: %w", err)
        }</span>

        <span class="cov0" title="0">if !filament.CanUserAccess(userID, isAdmin) </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied to filament %d", filamentID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file64" style="display: none">package usecases

import (
        "net/http"
        "strconv"

        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        calculationEntities "github.com/RodolfoBonis/spooliq/features/calculation/domain/entities"
        calculationServices "github.com/RodolfoBonis/spooliq/features/calculation/domain/services"
        "github.com/RodolfoBonis/spooliq/features/quotes/data/mappers"
        quotesEntities "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/repositories"
        "github.com/RodolfoBonis/spooliq/features/quotes/presentation/dto"
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

type quoteUseCaseImpl struct {
        quoteRepo          repositories.QuoteRepository
        calculationService calculationServices.CalculationService
        logger             logger.Logger
        validator          *validator.Validate
}

func NewQuoteUseCase(
        quoteRepo repositories.QuoteRepository,
        calculationService calculationServices.CalculationService,
        logger logger.Logger,
) QuoteUseCase <span class="cov0" title="0">{
        return &amp;quoteUseCaseImpl{
                quoteRepo:          quoteRepo,
                calculationService: calculationService,
                logger:             logger,
                validator:          validator.New(),
        }
}</span>

func (uc *quoteUseCaseImpl) CreateQuote(c *gin.Context) <span class="cov0" title="0">{
        var req dto.CreateQuoteRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "Formato de requisição inválido", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to bind create quote request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">if err := uc.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "Falha na validação dos dados", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Validation failed for create quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert DTO to entity (without filament lines)
        <span class="cov0" title="0">quote := mappers.CreateRequestToEntity(&amp;req, userID)

        // Process filament lines with snapshot service
        if len(req.FilamentLines) &gt; 0 </span><span class="cov0" title="0">{
                quote.FilamentLines = make([]quotesEntities.QuoteFilamentLine, 0, len(req.FilamentLines))
                for _, lineReq := range req.FilamentLines </span><span class="cov0" title="0">{
                        // Validate filament line request
                        if err := lineReq.Validate(); err != nil </span><span class="cov0" title="0">{
                                appError := errors.NewAppError(entities.ErrEntity, "Dados de linha de filamento inválidos", nil, err)
                                httpError := appError.ToHTTPError()
                                uc.logger.LogError(c.Request.Context(), "Filament line validation failed", appError)
                                c.JSON(httpError.StatusCode, httpError)
                                return
                        }</span>

                        // Create filament line with snapshot
                        <span class="cov0" title="0">var line quotesEntities.QuoteFilamentLine
                        line.WeightGrams = lineReq.WeightGrams
                        line.LengthMeters = lineReq.LengthMeters

                        // Handle automatic or manual snapshot
                        if lineReq.FilamentID != nil </span><span class="cov0" title="0">{
                                // TODO: Implement automatic snapshot from filament ID
                                // For now, we'll require manual snapshot data
                                appError := errors.NewAppError(entities.ErrEntity, "Snapshot automático ainda não implementado", nil, nil)
                                httpError := appError.ToHTTPError()
                                uc.logger.LogError(c.Request.Context(), "Automatic snapshot not implemented", appError)
                                c.JSON(httpError.StatusCode, httpError)
                                return
                        }</span> else<span class="cov0" title="0"> {
                                // Use manual snapshot data
                                line.FilamentSnapshotName = lineReq.FilamentSnapshotName
                                line.FilamentSnapshotBrand = lineReq.FilamentSnapshotBrand
                                line.FilamentSnapshotMaterial = lineReq.FilamentSnapshotMaterial
                                line.FilamentSnapshotColor = lineReq.FilamentSnapshotColor
                                line.FilamentSnapshotColorHex = lineReq.FilamentSnapshotColorHex
                                line.FilamentSnapshotPricePerKg = lineReq.FilamentSnapshotPricePerKg
                                line.FilamentSnapshotPricePerMeter = lineReq.FilamentSnapshotPricePerMeter
                                line.FilamentSnapshotURL = lineReq.FilamentSnapshotURL
                        }</span>

                        <span class="cov0" title="0">quote.FilamentLines = append(quote.FilamentLines, line)</span>
                }
        }

        // Validate business rules
        <span class="cov0" title="0">if !quote.IsValid() </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "Dados do orçamento inválidos", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Quote business validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Create quote
        <span class="cov0" title="0">if err := uc.quoteRepo.Create(c.Request.Context(), quote); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrRepository, "Erro ao criar orçamento", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to create quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response DTO
        <span class="cov0" title="0">response := dto.ToQuoteResponse(quote)

        uc.logger.Info(c.Request.Context(), "Quote created successfully", map[string]interface{}{
                "quote_id": quote.ID,
                "user_id":  userID,
        })

        c.JSON(http.StatusCreated, response)</span>
}

func (uc *quoteUseCaseImpl) GetQuote(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "ID inválido", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Invalid quote ID", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">quote, err := uc.quoteRepo.GetByID(c.Request.Context(), uint(id), userID)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrNotFound, "Orçamento não encontrado", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to get quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response DTO
        <span class="cov0" title="0">response := dto.ToQuoteResponse(quote)

        c.JSON(http.StatusOK, response)</span>
}

func (uc *quoteUseCaseImpl) GetUserQuotes(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">quotes, err := uc.quoteRepo.GetByUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrRepository, "Erro ao buscar orçamentos do usuário", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to get user quotes", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response DTOs
        <span class="cov0" title="0">responses := make([]*dto.QuoteResponse, 0, len(quotes))
        for _, quote := range quotes </span><span class="cov0" title="0">{
                responses = append(responses, dto.ToQuoteResponse(quote))
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"quotes": responses})</span>
}

func (uc *quoteUseCaseImpl) UpdateQuote(c *gin.Context) <span class="cov0" title="0">{
        // Implementation similar to CreateQuote but with update logic
        // ... (truncated for brevity)
        c.JSON(http.StatusNotImplemented, gin.H{"message": "UpdateQuote not implemented yet"})
}</span>

func (uc *quoteUseCaseImpl) DeleteQuote(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "ID inválido", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Invalid quote ID", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">if err := uc.quoteRepo.Delete(c.Request.Context(), uint(id), userID); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrRepository, "Erro ao deletar orçamento", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to delete quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">uc.logger.Info(c.Request.Context(), "Quote deleted successfully", map[string]interface{}{
                "quote_id": id,
                "user_id":  userID,
        })

        c.JSON(http.StatusNoContent, nil)</span>
}

func (uc *quoteUseCaseImpl) DuplicateQuote(c *gin.Context) <span class="cov0" title="0">{
        // Implementation for duplicating quotes
        // ... (truncated for brevity)
        c.JSON(http.StatusNotImplemented, gin.H{"message": "DuplicateQuote not implemented yet"})
}</span>

func (uc *quoteUseCaseImpl) CalculateQuote(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "ID inválido", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Invalid quote ID", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">var req dto.CalculateQuoteRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "Formato de requisição inválido", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to bind calculate request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">if err := uc.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrEntity, "Falha na validação dos dados", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Validation failed for calculate request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrUnauthorized, "Usuário não autenticado", nil, nil)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get quote with all data
        <span class="cov0" title="0">quote, err := uc.quoteRepo.GetWithFilamentLines(c.Request.Context(), uint(id), userID)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrNotFound, "Orçamento não encontrado", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to get quote for calculation", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Prepare calculation input
        <span class="cov0" title="0">calculationInput := calculationEntities.CostBreakdown{}

        // Convert filament lines to calculation entities
        for _, line := range quote.FilamentLines </span><span class="cov0" title="0">{
                filament := calculationEntities.FilamentLineInput{
                        Label:      line.FilamentSnapshotName + " " + line.FilamentSnapshotColor,
                        Grams:      line.WeightGrams,
                        PricePerKg: line.FilamentSnapshotPricePerKg,
                }
                calculationInput.Filaments = append(calculationInput.Filaments, filament)
        }</span>

        // Set machine input
        <span class="cov0" title="0">if quote.MachineProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Machine = calculationEntities.MachineInput{
                        Name:         quote.MachineProfile.Name,
                        Watt:         quote.MachineProfile.Watt,
                        IdleFactor:   quote.MachineProfile.IdleFactor,
                        HoursDecimal: req.PrintTimeHours,
                }
        }</span>

        // Set energy input
        <span class="cov0" title="0">if quote.EnergyProfile != nil </span><span class="cov0" title="0">{
                calculationInput.Energy = calculationEntities.EnergyInput{
                        BaseTariff:    quote.EnergyProfile.BaseTariff,
                        FlagSurcharge: quote.EnergyProfile.FlagSurcharge,
                }
        }</span>

        // Set cost input
        <span class="cov0" title="0">calculationInput.Costs = calculationEntities.CostInput{
                WearPct:        quote.CostProfile.WearPercentage,
                Overhead:       quote.CostProfile.OverheadAmount,
                OpRatePerHour:  quote.MarginProfile.OperatorRatePerHour,
                OpMinutes:      req.OperatorMinutes,
                CadRatePerHour: quote.MarginProfile.ModelerRatePerHour,
                CadMinutes:     req.ModelerMinutes,
        }

        // Set margin input based on service type
        appliedMargin := 0.0
        if quote.MarginProfile != nil </span><span class="cov0" title="0">{
                appliedMargin = quote.MarginProfile.GetMarginByServiceType(req.ServiceType)
        }</span>

        <span class="cov0" title="0">calculationInput.Margins = calculationEntities.MarginInput{
                OnlyPrintPct:     appliedMargin,
                LightAdjustPct:   appliedMargin,
                FullModelPct:     appliedMargin,
                ExtraCadLightMin: 0.0,
                ExtraCadFullMin:  0.0,
        }

        // Perform calculation
        result, err := uc.calculationService.Calculate(c.Request.Context(), calculationInput)
        if err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(entities.ErrService, "Erro ao calcular orçamento", nil, err)
                httpError := appError.ToHTTPError()
                uc.logger.LogError(c.Request.Context(), "Failed to calculate quote", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get margin based on service type (already calculated above)

        // Convert to response DTO
        <span class="cov0" title="0">response := dto.CalculationResult{
                MaterialCost:    result.Results.MaterialsCost,
                EnergyCost:      result.Results.EnergyCost,
                WearCost:        result.Results.WearCost,
                LaborCost:       result.Results.LaborCost,
                DirectCost:      result.Results.DirectCost,
                FinalPrice:      result.Results.DirectCost * (1 + appliedMargin/100),
                PrintTimeHours:  req.PrintTimeHours,
                OperatorMinutes: req.OperatorMinutes,
                ModelerMinutes:  req.ModelerMinutes,
                ServiceType:     req.ServiceType,
                AppliedMargin:   appliedMargin,
        }

        uc.logger.Info(c.Request.Context(), "Quote calculated successfully", map[string]interface{}{
                "quote_id":     id,
                "user_id":      userID,
                "final_price":  response.FinalPrice,
                "service_type": req.ServiceType,
        })

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package dto

import (
        "fmt"
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/entities"
)

// CreateQuoteRequest representa a requisição para criar um orçamento
type CreateQuoteRequest struct {
        Title         string                        `json:"title" validate:"required,min=1,max=255"`
        Notes         string                        `json:"notes,omitempty"`
        FilamentLines []CreateFilamentLineRequest   `json:"filament_lines" validate:"required,min=1"`
        MachineProfile *CreateMachineProfileRequest `json:"machine_profile,omitempty"`
        EnergyProfile  *CreateEnergyProfileRequest  `json:"energy_profile,omitempty"`
        CostProfile    *CreateCostProfileRequest    `json:"cost_profile,omitempty"`
        MarginProfile  *CreateMarginProfileRequest  `json:"margin_profile,omitempty"`
}

// UpdateQuoteRequest representa a requisição para atualizar um orçamento
type UpdateQuoteRequest struct {
        Title         string                        `json:"title" validate:"required,min=1,max=255"`
        Notes         string                        `json:"notes,omitempty"`
        FilamentLines []UpdateFilamentLineRequest   `json:"filament_lines" validate:"required,min=1"`
        MachineProfile *UpdateMachineProfileRequest `json:"machine_profile,omitempty"`
        EnergyProfile  *UpdateEnergyProfileRequest  `json:"energy_profile,omitempty"`
        CostProfile    *UpdateCostProfileRequest    `json:"cost_profile,omitempty"`
        MarginProfile  *UpdateMarginProfileRequest  `json:"margin_profile,omitempty"`
}

// CreateFilamentLineRequest representa a requisição para criar uma linha de filamento
// Supports both automatic snapshot (via filament_id) and manual snapshot (via filament_snapshot_* fields)
type CreateFilamentLineRequest struct {
        // Option 1: Automatic snapshot from existing filament
        FilamentID *uint `json:"filament_id,omitempty" validate:"omitempty,min=1"`

        // Option 2: Manual snapshot data (required if filament_id not provided)
        FilamentSnapshotName          string   `json:"filament_snapshot_name,omitempty"`
        FilamentSnapshotBrand         string   `json:"filament_snapshot_brand,omitempty"`
        FilamentSnapshotMaterial      string   `json:"filament_snapshot_material,omitempty"`
        FilamentSnapshotColor         string   `json:"filament_snapshot_color,omitempty"`
        FilamentSnapshotColorHex      string   `json:"filament_snapshot_color_hex,omitempty"`
        FilamentSnapshotPricePerKg    float64  `json:"filament_snapshot_price_per_kg,omitempty" validate:"omitempty,min=0"`
        FilamentSnapshotPricePerMeter *float64 `json:"filament_snapshot_price_per_meter,omitempty" validate:"omitempty,min=0"`
        FilamentSnapshotURL           string   `json:"filament_snapshot_url,omitempty"`

        // Required fields
        WeightGrams                   float64  `json:"weight_grams" validate:"required,min=0"`
        LengthMeters                  *float64 `json:"length_meters,omitempty" validate:"omitempty,min=0"`
}

// UpdateFilamentLineRequest representa a requisição para atualizar uma linha de filamento
type UpdateFilamentLineRequest struct {
        ID                            uint     `json:"id,omitempty"`
        FilamentSnapshotName          string   `json:"filament_snapshot_name" validate:"required"`
        FilamentSnapshotBrand         string   `json:"filament_snapshot_brand" validate:"required"`
        FilamentSnapshotMaterial      string   `json:"filament_snapshot_material" validate:"required"`
        FilamentSnapshotColor         string   `json:"filament_snapshot_color" validate:"required"`
        FilamentSnapshotColorHex      string   `json:"filament_snapshot_color_hex,omitempty"`
        FilamentSnapshotPricePerKg    float64  `json:"filament_snapshot_price_per_kg" validate:"required,min=0"`
        FilamentSnapshotPricePerMeter *float64 `json:"filament_snapshot_price_per_meter,omitempty" validate:"omitempty,min=0"`
        FilamentSnapshotURL           string   `json:"filament_snapshot_url,omitempty"`
        WeightGrams                   float64  `json:"weight_grams" validate:"required,min=0"`
        LengthMeters                  *float64 `json:"length_meters,omitempty" validate:"omitempty,min=0"`
}

// CreateMachineProfileRequest representa a requisição para criar um perfil de máquina
type CreateMachineProfileRequest struct {
        Name        string  `json:"name" validate:"required"`
        Brand       string  `json:"brand" validate:"required"`
        Model       string  `json:"model" validate:"required"`
        Watt        float64 `json:"watt" validate:"required,min=0"`
        IdleFactor  float64 `json:"idle_factor" validate:"min=0,max=1"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty" validate:"omitempty,url"`
}

// UpdateMachineProfileRequest representa a requisição para atualizar um perfil de máquina
type UpdateMachineProfileRequest struct {
        Name        string  `json:"name" validate:"required"`
        Brand       string  `json:"brand" validate:"required"`
        Model       string  `json:"model" validate:"required"`
        Watt        float64 `json:"watt" validate:"required,min=0"`
        IdleFactor  float64 `json:"idle_factor" validate:"min=0,max=1"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty" validate:"omitempty,url"`
}

// CreateEnergyProfileRequest representa a requisição para criar um perfil de energia
type CreateEnergyProfileRequest struct {
        BaseTariff    float64 `json:"base_tariff" validate:"required,min=0"`
        FlagSurcharge float64 `json:"flag_surcharge" validate:"min=0"`
        Location      string  `json:"location" validate:"required"`
        Year          int     `json:"year" validate:"required,min=2020,max=2030"`
        Description   string  `json:"description,omitempty"`
}

// UpdateEnergyProfileRequest representa a requisição para atualizar um perfil de energia
type UpdateEnergyProfileRequest struct {
        BaseTariff    float64 `json:"base_tariff" validate:"required,min=0"`
        FlagSurcharge float64 `json:"flag_surcharge" validate:"min=0"`
        Location      string  `json:"location" validate:"required"`
        Year          int     `json:"year" validate:"required,min=2020,max=2030"`
        Description   string  `json:"description,omitempty"`
}

// CreateCostProfileRequest representa a requisição para criar um perfil de custos
type CreateCostProfileRequest struct {
        WearPercentage float64 `json:"wear_percentage" validate:"min=0,max=100"`
        OverheadAmount float64 `json:"overhead_amount" validate:"min=0"`
        Description    string  `json:"description,omitempty"`
}

// UpdateCostProfileRequest representa a requisição para atualizar um perfil de custos
type UpdateCostProfileRequest struct {
        WearPercentage float64 `json:"wear_percentage" validate:"min=0,max=100"`
        OverheadAmount float64 `json:"overhead_amount" validate:"min=0"`
        Description    string  `json:"description,omitempty"`
}

// CreateMarginProfileRequest representa a requisição para criar um perfil de margens
type CreateMarginProfileRequest struct {
        PrintingOnlyMargin  float64 `json:"printing_only_margin" validate:"min=0"`
        PrintingPlusMargin  float64 `json:"printing_plus_margin" validate:"min=0"`
        FullServiceMargin   float64 `json:"full_service_margin" validate:"min=0"`
        OperatorRatePerHour float64 `json:"operator_rate_per_hour" validate:"min=0"`
        ModelerRatePerHour  float64 `json:"modeler_rate_per_hour" validate:"min=0"`
        Description         string  `json:"description,omitempty"`
}

// UpdateMarginProfileRequest representa a requisição para atualizar um perfil de margens
type UpdateMarginProfileRequest struct {
        PrintingOnlyMargin  float64 `json:"printing_only_margin" validate:"min=0"`
        PrintingPlusMargin  float64 `json:"printing_plus_margin" validate:"min=0"`
        FullServiceMargin   float64 `json:"full_service_margin" validate:"min=0"`
        OperatorRatePerHour float64 `json:"operator_rate_per_hour" validate:"min=0"`
        ModelerRatePerHour  float64 `json:"modeler_rate_per_hour" validate:"min=0"`
        Description         string  `json:"description,omitempty"`
}

// CalculateQuoteRequest representa a requisição para calcular um orçamento
type CalculateQuoteRequest struct {
        PrintTimeHours  float64 `json:"print_time_hours" validate:"required,min=0"`
        OperatorMinutes float64 `json:"operator_minutes" validate:"min=0"`
        ModelerMinutes  float64 `json:"modeler_minutes" validate:"min=0"`
        ServiceType     string  `json:"service_type" validate:"required,oneof=printing_only printing_plus full_service"`
}

// QuoteResponse representa a resposta de um orçamento
type QuoteResponse struct {
        ID            uint                      `json:"id"`
        Title         string                    `json:"title"`
        Notes         string                    `json:"notes,omitempty"`
        OwnerUserID   string                    `json:"owner_user_id"`
        CreatedAt     string                    `json:"created_at"`
        UpdatedAt     string                    `json:"updated_at"`
        FilamentLines []FilamentLineResponse    `json:"filament_lines,omitempty"`
        MachineProfile *MachineProfileResponse  `json:"machine_profile,omitempty"`
        EnergyProfile  *EnergyProfileResponse   `json:"energy_profile,omitempty"`
        CostProfile    *CostProfileResponse     `json:"cost_profile,omitempty"`
        MarginProfile  *MarginProfileResponse   `json:"margin_profile,omitempty"`
}

// FilamentLineResponse representa a resposta de uma linha de filamento
type FilamentLineResponse struct {
        ID                            uint     `json:"id"`
        QuoteID                       uint     `json:"quote_id"`
        FilamentSnapshotName          string   `json:"filament_snapshot_name"`
        FilamentSnapshotBrand         string   `json:"filament_snapshot_brand"`
        FilamentSnapshotMaterial      string   `json:"filament_snapshot_material"`
        FilamentSnapshotColor         string   `json:"filament_snapshot_color"`
        FilamentSnapshotColorHex      string   `json:"filament_snapshot_color_hex,omitempty"`
        FilamentSnapshotPricePerKg    float64  `json:"filament_snapshot_price_per_kg"`
        FilamentSnapshotPricePerMeter *float64 `json:"filament_snapshot_price_per_meter,omitempty"`
        FilamentSnapshotURL           string   `json:"filament_snapshot_url,omitempty"`
        WeightGrams                   float64  `json:"weight_grams"`
        LengthMeters                  *float64 `json:"length_meters,omitempty"`
        CreatedAt                     string   `json:"created_at"`
        UpdatedAt                     string   `json:"updated_at"`
}

// MachineProfileResponse representa a resposta de um perfil de máquina
type MachineProfileResponse struct {
        ID          uint    `json:"id"`
        QuoteID     uint    `json:"quote_id"`
        Name        string  `json:"name"`
        Brand       string  `json:"brand"`
        Model       string  `json:"model"`
        Watt        float64 `json:"watt"`
        IdleFactor  float64 `json:"idle_factor"`
        Description string  `json:"description,omitempty"`
        URL         string  `json:"url,omitempty"`
        CreatedAt   string  `json:"created_at"`
        UpdatedAt   string  `json:"updated_at"`
}

// EnergyProfileResponse representa a resposta de um perfil de energia
type EnergyProfileResponse struct {
        ID            uint    `json:"id"`
        QuoteID       uint    `json:"quote_id"`
        BaseTariff    float64 `json:"base_tariff"`
        FlagSurcharge float64 `json:"flag_surcharge"`
        Location      string  `json:"location"`
        Year          int     `json:"year"`
        Description   string  `json:"description,omitempty"`
        CreatedAt     string  `json:"created_at"`
        UpdatedAt     string  `json:"updated_at"`
}

// CostProfileResponse representa a resposta de um perfil de custos
type CostProfileResponse struct {
        ID             uint    `json:"id"`
        QuoteID        uint    `json:"quote_id"`
        WearPercentage float64 `json:"wear_percentage"`
        OverheadAmount float64 `json:"overhead_amount"`
        Description    string  `json:"description,omitempty"`
        CreatedAt      string  `json:"created_at"`
        UpdatedAt      string  `json:"updated_at"`
}

// MarginProfileResponse representa a resposta de um perfil de margens
type MarginProfileResponse struct {
        ID                  uint    `json:"id"`
        QuoteID             uint    `json:"quote_id"`
        PrintingOnlyMargin  float64 `json:"printing_only_margin"`
        PrintingPlusMargin  float64 `json:"printing_plus_margin"`
        FullServiceMargin   float64 `json:"full_service_margin"`
        OperatorRatePerHour float64 `json:"operator_rate_per_hour"`
        ModelerRatePerHour  float64 `json:"modeler_rate_per_hour"`
        Description         string  `json:"description,omitempty"`
        CreatedAt           string  `json:"created_at"`
        UpdatedAt           string  `json:"updated_at"`
}

// CalculationResult representa o resultado de um cálculo de orçamento
type CalculationResult struct {
        MaterialCost    float64 `json:"material_cost"`
        EnergyCost      float64 `json:"energy_cost"`
        WearCost        float64 `json:"wear_cost"`
        LaborCost       float64 `json:"labor_cost"`
        DirectCost      float64 `json:"direct_cost"`
        FinalPrice      float64 `json:"final_price"`
        PrintTimeHours  float64 `json:"print_time_hours"`
        OperatorMinutes float64 `json:"operator_minutes"`
        ModelerMinutes  float64 `json:"modeler_minutes"`
        ServiceType     string  `json:"service_type"`
        AppliedMargin   float64 `json:"applied_margin"`
}

// ToQuoteResponse converte uma entidade Quote para QuoteResponse
func ToQuoteResponse(quote *entities.Quote) *QuoteResponse <span class="cov0" title="0">{
        response := &amp;QuoteResponse{
                ID:          quote.ID,
                Title:       quote.Title,
                Notes:       quote.Notes,
                OwnerUserID: quote.OwnerUserID,
                CreatedAt:   quote.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:   quote.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        // Convert filament lines
        if len(quote.FilamentLines) &gt; 0 </span><span class="cov0" title="0">{
                response.FilamentLines = make([]FilamentLineResponse, 0, len(quote.FilamentLines))
                for _, line := range quote.FilamentLines </span><span class="cov0" title="0">{
                        response.FilamentLines = append(response.FilamentLines, FilamentLineResponse{
                                ID:                            line.ID,
                                QuoteID:                       line.QuoteID,
                                FilamentSnapshotName:          line.FilamentSnapshotName,
                                FilamentSnapshotBrand:         line.FilamentSnapshotBrand,
                                FilamentSnapshotMaterial:      line.FilamentSnapshotMaterial,
                                FilamentSnapshotColor:         line.FilamentSnapshotColor,
                                FilamentSnapshotColorHex:      line.FilamentSnapshotColorHex,
                                FilamentSnapshotPricePerKg:    line.FilamentSnapshotPricePerKg,
                                FilamentSnapshotPricePerMeter: line.FilamentSnapshotPricePerMeter,
                                FilamentSnapshotURL:           line.FilamentSnapshotURL,
                                WeightGrams:                   line.WeightGrams,
                                LengthMeters:                  line.LengthMeters,
                                CreatedAt:                     line.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                                UpdatedAt:                     line.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        })
                }</span>
        }

        // Convert profiles
        <span class="cov0" title="0">if quote.MachineProfile != nil </span><span class="cov0" title="0">{
                response.MachineProfile = &amp;MachineProfileResponse{
                        ID:          quote.MachineProfile.ID,
                        QuoteID:     quote.MachineProfile.QuoteID,
                        Name:        quote.MachineProfile.Name,
                        Brand:       quote.MachineProfile.Brand,
                        Model:       quote.MachineProfile.Model,
                        Watt:        quote.MachineProfile.Watt,
                        IdleFactor:  quote.MachineProfile.IdleFactor,
                        Description: quote.MachineProfile.Description,
                        URL:         quote.MachineProfile.URL,
                        CreatedAt:   quote.MachineProfile.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        UpdatedAt:   quote.MachineProfile.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov0" title="0">if quote.EnergyProfile != nil </span><span class="cov0" title="0">{
                response.EnergyProfile = &amp;EnergyProfileResponse{
                        ID:            quote.EnergyProfile.ID,
                        QuoteID:       quote.EnergyProfile.QuoteID,
                        BaseTariff:    quote.EnergyProfile.BaseTariff,
                        FlagSurcharge: quote.EnergyProfile.FlagSurcharge,
                        Location:      quote.EnergyProfile.Location,
                        Year:          quote.EnergyProfile.Year,
                        Description:   quote.EnergyProfile.Description,
                        CreatedAt:     quote.EnergyProfile.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        UpdatedAt:     quote.EnergyProfile.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov0" title="0">if quote.CostProfile != nil </span><span class="cov0" title="0">{
                response.CostProfile = &amp;CostProfileResponse{
                        ID:             quote.CostProfile.ID,
                        QuoteID:        quote.CostProfile.QuoteID,
                        WearPercentage: quote.CostProfile.WearPercentage,
                        OverheadAmount: quote.CostProfile.OverheadAmount,
                        Description:    quote.CostProfile.Description,
                        CreatedAt:      quote.CostProfile.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        UpdatedAt:      quote.CostProfile.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov0" title="0">if quote.MarginProfile != nil </span><span class="cov0" title="0">{
                response.MarginProfile = &amp;MarginProfileResponse{
                        ID:                  quote.MarginProfile.ID,
                        QuoteID:             quote.MarginProfile.QuoteID,
                        PrintingOnlyMargin:  quote.MarginProfile.PrintingOnlyMargin,
                        PrintingPlusMargin:  quote.MarginProfile.PrintingPlusMargin,
                        FullServiceMargin:   quote.MarginProfile.FullServiceMargin,
                        OperatorRatePerHour: quote.MarginProfile.OperatorRatePerHour,
                        ModelerRatePerHour:  quote.MarginProfile.ModelerRatePerHour,
                        Description:         quote.MarginProfile.Description,
                        CreatedAt:           quote.MarginProfile.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        UpdatedAt:           quote.MarginProfile.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        <span class="cov0" title="0">return response</span>
}

// Validate validates the CreateFilamentLineRequest ensuring either FilamentID or manual snapshot data is provided
func (req *CreateFilamentLineRequest) Validate() error <span class="cov0" title="0">{
        // Either filament_id OR manual snapshot data must be provided
        if req.FilamentID != nil </span><span class="cov0" title="0">{
                // If filament_id is provided, it should be valid
                if *req.FilamentID == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("filament_id must be greater than 0")
                }</span>
                // Manual snapshot data is not required when filament_id is provided
                <span class="cov0" title="0">return nil</span>
        }

        // If filament_id is not provided, manual snapshot data is required
        <span class="cov0" title="0">if req.FilamentSnapshotName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("filament_snapshot_name is required when filament_id is not provided")
        }</span>
        <span class="cov0" title="0">if req.FilamentSnapshotBrand == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("filament_snapshot_brand is required when filament_id is not provided")
        }</span>
        <span class="cov0" title="0">if req.FilamentSnapshotMaterial == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("filament_snapshot_material is required when filament_id is not provided")
        }</span>
        <span class="cov0" title="0">if req.FilamentSnapshotColor == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("filament_snapshot_color is required when filament_id is not provided")
        }</span>
        <span class="cov0" title="0">if req.FilamentSnapshotPricePerKg &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("filament_snapshot_price_per_kg must be greater than 0 when filament_id is not provided")
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file66" style="display: none">package handlers

import (
        "github.com/RodolfoBonis/spooliq/features/quotes/domain/usecases"
        "github.com/gin-gonic/gin"
)

type QuoteHandler struct {
        quoteUseCase usecases.QuoteUseCase
}

func NewQuoteHandler(quoteUseCase usecases.QuoteUseCase) *QuoteHandler <span class="cov0" title="0">{
        return &amp;QuoteHandler{
                quoteUseCase: quoteUseCase,
        }
}</span>

// CreateQuote godoc
// @Summary Create a new quote
// @Description Create a new quote with filament lines and profiles
// @Tags quotes
// @Accept json
// @Produce json
// @Param quote body usecases.CreateQuoteRequest true "Quote data"
// @Success 201 {object} usecases.QuoteResponse
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes [post]
// @Security BearerAuth
func (h *QuoteHandler) CreateQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.CreateQuote(c)
}</span>

// GetQuote godoc
// @Summary Get a quote by ID
// @Description Get a quote by ID with all its filament lines and profiles
// @Tags quotes
// @Produce json
// @Param id path int true "Quote ID"
// @Success 200 {object} usecases.QuoteResponse
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /v1/quotes/{id} [get]
// @Security BearerAuth
func (h *QuoteHandler) GetQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.GetQuote(c)
}</span>

// GetUserQuotes godoc
// @Summary Get all quotes for the authenticated user
// @Description Get all quotes belonging to the authenticated user
// @Tags quotes
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes [get]
// @Security BearerAuth
func (h *QuoteHandler) GetUserQuotes(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.GetUserQuotes(c)
}</span>

// UpdateQuote godoc
// @Summary Update a quote
// @Description Update a quote with new data
// @Tags quotes
// @Accept json
// @Produce json
// @Param id path int true "Quote ID"
// @Param quote body usecases.UpdateQuoteRequest true "Quote data"
// @Success 200 {object} usecases.QuoteResponse
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes/{id} [put]
// @Security BearerAuth
func (h *QuoteHandler) UpdateQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.UpdateQuote(c)
}</span>

// DeleteQuote godoc
// @Summary Delete a quote
// @Description Delete a quote and all its related data
// @Tags quotes
// @Param id path int true "Quote ID"
// @Success 204
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes/{id} [delete]
// @Security BearerAuth
func (h *QuoteHandler) DeleteQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.DeleteQuote(c)
}</span>

// DuplicateQuote godoc
// @Summary Duplicate a quote
// @Description Create a copy of an existing quote
// @Tags quotes
// @Produce json
// @Param id path int true "Quote ID"
// @Success 201 {object} usecases.QuoteResponse
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes/{id}/duplicate [post]
// @Security BearerAuth
func (h *QuoteHandler) DuplicateQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.DuplicateQuote(c)
}</span>

// CalculateQuote godoc
// @Summary Calculate quote costs
// @Description Calculate all costs for a quote based on provided parameters
// @Tags quotes
// @Accept json
// @Produce json
// @Param id path int true "Quote ID"
// @Param calculation body usecases.CalculateQuoteRequest true "Calculation parameters"
// @Success 200 {object} usecases.CalculationResult
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /v1/quotes/{id}/calculate [post]
// @Security BearerAuth
func (h *QuoteHandler) CalculateQuote(c *gin.Context) <span class="cov0" title="0">{
        h.quoteUseCase.CalculateQuote(c)
}</pre>
		
		<pre class="file" id="file67" style="display: none">package gpu

import (
        "context"
        "os/exec"
        "strings"

        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
)

// LinuxDetector provides GPU detection for Linux systems.
type LinuxDetector struct {
        logger logger.Logger
}

// NewLinuxDetector creates a new LinuxDetector instance.
func NewLinuxDetector(logger logger.Logger) Detector <span class="cov0" title="0">{
        return &amp;LinuxDetector{logger: logger}
}</span>

// GetGPUInfo retrieves GPU information on Linux systems.
func (d *LinuxDetector) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        cmd := exec.Command("lspci", "-v")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.ServiceError(err.Error(), map[string]interface{}{"cmd": "lspci -v"})
                d.logger.LogError(context.Background(), "Failed to execute lspci", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">outputStr := string(output)
        lines := strings.Split(outputStr, "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(line), "vga compatible controller") ||
                        strings.Contains(strings.ToLower(line), "3d controller") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, ": ")
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                model := strings.TrimSpace(parts[1])

                                memory := d.getLinuxGPUMemory(model)

                                return entities.GPU{
                                        Model:     model,
                                        Memory:    memory,
                                        Available: true,
                                }, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return entities.GPU{}, errors.ServiceError("No GPU found on Linux")</span>
}

func (d *LinuxDetector) getLinuxGPUMemory(model string) string <span class="cov0" title="0">{
        if strings.Contains(strings.ToLower(model), "amd") </span><span class="cov0" title="0">{
                if cmd := exec.Command("rocm-smi", "--showmeminfo"); cmd != nil </span><span class="cov0" title="0">{
                        output, err := cmd.Output()
                        if err == nil </span><span class="cov0" title="0">{
                                return d.parseAMDMemoryOutput(string(output))
                        }</span>
                        <span class="cov0" title="0">appErr := errors.ServiceError(err.Error(), map[string]interface{}{"cmd": "rocm-smi --showmeminfo"})
                        d.logger.LogError(context.Background(), "Failed to execute rocm-smi", appErr)</span>
                }
        }

        <span class="cov0" title="0">return "Memory info unavailable"</span>
}

func (d *LinuxDetector) parseAMDMemoryOutput(output string) string <span class="cov0" title="0">{
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "Total") &amp;&amp; strings.Contains(line, "MB") </span><span class="cov0" title="0">{
                        return strings.TrimSpace(line)
                }</span>
        }
        <span class="cov0" title="0">return "AMD GPU detected - Memory info unavailable"</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package gpu

import (
        "context"
        "encoding/json"
        "fmt"
        "os/exec"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
        "github.com/shirou/gopsutil/v3/mem"
)

// MacOSDetector provides GPU detection for macOS systems.
type MacOSDetector struct {
        logger logger.Logger
}

// NewMacOSDetector creates a new MacOSDetector instance.
func NewMacOSDetector(logger logger.Logger) Detector <span class="cov0" title="0">{
        return &amp;MacOSDetector{logger: logger}
}</span>

// GetGPUInfo retrieves GPU information on macOS systems.
func (d *MacOSDetector) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        d.logger.Info(context.Background(), "Entrou no MacOSDetector.GetGPUInfo")
        cmd := exec.Command("system_profiler", "SPDisplaysDataType", "-json")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"cmd": "system_profiler SPDisplaysDataType -json"}, err)
                d.logger.LogError(context.Background(), "Failed to execute system_profiler", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">var displays map[string]interface{}
        if err := json.Unmarshal(output, &amp;displays); err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"cmd": "system_profiler output unmarshal", "raw": string(output)}, err)
                d.logger.LogError(context.Background(), "Failed to unmarshal system_profiler output", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">if items, ok := displays["SPDisplaysDataType"].([]interface{}); ok &amp;&amp; len(items) &gt; 0 </span><span class="cov0" title="0">{
                if gpu, ok := items[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        model := "Unknown GPU"
                        memory := "N/A"
                        cores := 0

                        if name, ok := gpu["sppci_model"].(string); ok </span><span class="cov0" title="0">{
                                model = name
                        }</span> else<span class="cov0" title="0"> if name, ok := gpu["_name"].(string); ok </span><span class="cov0" title="0">{
                                model = name
                        }</span>

                        <span class="cov0" title="0">if c, ok := gpu["sppci_cores"].(string); ok </span><span class="cov0" title="0">{
                                fmt.Sscanf(c, "%d", &amp;cores)
                        }</span>

                        <span class="cov0" title="0">if vm, err := mem.VirtualMemory(); err == nil </span><span class="cov0" title="0">{
                                memory = fmt.Sprintf("%.2f GB (Shared)", float64(vm.Total)/(1024*1024*1024))
                        }</span>

                        <span class="cov0" title="0">d.logger.Info(context.Background(), "GPU info detected", map[string]interface{}{"model": model, "memory": memory})
                        return entities.GPU{
                                Model:     model,
                                Memory:    memory,
                                Available: true,
                                Cores:     cores,
                        }, nil</span>
                }
        }
        <span class="cov0" title="0">d.logger.Info(context.Background(), "No GPU found on MacOS after parsing")
        return entities.GPU{}, errors.NewAppError(coreEntities.ErrService, "No GPU found on MacOS", nil, nil)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package gpu

import (
        "context"
        "fmt"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
        "github.com/mindprince/gonvml"
)

// NvidiaDetector provides GPU detection for NVIDIA GPUs.
type NvidiaDetector struct {
        logger logger.Logger
}

// NewNvidiaDetector creates a new NvidiaDetector instance.
func NewNvidiaDetector(logger logger.Logger) Detector <span class="cov0" title="0">{
        return &amp;NvidiaDetector{logger: logger}
}</span>

// GetGPUInfo retrieves GPU information for NVIDIA GPUs.
func (d *NvidiaDetector) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        if err := gonvml.Initialize(); err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"step": "NVML Initialize"}, err)
                d.logger.LogError(context.Background(), "Failed to initialize NVML", appErr)
                return entities.GPU{}, appErr
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := gonvml.Shutdown()
                if err != nil </span><span class="cov0" title="0">{
                        appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"step": "NVML Shutdown"}, err)
                        d.logger.LogError(context.Background(), "Error shutting down NVML", appErr)
                }</span>
        }()

        <span class="cov0" title="0">count, err := gonvml.DeviceCount()
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, "Nenhuma GPU NVIDIA encontrada ou erro ao obter contagem", map[string]interface{}{"error": err}, err)
                d.logger.LogError(context.Background(), "Failed to get NVIDIA device count", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">device, err := gonvml.DeviceHandleByIndex(0)
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"step": "DeviceHandleByIndex"}, err)
                d.logger.LogError(context.Background(), "Failed to get NVIDIA device handle", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">name, err := device.Name()
        if err != nil </span><span class="cov0" title="0">{
                name = "GPU NVIDIA (Modelo Desconhecido)"
        }</span>

        <span class="cov0" title="0">total, used, err := device.MemoryInfo()
        var memoryStr string
        if err != nil </span><span class="cov0" title="0">{
                memoryStr = "Informações de memória indisponíveis"
                appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"step": "MemoryInfo"}, err)
                d.logger.LogError(context.Background(), "Failed to get NVIDIA memory info", appErr)
        }</span> else<span class="cov0" title="0"> {
                totalMemoryGB := float64(total) / (1024 * 1024 * 1024)
                usedMemoryGB := float64(used) / (1024 * 1024 * 1024)
                memoryStr = fmt.Sprintf("%.2f GB / %.2f GB", usedMemoryGB, totalMemoryGB)
        }</span>

        <span class="cov0" title="0">return entities.GPU{
                Model:     name,
                Memory:    memoryStr,
                Available: true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package gpu

import (
        "runtime"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
)

// Service provides GPU service operations.
type Service interface {
        GetGPUInfo() (entities.GPU, *errors.AppError)
}

type service struct {
        detectors []Detector
}

// NewService creates a new Service instance.
func NewService(logger logger.Logger) Service <span class="cov0" title="0">{
        var detectors []Detector

        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                detectors = append(detectors, NewMacOSDetector(logger))</span>
        case "linux":<span class="cov0" title="0">
                detectors = append(detectors, NewNvidiaDetector(logger))
                detectors = append(detectors, NewLinuxDetector(logger))</span>
        case "windows":<span class="cov0" title="0">
                detectors = append(detectors, NewNvidiaDetector(logger))
                detectors = append(detectors, NewWindowsDetector(logger))</span>
        }

        <span class="cov0" title="0">return &amp;service{detectors: detectors}</span>
}

func (s *service) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        for _, detector := range s.detectors </span><span class="cov0" title="0">{
                gpuInfo, err := detector.GetGPUInfo()
                if err == nil </span><span class="cov0" title="0">{
                        return gpuInfo, nil
                }</span>
        }
        <span class="cov0" title="0">return entities.GPU{}, errors.NewAppError(coreEntities.ErrService, "No GPU detected", nil, nil)</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package gpu

import (
        "context"
        "fmt"
        "os/exec"
        "strconv"
        "strings"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
)

// WindowsDetector provides GPU detection for Windows systems.
type WindowsDetector struct {
        logger logger.Logger
}

// NewWindowsDetector creates a new WindowsDetector instance.
func NewWindowsDetector(logger logger.Logger) Detector <span class="cov0" title="0">{
        return &amp;WindowsDetector{logger: logger}
}</span>

// GetGPUInfo retrieves GPU information on Windows systems.
func (d *WindowsDetector) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        cmd := exec.Command("wmic", "path", "win32_VideoController", "get", "name,AdapterRAM", "/format:csv")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                appErr := errors.NewAppError(coreEntities.ErrService, "Failed to execute wmic", map[string]interface{}{"cmd": "wmic path win32_VideoController get name,AdapterRAM /format:csv"}, err)
                d.logger.LogError(context.Background(), "Failed to execute wmic", appErr)
                return entities.GPU{}, appErr
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, ",") &amp;&amp; !strings.Contains(line, "Node") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, ",")
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                name := strings.TrimSpace(parts[2])
                                ramStr := strings.TrimSpace(parts[1])

                                if name != "" &amp;&amp; name != "Name" </span><span class="cov0" title="0">{
                                        memory := "N/A"
                                        if ramStr != "" &amp;&amp; ramStr != "AdapterRAM" </span><span class="cov0" title="0">{
                                                if ram, err := strconv.ParseInt(ramStr, 10, 64); err == nil &amp;&amp; ram &gt; 0 </span><span class="cov0" title="0">{
                                                        memory = fmt.Sprintf("%.2f GB", float64(ram)/(1024*1024*1024))
                                                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                                        appErr := errors.NewAppError(coreEntities.ErrService, err.Error(), map[string]interface{}{"ramStr": ramStr}, err)
                                                        d.logger.LogError(context.Background(), "Failed to parse AdapterRAM", appErr)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">return entities.GPU{
                                                Model:     name,
                                                Memory:    memory,
                                                Available: true,
                                        }, nil</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return entities.GPU{}, errors.NewAppError(coreEntities.ErrService, "No GPU found on Windows", nil, nil)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package services

import (
        "fmt"
        "os"
        "strings"

        "github.com/RodolfoBonis/spooliq/core/config"
        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/features/system/data/services/gpu"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/disk"
        "github.com/shirou/gopsutil/v3/host"
        "github.com/shirou/gopsutil/v3/mem"
)

// SystemService provides system-related services.
type SystemService interface {
        GetCPUInfo() (entities.CPU, *errors.AppError)
        GetMemoryInfo() (entities.Memory, *errors.AppError)
        GetStorageInfo() (entities.Storage, *errors.AppError)
        GetGPUInfo() (entities.GPU, *errors.AppError)
        GetHostInfo() (string, *errors.AppError)
        GetServerInfo() (entities.Server, *errors.AppError)
}

type systemService struct {
        gpuService gpu.Service
}

// NewSystemService creates a new SystemService instance.
func NewSystemService(gpuService gpu.Service) SystemService <span class="cov0" title="0">{
        return &amp;systemService{
                gpuService: gpuService,
        }
}</span>

func (s *systemService) GetCPUInfo() (entities.CPU, *errors.AppError) <span class="cov0" title="0">{
        infos, err := cpu.Info()

        if err != nil </span><span class="cov0" title="0">{
                return entities.CPU{}, errors.NewAppError(coreEntities.ErrService, err.Error(), nil, err)
        }</span>

        <span class="cov0" title="0">if len(infos) == 0 </span><span class="cov0" title="0">{
                return entities.CPU{}, errors.NewAppError(coreEntities.ErrService, "no CPU information available", nil, nil)
        }</span>

        <span class="cov0" title="0">cpuInfo := infos[0]

        percent, _ := cpu.Percent(0, false)
        return entities.CPU{
                Model: cpuInfo.ModelName,
                Cores: cpuInfo.Cores,
                Usage: fmt.Sprintf("%.2f%%", percent[0]),
        }, nil</span>
}

func (s *systemService) GetMemoryInfo() (entities.Memory, *errors.AppError) <span class="cov0" title="0">{
        memInfo, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return entities.Memory{}, errors.NewAppError(coreEntities.ErrService, err.Error(), nil, err)
        }</span>

        <span class="cov0" title="0">return entities.Memory{
                Total:      fmt.Sprintf("%.2f GB", float64(memInfo.Total)/(1024*1024*1024)),
                Available:  fmt.Sprintf("%.2f GB", float64(memInfo.Available)/(1024*1024*1024)),
                Used:       fmt.Sprintf("%.2f GB", float64(memInfo.Used)/(1024*1024*1024)),
                Percentage: fmt.Sprintf("%.2f%%", memInfo.UsedPercent),
        }, nil</span>
}

func (s *systemService) GetStorageInfo() (entities.Storage, *errors.AppError) <span class="cov0" title="0">{
        partitions, err := disk.Partitions(false)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Storage{}, errors.NewAppError(coreEntities.ErrService, err.Error(), nil, err)
        }</span>

        <span class="cov0" title="0">var totalUsed, totalTotal uint64
        partition := partitions[0]
        usage, _ := disk.Usage(partition.Mountpoint)

        totalUsed += usage.Used
        totalTotal += usage.Total

        var usagePercentage float64
        if totalTotal &gt; 0 </span><span class="cov0" title="0">{
                usagePercentage = float64(totalUsed) / float64(totalTotal) * 100
        }</span>

        <span class="cov0" title="0">return entities.Storage{
                Used:       fmt.Sprintf("%v GB", totalUsed/(1024*1024*1024)),
                Total:      fmt.Sprintf("%v GB", totalTotal/(1024*1024*1024)),
                Percentage: fmt.Sprintf("%.2f%%", usagePercentage),
        }, nil</span>
}

func (s *systemService) GetHostInfo() (string, *errors.AppError) <span class="cov0" title="0">{
        info, err := host.Info()

        if err != nil </span><span class="cov0" title="0">{
                return "", errors.NewAppError(coreEntities.ErrService, err.Error(), nil, err)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Platform: %s %s (%s)",
                info.Platform,
                info.PlatformVersion,
                info.PlatformFamily,
        ), nil</span>
}

func (s *systemService) GetGPUInfo() (entities.GPU, *errors.AppError) <span class="cov0" title="0">{
        gpuInfo, err := s.gpuService.GetGPUInfo()
        if err == nil </span><span class="cov0" title="0">{
                return gpuInfo, nil
        }</span>
        <span class="cov0" title="0">return entities.GPU{
                Model:     "No dedicated GPU detected",
                Memory:    "N/A",
                Available: false,
        }, nil</span>
}

func (s *systemService) GetServerInfo() (entities.Server, *errors.AppError) <span class="cov0" title="0">{
        versionFileName := "version.txt"
        if config.EnvironmentConfig() == coreEntities.Environment.Production </span><span class="cov0" title="0">{
                versionFileName = "/version.txt"
        }</span>
        <span class="cov0" title="0">version := "unknown"
        if content, err := os.ReadFile(versionFileName); err == nil </span><span class="cov0" title="0">{
                version = strings.TrimSpace(string(content))
        }</span>
        <span class="cov0" title="0">return entities.Server{
                Version: version,
                Active:  true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package di

import (
        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/data/services"
        gpuService "github.com/RodolfoBonis/spooliq/features/system/data/services/gpu"
        "github.com/RodolfoBonis/spooliq/features/system/domain/usecases"
        "go.uber.org/fx"
)

// SystemModule provides the fx module for system dependencies.
var SystemModule = fx.Module("system",
        fx.Provide(
                func(logger logger.Logger, cfg *config.AppConfig) usecases.SystemUseCase <span class="cov0" title="0">{
                        gpu := gpuService.NewService(logger)
                        service := services.NewSystemService(gpu)
                        return usecases.NewSystemUseCase(service, logger)
                }</span>,
        ),
)
</pre>
		
		<pre class="file" id="file74" style="display: none">package usecases

import (
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/domain/entities"
        "github.com/gin-gonic/gin"
)

// GetSystemStatus returns the current system status, including OS, CPU, memory, GPU, storage, and server info.
// @Summary Get System Status
// @Schemes
// @Description Returns the current system status (OS, CPU, memory, GPU, storage, server)
// @Tags System
// @Accept json
// @Produce json
// @Success 200 {object} entities.SystemStatus "System status info"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /system/ [get]
// @Example response {
//   "OS": "Darwin",
//   "CPU": {"Model": "Intel(R) Core(TM) i7", "Cores": 8, "Threads": 16, "Usage": "15%"},
//   "Memory": {"Total": "16GB", "Available": "8GB", "Used": "8GB", "Percentage": "50%"},
//   "GPU": {"Model": "AMD Radeon Pro", "Memory": "4GB", "Available": true},
//   "Storage": {"Used": "200GB", "Total": "500GB", "Percentage": "40%"},
//   "Server": {"Version": "1.0.0", "Active": true}
// }

func (uc *systemUseCaseImpl) GetSystemStatus(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()
        uc.Logger.Info(ctx, "System status requested", logger.Fields{
                "ip":         c.ClientIP(),
                "user_agent": c.Request.UserAgent(),
        })
        systemStatus := entities.SystemStatus{}

        cpu, appError := uc.Service.GetCPUInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get CPU info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">memory, appError := uc.Service.GetMemoryInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get memory info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">storage, appError := uc.Service.GetStorageInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get storage info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">hostInfo, appError := uc.Service.GetHostInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get host info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">gpuInfo, appError := uc.Service.GetGPUInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get GPU info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">serverInfo, appError := uc.Service.GetServerInfo()
        if appError != nil </span><span class="cov0" title="0">{
                httpError := appError.ToHTTPError()
                uc.Logger.LogError(ctx, "Failed to get server info", appError)
                c.JSON(httpError.StatusCode, httpError.ToMap())
                return
        }</span>

        <span class="cov0" title="0">systemStatus.OS = hostInfo
        systemStatus.CPU = cpu
        systemStatus.Memory = memory
        systemStatus.Storage = storage
        systemStatus.GPU = gpuInfo
        systemStatus.Server = serverInfo

        uc.Logger.Info(ctx, "System status returned", logger.Fields{
                "ip": c.ClientIP(),
        })
        c.JSON(200, systemStatus)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package usecases

import (
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/system/data/services"
        "github.com/gin-gonic/gin"
)

// SystemUseCase define os casos de uso do domínio de sistema.
type SystemUseCase interface {
        // GetSystemStatus retorna o status do sistema.
        GetSystemStatus(c *gin.Context)
}

// systemUseCaseImpl é a implementação de SystemUseCase.
type systemUseCaseImpl struct {
        Service services.SystemService
        Logger  logger.Logger
}

// NewSystemUseCase cria uma nova instância de SystemUseCase.
func NewSystemUseCase(service services.SystemService, logger logger.Logger) SystemUseCase <span class="cov0" title="0">{
        return &amp;systemUseCaseImpl{
                Service: service,
                Logger:  logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package system

import (
        "github.com/RodolfoBonis/spooliq/core/middlewares"
        "github.com/RodolfoBonis/spooliq/features/system/domain/usecases"
        "github.com/gin-gonic/gin"
)

// GetSystemStatusHandler returns the current system status, including OS, CPU, memory, GPU, storage, and server info.
// @Summary Get System Status
// @Schemes
// @Description Returns the current system status (OS, CPU, memory, GPU, storage, server)
// @Tags System
// @Accept json
// @Produce json
// @Success 200 {object} entities.SystemStatus "System status info"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /system [get]
//
//        @Example response {
//          "OS": "Darwin",
//          "CPU": {"Model": "Intel(R) Core(TM) i7", "Cores": 8, "Threads": 16, "Usage": "15%"},
//          "Memory": {"Total": "16GB", "Available": "8GB", "Used": "8GB", "Percentage": "50%"},
//          "GPU": {"Model": "AMD Radeon Pro", "Memory": "4GB", "Available": true},
//          "Storage": {"Used": "200GB", "Total": "500GB", "Percentage": "40%"},
//          "Server": {"Version": "1.0.0", "Active": true}
//        }
func GetSystemStatusHandler(systemUc usecases.SystemUseCase) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                systemUc.GetSystemStatus(c)
        }</span>
}

// Routes registers system-related routes for the application.
func Routes(route *gin.RouterGroup, systemUc usecases.SystemUseCase, cacheMiddleware *middlewares.CacheMiddleware) <span class="cov0" title="0">{
        systemRoute := route.Group("/system")
        
        // Endpoint sem cache (sempre busca dados frescos)
        systemRoute.GET("", GetSystemStatusHandler(systemUc))
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package repositories

import (
        "context"
        "fmt"
        "time"

        "github.com/Nerzal/gocloak/v13"
        "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/logger"
        userEntities "github.com/RodolfoBonis/spooliq/features/users/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/users/domain/repositories"
)

type keycloakUserRepository struct {
        client             *gocloak.GoCloak
        keycloakConfig     entities.KeyCloakDataEntity
        logger             logger.Logger
        adminToken         *gocloak.JWT
        adminTokenExpiry   time.Time
}

// NewKeycloakUserRepository creates a new Keycloak user repository
func NewKeycloakUserRepository(
        client *gocloak.GoCloak,
        keycloakConfig entities.KeyCloakDataEntity,
        logger logger.Logger,
) repositories.UserRepository <span class="cov0" title="0">{
        return &amp;keycloakUserRepository{
                client:         client,
                keycloakConfig: keycloakConfig,
                logger:         logger,
        }
}</span>

// GetUsers retrieves users with optional filtering and pagination
func (r *keycloakUserRepository) GetUsers(ctx context.Context, query userEntities.UserListQuery) ([]*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">params := gocloak.GetUsersParams{
                Search: &amp;query.Search,
                First:  &amp;query.First,
                Max:    &amp;query.Max,
        }

        users, err := r.client.GetUsers(ctx, token.AccessToken, r.keycloakConfig.Realm, params)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get users from Keycloak", err)
                return nil, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov0" title="0">var result []*userEntities.User
        for _, kcUser := range users </span><span class="cov0" title="0">{
                user := r.mapKeycloakUserToEntity(kcUser)

                // Get user roles
                roles, err := r.getUserRoles(ctx, *kcUser.ID)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warning(ctx, "Failed to get user roles", map[string]interface{}{
                                "user_id": *kcUser.ID,
                                "error":   err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        user.Roles = roles
                }</span>

                <span class="cov0" title="0">result = append(result, user)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// GetUserByID retrieves a user by their ID
func (r *keycloakUserRepository) GetUserByID(ctx context.Context, userID string) (*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">kcUser, err := r.client.GetUserByID(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get user by ID from Keycloak", err)
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">user := r.mapKeycloakUserToEntity(kcUser)

        // Get user roles
        roles, err := r.getUserRoles(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Warning(ctx, "Failed to get user roles", map[string]interface{}{
                        "user_id": userID,
                        "error":   err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                user.Roles = roles
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByEmail retrieves a user by their email address
func (r *keycloakUserRepository) GetUserByEmail(ctx context.Context, email string) (*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">params := gocloak.GetUsersParams{
                Email: &amp;email,
                Exact: gocloak.BoolP(true),
        }

        users, err := r.client.GetUsers(ctx, token.AccessToken, r.keycloakConfig.Realm, params)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get user by email from Keycloak", err)
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, userEntities.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">user := r.mapKeycloakUserToEntity(users[0])

        // Get user roles
        roles, err := r.getUserRoles(ctx, *users[0].ID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Warning(ctx, "Failed to get user roles", map[string]interface{}{
                        "user_id": *users[0].ID,
                        "error":   err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                user.Roles = roles
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByUsername retrieves a user by their username
func (r *keycloakUserRepository) GetUserByUsername(ctx context.Context, username string) (*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">params := gocloak.GetUsersParams{
                Username: &amp;username,
                Exact:    gocloak.BoolP(true),
        }

        users, err := r.client.GetUsers(ctx, token.AccessToken, r.keycloakConfig.Realm, params)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to get user by username from Keycloak", err)
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, userEntities.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">user := r.mapKeycloakUserToEntity(users[0])

        // Get user roles
        roles, err := r.getUserRoles(ctx, *users[0].ID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Warning(ctx, "Failed to get user roles", map[string]interface{}{
                        "user_id": *users[0].ID,
                        "error":   err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                user.Roles = roles
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// CreateUser creates a new user
func (r *keycloakUserRepository) CreateUser(ctx context.Context, request *userEntities.UserCreateRequest) (*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        // Create user in Keycloak
        <span class="cov0" title="0">kcUser := gocloak.User{
                Username:  &amp;request.Username,
                Email:     &amp;request.Email,
                FirstName: &amp;request.FirstName,
                LastName:  &amp;request.LastName,
                Enabled:   &amp;request.Enabled,
        }

        userID, err := r.client.CreateUser(ctx, token.AccessToken, r.keycloakConfig.Realm, kcUser)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to create user in Keycloak", err)
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Set password
        <span class="cov0" title="0">err = r.client.SetPassword(ctx, token.AccessToken, r.keycloakConfig.Realm, userID, request.Password, request.TemporaryPassword)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to set password for new user", err)
                // Try to cleanup created user
                _ = r.client.DeleteUser(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
                return nil, fmt.Errorf("failed to set password: %w", err)
        }</span>

        // Get the created user
        <span class="cov0" title="0">return r.GetUserByID(ctx, userID)</span>
}

// UpdateUser updates an existing user
func (r *keycloakUserRepository) UpdateUser(ctx context.Context, userID string, updates *userEntities.UserUpdateRequest) (*userEntities.User, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, err := r.client.GetUserByID(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current user: %w", err)
        }</span>

        // Apply updates
        <span class="cov0" title="0">if updates.Email != nil </span><span class="cov0" title="0">{
                currentUser.Email = updates.Email
        }</span>
        <span class="cov0" title="0">if updates.FirstName != nil </span><span class="cov0" title="0">{
                currentUser.FirstName = updates.FirstName
        }</span>
        <span class="cov0" title="0">if updates.LastName != nil </span><span class="cov0" title="0">{
                currentUser.LastName = updates.LastName
        }</span>
        <span class="cov0" title="0">if updates.Enabled != nil </span><span class="cov0" title="0">{
                currentUser.Enabled = updates.Enabled
        }</span>

        // Update user in Keycloak
        <span class="cov0" title="0">err = r.client.UpdateUser(ctx, token.AccessToken, r.keycloakConfig.Realm, *currentUser)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to update user in Keycloak", err)
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        // Return updated user
        <span class="cov0" title="0">return r.GetUserByID(ctx, userID)</span>
}

// DeleteUser deletes a user by their ID
func (r *keycloakUserRepository) DeleteUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">err = r.client.DeleteUser(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to delete user in Keycloak", err)
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetUserEnabled enables or disables a user account
func (r *keycloakUserRepository) SetUserEnabled(ctx context.Context, userID string, enabled bool) error <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        // Get current user
        <span class="cov0" title="0">currentUser, err := r.client.GetUserByID(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current user: %w", err)
        }</span>

        // Update enabled status
        <span class="cov0" title="0">currentUser.Enabled = &amp;enabled

        err = r.client.UpdateUser(ctx, token.AccessToken, r.keycloakConfig.Realm, *currentUser)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to update user enabled status in Keycloak", err)
                return fmt.Errorf("failed to update user enabled status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ResetUserPassword resets a user's password
func (r *keycloakUserRepository) ResetUserPassword(ctx context.Context, userID string, newPassword string, temporary bool) error <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">err = r.client.SetPassword(ctx, token.AccessToken, r.keycloakConfig.Realm, userID, newPassword, temporary)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to reset user password in Keycloak", err)
                return fmt.Errorf("failed to reset password: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserRoles retrieves the roles assigned to a user
func (r *keycloakUserRepository) GetUserRoles(ctx context.Context, userID string) ([]string, error) <span class="cov0" title="0">{
        return r.getUserRoles(ctx, userID)
}</span>

// AddUserRole adds a role to a user
func (r *keycloakUserRepository) AddUserRole(ctx context.Context, userID string, role string) error <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        // Get role by name
        <span class="cov0" title="0">kcRole, err := r.client.GetRealmRole(ctx, token.AccessToken, r.keycloakConfig.Realm, role)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get role: %w", err)
        }</span>

        // Add role to user
        <span class="cov0" title="0">err = r.client.AddRealmRoleToUser(ctx, token.AccessToken, r.keycloakConfig.Realm, userID, []gocloak.Role{*kcRole})
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to add role to user in Keycloak", err)
                return fmt.Errorf("failed to add role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveUserRole removes a role from a user
func (r *keycloakUserRepository) RemoveUserRole(ctx context.Context, userID string, role string) error <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        // Get role by name
        <span class="cov0" title="0">kcRole, err := r.client.GetRealmRole(ctx, token.AccessToken, r.keycloakConfig.Realm, role)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get role: %w", err)
        }</span>

        // Remove role from user
        <span class="cov0" title="0">err = r.client.DeleteRealmRoleFromUser(ctx, token.AccessToken, r.keycloakConfig.Realm, userID, []gocloak.Role{*kcRole})
        if err != nil </span><span class="cov0" title="0">{
                r.logger.LogError(ctx, "Failed to remove role from user in Keycloak", err)
                return fmt.Errorf("failed to remove role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (r *keycloakUserRepository) getAdminToken(ctx context.Context) (*gocloak.JWT, error) <span class="cov0" title="0">{
        // Check if we have a valid admin token
        if r.adminToken != nil &amp;&amp; time.Now().Before(r.adminTokenExpiry.Add(-30*time.Second)) </span><span class="cov0" title="0">{
                return r.adminToken, nil
        }</span>

        // Get new admin token
        <span class="cov0" title="0">token, err := r.client.LoginAdmin(ctx, r.keycloakConfig.ClientID, r.keycloakConfig.ClientSecret, r.keycloakConfig.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to login as admin: %w", err)
        }</span>

        <span class="cov0" title="0">r.adminToken = token
        r.adminTokenExpiry = time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)

        return token, nil</span>
}

func (r *keycloakUserRepository) getUserRoles(ctx context.Context, userID string) ([]string, error) <span class="cov0" title="0">{
        token, err := r.getAdminToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get admin token: %w", err)
        }</span>

        <span class="cov0" title="0">roles, err := r.client.GetRealmRolesByUserID(ctx, token.AccessToken, r.keycloakConfig.Realm, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user roles: %w", err)
        }</span>

        <span class="cov0" title="0">var roleNames []string
        for _, role := range roles </span><span class="cov0" title="0">{
                if role.Name != nil </span><span class="cov0" title="0">{
                        roleNames = append(roleNames, *role.Name)
                }</span>
        }

        <span class="cov0" title="0">return roleNames, nil</span>
}

func (r *keycloakUserRepository) mapKeycloakUserToEntity(kcUser *gocloak.User) *userEntities.User <span class="cov0" title="0">{
        user := &amp;userEntities.User{
                ID:        *kcUser.ID,
                Enabled:   *kcUser.Enabled,
                CreatedAt: time.Unix(*kcUser.CreatedTimestamp/1000, 0),
        }

        if kcUser.Username != nil </span><span class="cov0" title="0">{
                user.Username = *kcUser.Username
        }</span>
        <span class="cov0" title="0">if kcUser.Email != nil </span><span class="cov0" title="0">{
                user.Email = *kcUser.Email
        }</span>
        <span class="cov0" title="0">if kcUser.FirstName != nil </span><span class="cov0" title="0">{
                user.FirstName = *kcUser.FirstName
        }</span>
        <span class="cov0" title="0">if kcUser.LastName != nil </span><span class="cov0" title="0">{
                user.LastName = *kcUser.LastName
        }</span>

        // Set UpdatedAt to CreatedAt if not available
        <span class="cov0" title="0">user.UpdatedAt = user.CreatedAt

        // Convert attributes if present
        if kcUser.Attributes != nil </span><span class="cov0" title="0">{
                user.Attributes = make(map[string]string)
                for key, values := range *kcUser.Attributes </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                user.Attributes[key] = values[0]
                        }</span>
                }
        }

        <span class="cov0" title="0">return user</span>
}</pre>
		
		<pre class="file" id="file78" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/users/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/users/domain/repositories"
        "github.com/RodolfoBonis/spooliq/features/users/domain/services"
        "github.com/go-playground/validator/v10"
)

type userServiceImpl struct {
        userRepo  repositories.UserRepository
        logger    logger.Logger
        validator *validator.Validate
}

// NewUserService creates a new user service implementation
func NewUserService(
        userRepo repositories.UserRepository,
        logger logger.Logger,
) services.UserService <span class="cov0" title="0">{
        return &amp;userServiceImpl{
                userRepo:  userRepo,
                logger:    logger,
                validator: validator.New(),
        }
}</span>

// GetUsers retrieves users with pagination and filtering (admin only)
func (s *userServiceImpl) GetUsers(ctx context.Context, query entities.UserListQuery, requesterID string) ([]*entities.User, error) <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return nil, fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to list users", map[string]interface{}{
                        "requester_id": requesterID,
                })
                return nil, entities.ErrUnauthorized
        }</span>

        // Set default pagination if not provided
        <span class="cov0" title="0">if query.Max == 0 </span><span class="cov0" title="0">{
                query.Max = 20
        }</span>
        <span class="cov0" title="0">if query.Max &gt; 100 </span><span class="cov0" title="0">{
                query.Max = 100 // Limit maximum results
        }</span>

        <span class="cov0" title="0">users, err := s.userRepo.GetUsers(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get users", err)
                return nil, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Users retrieved successfully", map[string]interface{}{
                "requester_id": requesterID,
                "count":        len(users),
                "query":        query.Search,
        })

        return users, nil</span>
}

// GetUserByID retrieves a user by ID (admin or self)
func (s *userServiceImpl) GetUserByID(ctx context.Context, userID string, requesterID string) (*entities.User, error) <span class="cov0" title="0">{
        // Get requester to check permissions
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return nil, fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        // Check if requester can access this user
        <span class="cov0" title="0">if !requester.CanModifyUser(userID) &amp;&amp; userID != requesterID </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "User attempted to access unauthorized user", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                })
                return nil, entities.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get user", err)
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetCurrentUser retrieves the current user's profile
func (s *userServiceImpl) GetCurrentUser(ctx context.Context, userID string) (*entities.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get current user", err)
                return nil, fmt.Errorf("failed to get current user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// CreateUser creates a new user (admin only)
func (s *userServiceImpl) CreateUser(ctx context.Context, request *entities.UserCreateRequest, requesterID string) (*entities.User, error) <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return nil, fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to create user", map[string]interface{}{
                        "requester_id": requesterID,
                })
                return nil, entities.ErrUnauthorized
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := s.validator.Struct(request); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "User create request validation failed", err)
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := request.ValidateCreate(); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "User create business validation failed", err)
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">existingUser, err := s.userRepo.GetUserByEmail(ctx, request.Email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Attempted to create user with existing email", map[string]interface{}{
                        "email":        request.Email,
                        "requester_id": requesterID,
                })
                return nil, entities.ErrUserAlreadyExists
        }</span>

        <span class="cov0" title="0">existingUser, err = s.userRepo.GetUserByUsername(ctx, request.Username)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Attempted to create user with existing username", map[string]interface{}{
                        "username":     request.Username,
                        "requester_id": requesterID,
                })
                return nil, entities.ErrUserAlreadyExists
        }</span>

        // Create user
        <span class="cov0" title="0">user, err := s.userRepo.CreateUser(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to create user", err)
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "User created successfully", map[string]interface{}{
                "user_id":      user.ID,
                "username":     user.Username,
                "email":        user.Email,
                "requester_id": requesterID,
        })

        return user, nil</span>
}

// UpdateUser updates a user (admin or self with restrictions)
func (s *userServiceImpl) UpdateUser(ctx context.Context, userID string, updates *entities.UserUpdateRequest, requesterID string) (*entities.User, error) <span class="cov0" title="0">{
        // Get requester to check permissions
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return nil, fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        // Check if requester can modify this user
        <span class="cov0" title="0">if !requester.CanModifyUser(userID) &amp;&amp; userID != requesterID </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "User attempted to update unauthorized user", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                })
                return nil, entities.ErrUnauthorized
        }</span>

        // If user is updating themselves, they can't change enabled status
        <span class="cov0" title="0">if userID == requesterID &amp;&amp; updates.Enabled != nil </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "User attempted to change their own enabled status", map[string]interface{}{
                        "user_id": userID,
                })
                updates.Enabled = nil // Remove this field from updates
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := s.validator.Struct(updates); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "User update request validation failed", err)
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := updates.ValidateUpdate(); err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "User update business validation failed", err)
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Check if email is being changed and if it already exists
        <span class="cov0" title="0">if updates.Email != nil </span><span class="cov0" title="0">{
                existingUser, err := s.userRepo.GetUserByEmail(ctx, *updates.Email)
                if err == nil &amp;&amp; existingUser != nil &amp;&amp; existingUser.ID != userID </span><span class="cov0" title="0">{
                        s.logger.Warning(ctx, "Attempted to update user with existing email", map[string]interface{}{
                                "email":        *updates.Email,
                                "target_id":    userID,
                                "requester_id": requesterID,
                        })
                        return nil, entities.ErrUserAlreadyExists
                }</span>
        }

        // Update user
        <span class="cov0" title="0">user, err := s.userRepo.UpdateUser(ctx, userID, updates)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to update user", err)
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "User updated successfully", map[string]interface{}{
                "user_id":      userID,
                "requester_id": requesterID,
        })

        return user, nil</span>
}

// DeleteUser deletes a user (admin only)
func (s *userServiceImpl) DeleteUser(ctx context.Context, userID string, requesterID string) error <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to delete user", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                })
                return entities.ErrUnauthorized
        }</span>

        // Prevent self-deletion
        <span class="cov0" title="0">if userID == requesterID </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Admin attempted to delete themselves", map[string]interface{}{
                        "user_id": userID,
                })
                return fmt.Errorf("cannot delete your own account")
        }</span>

        // Verify target user exists
        <span class="cov0" title="0">_, err = s.userRepo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get target user for deletion", err)
                return fmt.Errorf("failed to get target user: %w", err)
        }</span>

        // Delete user
        <span class="cov0" title="0">err = s.userRepo.DeleteUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to delete user", err)
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "User deleted successfully", map[string]interface{}{
                "deleted_user_id": userID,
                "requester_id":    requesterID,
        })

        return nil</span>
}

// SetUserEnabled enables/disables a user account (admin only)
func (s *userServiceImpl) SetUserEnabled(ctx context.Context, userID string, enabled bool, requesterID string) error <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to change user enabled status", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                })
                return entities.ErrUnauthorized
        }</span>

        // Prevent disabling self
        <span class="cov0" title="0">if userID == requesterID &amp;&amp; !enabled </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Admin attempted to disable themselves", map[string]interface{}{
                        "user_id": userID,
                })
                return fmt.Errorf("cannot disable your own account")
        }</span>

        <span class="cov0" title="0">err = s.userRepo.SetUserEnabled(ctx, userID, enabled)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to set user enabled status", err)
                return fmt.Errorf("failed to set user enabled status: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "User enabled status changed", map[string]interface{}{
                "user_id":      userID,
                "enabled":      enabled,
                "requester_id": requesterID,
        })

        return nil</span>
}

// ResetUserPassword resets a user's password (admin only)
func (s *userServiceImpl) ResetUserPassword(ctx context.Context, userID string, newPassword string, temporary bool, requesterID string) error <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to reset password", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                })
                return entities.ErrUnauthorized
        }</span>

        // Validate password strength
        <span class="cov0" title="0">req := &amp;entities.UserCreateRequest{Password: newPassword}
        if err := req.ValidateCreate(); err != nil </span><span class="cov0" title="0">{
                return entities.ErrPasswordTooWeak
        }</span>

        <span class="cov0" title="0">err = s.userRepo.ResetUserPassword(ctx, userID, newPassword, temporary)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to reset user password", err)
                return fmt.Errorf("failed to reset password: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "User password reset successfully", map[string]interface{}{
                "user_id":      userID,
                "temporary":    temporary,
                "requester_id": requesterID,
        })

        return nil</span>
}

// AddUserRole adds a role to a user (admin only)
func (s *userServiceImpl) AddUserRole(ctx context.Context, userID string, role string, requesterID string) error <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to add role", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                        "role":         role,
                })
                return entities.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = s.userRepo.AddUserRole(ctx, userID, role)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to add role to user", err)
                return fmt.Errorf("failed to add role: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Role added to user successfully", map[string]interface{}{
                "user_id":      userID,
                "role":         role,
                "requester_id": requesterID,
        })

        return nil</span>
}

// RemoveUserRole removes a role from a user (admin only)
func (s *userServiceImpl) RemoveUserRole(ctx context.Context, userID string, role string, requesterID string) error <span class="cov0" title="0">{
        // Verify requester is admin
        requester, err := s.userRepo.GetUserByID(ctx, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to get requester user", err)
                return fmt.Errorf("failed to verify requester: %w", err)
        }</span>

        <span class="cov0" title="0">if !requester.IsAdmin() </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Non-admin user attempted to remove role", map[string]interface{}{
                        "requester_id": requesterID,
                        "target_id":    userID,
                        "role":         role,
                })
                return entities.ErrUnauthorized
        }</span>

        // Prevent removing admin role from self
        <span class="cov0" title="0">if userID == requesterID &amp;&amp; role == "admin" </span><span class="cov0" title="0">{
                s.logger.Warning(ctx, "Admin attempted to remove admin role from themselves", map[string]interface{}{
                        "user_id": userID,
                })
                return fmt.Errorf("cannot remove admin role from your own account")
        }</span>

        <span class="cov0" title="0">err = s.userRepo.RemoveUserRole(ctx, userID, role)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.LogError(ctx, "Failed to remove role from user", err)
                return fmt.Errorf("failed to remove role: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Role removed from user successfully", map[string]interface{}{
                "user_id":      userID,
                "role":         role,
                "requester_id": requesterID,
        })

        return nil</span>
}</pre>
		
		<pre class="file" id="file79" style="display: none">package di

import (
        "github.com/gin-gonic/gin"
        "go.uber.org/fx"

        "github.com/RodolfoBonis/spooliq/core/config"
        "github.com/RodolfoBonis/spooliq/core/entities"
        userRepositories "github.com/RodolfoBonis/spooliq/features/users/data/repositories"
        userServices "github.com/RodolfoBonis/spooliq/features/users/data/services"
        "github.com/RodolfoBonis/spooliq/features/users/domain/repositories"
        domainServices "github.com/RodolfoBonis/spooliq/features/users/domain/services"
        "github.com/RodolfoBonis/spooliq/features/users/presentation/handlers"
)

// Module provides the users feature module
var Module = fx.Module("users",
        fx.Provide(
                // Repositories
                fx.Annotate(
                        userRepositories.NewKeycloakUserRepository,
                        fx.As(new(repositories.UserRepository)),
                ),

                // Services
                fx.Annotate(
                        userServices.NewUserService,
                        fx.As(new(domainServices.UserService)),
                ),

                // Handlers
                handlers.NewUserHandler,

                // Keycloak configuration provider
                func() entities.KeyCloakDataEntity <span class="cov0" title="0">{
                        return config.EnvKeyCloak()
                }</span>,
        ),
        fx.Invoke(RegisterUserRoutes),
)

// RegisterUserRoutes registers the user routes
func RegisterUserRoutes(r *gin.Engine, handler *handlers.UserHandler) <span class="cov0" title="0">{
        v1 := r.Group("/v1")
        </span><span class="cov0" title="0">{
                // User management endpoints
                users := v1.Group("/users")
                </span><span class="cov0" title="0">{
                        // Public endpoint for current user profile
                        users.GET("/me", handler.GetCurrentUser)

                        // Admin endpoints for user management
                        users.GET("", handler.GetUsers)                              // List users (admin)
                        users.POST("", handler.CreateUser)                          // Create user (admin)
                        users.GET("/:id", handler.GetUserByID)                      // Get user by ID (admin or self)
                        users.PATCH("/:id", handler.UpdateUser)                     // Update user (admin or self)
                        users.DELETE("/:id", handler.DeleteUser)                    // Delete user (admin)
                        users.PATCH("/:id/enabled", handler.SetUserEnabled)         // Enable/disable user (admin)
                        users.PATCH("/:id/password", handler.ResetUserPassword)     // Reset password (admin)
                        users.POST("/:id/roles", handler.AddUserRole)               // Add role (admin)
                        users.DELETE("/:id/roles/:role", handler.RemoveUserRole)    // Remove role (admin)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file80" style="display: none">package entities

import (
        "time"
        "errors"
        "regexp"
)

// User represents a user in the domain
type User struct {
        ID          string             `json:"id"`
        Username    string             `json:"username"`
        Email       string             `json:"email"`
        FirstName   string             `json:"first_name"`
        LastName    string             `json:"last_name"`
        Enabled     bool               `json:"enabled"`
        CreatedAt   time.Time          `json:"created_at"`
        UpdatedAt   time.Time          `json:"updated_at"`
        Roles       []string           `json:"roles"`
        Attributes  map[string]string  `json:"attributes,omitempty"`
}

// UserCreateRequest represents data needed to create a new user
type UserCreateRequest struct {
        Username        string `json:"username" validate:"required,min=3,max=50"`
        Email          string `json:"email" validate:"required,email"`
        FirstName      string `json:"first_name" validate:"required,min=1,max=100"`
        LastName       string `json:"last_name" validate:"required,min=1,max=100"`
        Password       string `json:"password" validate:"required,min=8"`
        Enabled        bool   `json:"enabled"`
        TemporaryPassword bool `json:"temporary_password"`
}

// UserUpdateRequest represents data that can be updated for a user
type UserUpdateRequest struct {
        Email     *string `json:"email,omitempty" validate:"omitempty,email"`
        FirstName *string `json:"first_name,omitempty" validate:"omitempty,min=1,max=100"`
        LastName  *string `json:"last_name,omitempty" validate:"omitempty,min=1,max=100"`
        Enabled   *bool   `json:"enabled,omitempty"`
}

// UserListQuery represents query parameters for listing users
type UserListQuery struct {
        Search string `json:"search,omitempty"`
        First  int    `json:"first,omitempty"`
        Max    int    `json:"max,omitempty"`
}

// Business validation methods

// ValidateCreate validates user creation request
func (req *UserCreateRequest) ValidateCreate() error <span class="cov0" title="0">{
        if err := req.validateUsername(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := req.validateEmail(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := req.validatePassword(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateUpdate validates user update request
func (req *UserUpdateRequest) ValidateUpdate() error <span class="cov0" title="0">{
        if req.Email != nil </span><span class="cov0" title="0">{
                if err := validateEmailFormat(*req.Email); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFullName returns the user's full name
func (u *User) GetFullName() string <span class="cov0" title="0">{
        if u.FirstName == "" &amp;&amp; u.LastName == "" </span><span class="cov0" title="0">{
                return u.Username
        }</span>
        <span class="cov0" title="0">return u.FirstName + " " + u.LastName</span>
}

// HasRole checks if user has a specific role
func (u *User) HasRole(role string) bool <span class="cov0" title="0">{
        for _, r := range u.Roles </span><span class="cov0" title="0">{
                if r == role </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsAdmin checks if user has admin role
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.HasRole("admin")
}</span>

// CanModifyUser checks if current user can modify target user
func (u *User) CanModifyUser(targetUserID string) bool <span class="cov0" title="0">{
        // Admin can modify anyone except themselves
        if u.IsAdmin() &amp;&amp; u.ID != targetUserID </span><span class="cov0" title="0">{
                return true
        }</span>
        // Users can only modify themselves
        <span class="cov0" title="0">return u.ID == targetUserID</span>
}

// Private validation helpers

func (req *UserCreateRequest) validateUsername() error <span class="cov0" title="0">{
        if len(req.Username) &lt; 3 || len(req.Username) &gt; 50 </span><span class="cov0" title="0">{
                return errors.New("username must be between 3 and 50 characters")
        }</span>

        // Username must contain only alphanumeric characters, dots, underscores, and hyphens
        <span class="cov0" title="0">matched, _ := regexp.MatchString("^[a-zA-Z0-9._-]+$", req.Username)
        if !matched </span><span class="cov0" title="0">{
                return errors.New("username can only contain letters, numbers, dots, underscores, and hyphens")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (req *UserCreateRequest) validateEmail() error <span class="cov0" title="0">{
        return validateEmailFormat(req.Email)
}</span>

func validateEmailFormat(email string) error <span class="cov0" title="0">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(email) </span><span class="cov0" title="0">{
                return errors.New("invalid email format")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (req *UserCreateRequest) validatePassword() error <span class="cov0" title="0">{
        if len(req.Password) &lt; 8 </span><span class="cov0" title="0">{
                return errors.New("password must be at least 8 characters long")
        }</span>

        // Check for at least one uppercase letter
        <span class="cov0" title="0">hasUpper, _ := regexp.MatchString(`[A-Z]`, req.Password)
        if !hasUpper </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one uppercase letter")
        }</span>

        // Check for at least one lowercase letter
        <span class="cov0" title="0">hasLower, _ := regexp.MatchString(`[a-z]`, req.Password)
        if !hasLower </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one lowercase letter")
        }</span>

        // Check for at least one number
        <span class="cov0" title="0">hasNumber, _ := regexp.MatchString(`[0-9]`, req.Password)
        if !hasNumber </span><span class="cov0" title="0">{
                return errors.New("password must contain at least one number")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Common domain errors
var (
        ErrUserNotFound      = errors.New("user not found")
        ErrUserAlreadyExists = errors.New("user already exists")
        ErrInvalidUserData   = errors.New("invalid user data")
        ErrUnauthorized      = errors.New("unauthorized to perform this action")
        ErrPasswordTooWeak   = errors.New("password does not meet security requirements")
)</pre>
		
		<pre class="file" id="file81" style="display: none">package dto

import (
        "time"
        "github.com/RodolfoBonis/spooliq/features/users/domain/entities"
)

// UserResponse represents a user in API responses
type UserResponse struct {
        ID          string            `json:"id"`
        Username    string            `json:"username"`
        Email       string            `json:"email"`
        FirstName   string            `json:"first_name"`
        LastName    string            `json:"last_name"`
        FullName    string            `json:"full_name"`
        Enabled     bool              `json:"enabled"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        Roles       []string          `json:"roles"`
        Attributes  map[string]string `json:"attributes,omitempty"`
}

// UsersListResponse represents a paginated list of users
type UsersListResponse struct {
        Users []UserResponse `json:"users"`
        Total int           `json:"total"`
        Page  int           `json:"page"`
        Size  int           `json:"size"`
}

// CreateUserRequest represents the request to create a new user
type CreateUserRequest struct {
        Username          string `json:"username" validate:"required,min=3,max=50"`
        Email            string `json:"email" validate:"required,email"`
        FirstName        string `json:"first_name" validate:"required,min=1,max=100"`
        LastName         string `json:"last_name" validate:"required,min=1,max=100"`
        Password         string `json:"password" validate:"required,min=8"`
        Enabled          bool   `json:"enabled"`
        TemporaryPassword bool   `json:"temporary_password"`
}

// UpdateUserRequest represents the request to update user information
type UpdateUserRequest struct {
        Email     *string `json:"email,omitempty" validate:"omitempty,email"`
        FirstName *string `json:"first_name,omitempty" validate:"omitempty,min=1,max=100"`
        LastName  *string `json:"last_name,omitempty" validate:"omitempty,min=1,max=100"`
        Enabled   *bool   `json:"enabled,omitempty"`
}

// UserListQueryRequest represents query parameters for listing users
type UserListQueryRequest struct {
        Search string `form:"search" json:"search,omitempty"`
        Page   int    `form:"page" json:"page,omitempty"`
        Size   int    `form:"size" json:"size,omitempty"`
}

// SetUserEnabledRequest represents the request to enable/disable a user
type SetUserEnabledRequest struct {
        Enabled bool `json:"enabled"`
}

// ResetPasswordRequest represents the request to reset a user's password
type ResetPasswordRequest struct {
        NewPassword string `json:"new_password" validate:"required,min=8"`
        Temporary   bool   `json:"temporary"`
}

// UserRoleRequest represents the request to add/remove a role
type UserRoleRequest struct {
        Role string `json:"role" validate:"required"`
}

// Conversion methods

// ToEntity converts CreateUserRequest to domain entity
func (req *CreateUserRequest) ToEntity() *entities.UserCreateRequest <span class="cov0" title="0">{
        return &amp;entities.UserCreateRequest{
                Username:          req.Username,
                Email:            req.Email,
                FirstName:        req.FirstName,
                LastName:         req.LastName,
                Password:         req.Password,
                Enabled:          req.Enabled,
                TemporaryPassword: req.TemporaryPassword,
        }
}</span>

// ToEntity converts UpdateUserRequest to domain entity
func (req *UpdateUserRequest) ToEntity() *entities.UserUpdateRequest <span class="cov0" title="0">{
        return &amp;entities.UserUpdateRequest{
                Email:     req.Email,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Enabled:   req.Enabled,
        }
}</span>

// ToEntity converts UserListQueryRequest to domain entity
func (req *UserListQueryRequest) ToEntity() entities.UserListQuery <span class="cov0" title="0">{
        // Set defaults
        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.Size &lt;= 0 </span><span class="cov0" title="0">{
                req.Size = 20
        }</span>
        <span class="cov0" title="0">if req.Size &gt; 100 </span><span class="cov0" title="0">{
                req.Size = 100
        }</span>

        <span class="cov0" title="0">first := (req.Page - 1) * req.Size

        return entities.UserListQuery{
                Search: req.Search,
                First:  first,
                Max:    req.Size,
        }</span>
}

// FromEntity converts domain entity to UserResponse
func UserResponseFromEntity(user *entities.User) UserResponse <span class="cov0" title="0">{
        response := UserResponse{
                ID:         user.ID,
                Username:   user.Username,
                Email:      user.Email,
                FirstName:  user.FirstName,
                LastName:   user.LastName,
                FullName:   user.GetFullName(),
                Enabled:    user.Enabled,
                CreatedAt:  user.CreatedAt,
                UpdatedAt:  user.UpdatedAt,
                Roles:      user.Roles,
                Attributes: user.Attributes,
        }

        return response
}</span>

// FromEntities converts slice of domain entities to UserResponse slice
func UserResponsesFromEntities(users []*entities.User) []UserResponse <span class="cov0" title="0">{
        responses := make([]UserResponse, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                responses[i] = UserResponseFromEntity(user)
        }</span>
        <span class="cov0" title="0">return responses</span>
}

// ToUsersListResponse creates a paginated response
func ToUsersListResponse(users []*entities.User, page, size int) UsersListResponse <span class="cov0" title="0">{
        return UsersListResponse{
                Users: UserResponsesFromEntities(users),
                Total: len(users),
                Page:  page,
                Size:  size,
        }
}</pre>
		
		<pre class="file" id="file82" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"

        coreEntities "github.com/RodolfoBonis/spooliq/core/entities"
        "github.com/RodolfoBonis/spooliq/core/errors"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/features/users/domain/entities"
        "github.com/RodolfoBonis/spooliq/features/users/domain/services"
        "github.com/RodolfoBonis/spooliq/features/users/presentation/dto"
)

type UserHandler struct {
        userService services.UserService
        logger      logger.Logger
        validator   *validator.Validate
}

// NewUserHandler creates a new user handler
func NewUserHandler(
        userService services.UserService,
        logger logger.Logger,
) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
                logger:      logger,
                validator:   validator.New(),
        }
}</span>

// GetUsers retrieves users with pagination and filtering (admin only)
// @Summary Get users list
// @Description Retrieves a paginated list of users with optional search filtering (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param search query string false "Search term for username, email, first name, or last name"
// @Param page query int false "Page number (default: 1)"
// @Param size query int false "Page size (default: 20, max: 100)"
// @Success 200 {object} dto.UsersListResponse
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users [get]
// @Security BearerAuth
func (h *UserHandler) GetUsers(c *gin.Context) <span class="cov0" title="0">{
        // Get query parameters
        var query dto.UserListQueryRequest
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid query parameters", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind query parameters", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to domain query
        <span class="cov0" title="0">domainQuery := query.ToEntity()

        // Get users
        users, err := h.userService.GetUsers(c.Request.Context(), domainQuery, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get users", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := dto.ToUsersListResponse(users, query.Page, query.Size)

        c.JSON(http.StatusOK, response)</span>
}

// GetUserByID retrieves a user by ID (admin or self)
// @Summary Get user by ID
// @Description Retrieves a user by their ID (admin can get any user, users can get themselves)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} dto.UserResponse
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id} [get]
// @Security BearerAuth
func (h *UserHandler) GetUserByID(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), userID, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get user", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := dto.UserResponseFromEntity(user)

        c.JSON(http.StatusOK, response)</span>
}

// GetCurrentUser retrieves the current user's profile
// @Summary Get current user profile
// @Description Retrieves the authenticated user's profile information
// @Tags users
// @Accept json
// @Produce json
// @Success 200 {object} dto.UserResponse
// @Failure 401 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/me [get]
// @Security BearerAuth
func (h *UserHandler) GetCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        // Get requester ID
        requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get current user
        <span class="cov0" title="0">user, err := h.userService.GetCurrentUser(c.Request.Context(), requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to get current user", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := dto.UserResponseFromEntity(user)

        c.JSON(http.StatusOK, response)</span>
}

// CreateUser creates a new user (admin only)
// @Summary Create new user
// @Description Creates a new user account (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param request body dto.CreateUserRequest true "User creation data"
// @Success 201 {object} dto.UserResponse
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users [post]
// @Security BearerAuth
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        // Bind request
        var req dto.CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind create user request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Create user request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to domain entity
        <span class="cov0" title="0">domainRequest := req.ToEntity()

        // Create user
        user, err := h.userService.CreateUser(c.Request.Context(), domainRequest, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to create user", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := dto.UserResponseFromEntity(user)

        c.JSON(http.StatusCreated, response)</span>
}

// UpdateUser updates a user (admin or self with restrictions)
// @Summary Update user
// @Description Updates user information (admin can update any user, users can update themselves with restrictions)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body dto.UpdateUserRequest true "User update data"
// @Success 200 {object} dto.UserResponse
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 409 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id} [patch]
// @Security BearerAuth
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">var req dto.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind update user request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Update user request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to domain entity
        <span class="cov0" title="0">domainRequest := req.ToEntity()

        // Update user
        user, err := h.userService.UpdateUser(c.Request.Context(), userID, domainRequest, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to update user", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Convert to response
        <span class="cov0" title="0">response := dto.UserResponseFromEntity(user)

        c.JSON(http.StatusOK, response)</span>
}

// DeleteUser deletes a user (admin only)
// @Summary Delete user
// @Description Deletes a user account (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 204 "User deleted successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id} [delete]
// @Security BearerAuth
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Delete user
        <span class="cov0" title="0">err := h.userService.DeleteUser(c.Request.Context(), userID, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to delete user", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// SetUserEnabled enables or disables a user account (admin only)
// @Summary Enable/disable user
// @Description Enables or disables a user account (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body dto.SetUserEnabledRequest true "Enable/disable data"
// @Success 204 "User status updated successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id}/enabled [patch]
// @Security BearerAuth
func (h *UserHandler) SetUserEnabled(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">var req dto.SetUserEnabledRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind set enabled request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Set user enabled status
        <span class="cov0" title="0">err := h.userService.SetUserEnabled(c.Request.Context(), userID, req.Enabled, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to set user enabled status", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// ResetUserPassword resets a user's password (admin only)
// @Summary Reset user password
// @Description Resets a user's password (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body dto.ResetPasswordRequest true "Password reset data"
// @Success 204 "Password reset successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id}/password [patch]
// @Security BearerAuth
func (h *UserHandler) ResetUserPassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">var req dto.ResetPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind reset password request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Reset password request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Reset password
        <span class="cov0" title="0">err := h.userService.ResetUserPassword(c.Request.Context(), userID, req.NewPassword, req.Temporary, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to reset user password", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// AddUserRole adds a role to a user (admin only)
// @Summary Add role to user
// @Description Adds a role to a user (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body dto.UserRoleRequest true "Role data"
// @Success 204 "Role added successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id}/roles [post]
// @Security BearerAuth
func (h *UserHandler) AddUserRole(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">var req dto.UserRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Invalid request format", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to bind add role request", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Validation failed", nil, err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Add role request validation failed", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Add role
        <span class="cov0" title="0">err := h.userService.AddUserRole(c.Request.Context(), userID, req.Role, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to add user role", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// RemoveUserRole removes a role from a user (admin only)
// @Summary Remove role from user
// @Description Removes a role from a user (admin only)
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param role path string true "Role name"
// @Success 204 "Role removed successfully"
// @Failure 400 {object} errors.HTTPError
// @Failure 401 {object} errors.HTTPError
// @Failure 403 {object} errors.HTTPError
// @Failure 404 {object} errors.HTTPError
// @Failure 500 {object} errors.HTTPError
// @Router /users/{id}/roles/{role} [delete]
// @Security BearerAuth
func (h *UserHandler) RemoveUserRole(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        role := c.Param("role")

        if userID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "User ID is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User ID is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">if role == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrEntity, "Role is required", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Role is required", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Get requester ID
        <span class="cov0" title="0">requesterID := c.GetString("user_id")
        if requesterID == "" </span><span class="cov0" title="0">{
                appError := errors.NewAppError(coreEntities.ErrUnauthorized, "User not authenticated", nil, nil)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "User not authenticated", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        // Remove role
        <span class="cov0" title="0">err := h.userService.RemoveUserRole(c.Request.Context(), userID, role, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                appError := h.mapDomainError(err)
                httpError := appError.ToHTTPError()
                h.logger.LogError(c.Request.Context(), "Failed to remove user role", appError)
                c.JSON(httpError.StatusCode, httpError)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// Helper methods

func (h *UserHandler) mapDomainError(err error) *errors.AppError <span class="cov0" title="0">{
        switch err </span>{
        case entities.ErrUserNotFound:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrNotFound, "User not found", nil, err)</span>
        case entities.ErrUserAlreadyExists:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrConflict, "User already exists", nil, err)</span>
        case entities.ErrUnauthorized:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrUnauthorized, "Unauthorized", nil, err)</span>
        case entities.ErrInvalidUserData:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrEntity, "Invalid user data", nil, err)</span>
        case entities.ErrPasswordTooWeak:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrEntity, "Password does not meet security requirements", nil, err)</span>
        default:<span class="cov0" title="0">
                return errors.NewAppError(coreEntities.ErrService, "Internal server error", nil, err)</span>
        }
}</pre>
		
		<pre class="file" id="file83" style="display: none">package main

import "github.com/RodolfoBonis/spooliq/app"

func main() <span class="cov0" title="0">{
        app.NewFxApp().Run()
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package routes

import (
        "github.com/RodolfoBonis/spooliq/core/health"
        "github.com/RodolfoBonis/spooliq/core/logger"
        "github.com/RodolfoBonis/spooliq/core/middlewares"
        "github.com/RodolfoBonis/spooliq/features/auth"
        auth_uc "github.com/RodolfoBonis/spooliq/features/auth/domain/usecases"
        "github.com/RodolfoBonis/spooliq/features/filaments"
        filaments_uc "github.com/RodolfoBonis/spooliq/features/filaments/domain/usecases"
        "github.com/RodolfoBonis/spooliq/features/system"
        system_uc "github.com/RodolfoBonis/spooliq/features/system/domain/usecases"
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// InitializeRoutes sets up all application routes.
func InitializeRoutes(
        router *gin.Engine,
        systemUc system_uc.SystemUseCase,
        authUc auth_uc.AuthUseCase,
        filamentsUc filaments_uc.FilamentUseCase,
        protectFactory func(handler gin.HandlerFunc, role string) gin.HandlerFunc,
        cacheMiddleware *middlewares.CacheMiddleware,
        logger logger.Logger,
) <span class="cov0" title="0">{

        root := router.Group("/v1")

        root.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        router.GET("/metrics", gin.WrapH(promhttp.Handler()))

        health.Routes(root, logger)
        auth.Routes(root, authUc, protectFactory)
        system.Routes(root, systemUc, cacheMiddleware)
        filaments.Routes(root, filamentsUc, protectFactory)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
