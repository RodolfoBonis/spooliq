name: CD Pipeline - spooliq


on:
  workflow_run:
    workflows: ["CI/CD Pipeline - ${{ github.event.repository.name }}"]
    types:
      - completed
    branches: [main]
    path-ignore:
      -
  workflow_dispatch:

env:
  GO_VERSION: '1.23'
  PACKAGE_NAME: ${{ github.event.repository.name }}
  REPOSITORY_OWNER: ${{ github.repository_owner }}

jobs:
  get_commit_messages:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
    steps:
      - name: Install GitHub CLI
        run: sudo apt-get install gh -y

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Get commit information
        id: commit_info
        run: |
          # Tenta pegar informações da última PR mesclada
          pr_info=$(gh pr list --state merged --limit 1 --json number,title,body,mergeCommit)
          
          # Verifica se encontrou uma PR
          if [ "$(echo "$pr_info" | jq '. | length')" -gt 0 ] && [ "$(echo "$pr_info" | jq -r '.[0].mergeCommit.oid')" = "$(git rev-parse HEAD)" ]; then
            # É uma PR mesclada
            pr_number=$(echo "$pr_info" | jq -r '.[0].number')
            echo "🔄 Pull Request #$pr_number" > commit_messages.txt
            echo "$(echo "$pr_info" | jq -r '.[0].title')" >> commit_messages.txt
            echo "" >> commit_messages.txt
          
            pr_body=$(echo "$pr_info" | jq -r '.[0].body')
            if [ "$pr_body" != "null" ] && [ ! -z "$pr_body" ]; then
              echo "📝 Description:" >> commit_messages.txt
              echo "$pr_body" >> commit_messages.txt
              echo "" >> commit_messages.txt
            fi
          
            echo "📦 Commits:" >> commit_messages.txt
            gh pr view $pr_number --json commits --jq '.commits[] | "• " + .messageHeadline + if .messageBody then "\n  " + (.messageBody | gsub("\n"; "\n  ")) else "" end' >> commit_messages.txt
          else
            # É um push direto na main
            echo "📦 Direct Push to Main" > commit_messages.txt
            echo "" >> commit_messages.txt
          
            # Pega o último commit
            last_commit=$(git log -1 --pretty=format:"%s%n%n%b")
            echo "• $last_commit" >> commit_messages.txt
          
            # Se houver mais commits no push, adiciona eles também
            additional_commits=$(git log HEAD~1..HEAD^ --pretty=format:"• %s%n  %b")
            if [ ! -z "$additional_commits" ]; then
              echo "$additional_commits" >> commit_messages.txt
            fi
          fi

      - name: Upload commit messages
        uses: actions/upload-artifact@v4
        with:
          name: commit-messages
          path: commit_messages.txt

  build_and_deploy:
    needs: get_commit_messages
    runs-on: ${{ matrix.os }}
    outputs:
      VERSION: ${{ env.VERSION }}
      IMAGE_URL: ${{ env.IMAGE_URL }}
    strategy:
      matrix:
        os: [ubuntu-latest]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup ArgoCD CLI
        uses: imajeetyadav/argocd-cli@v1

      - name: Increment version
        run: |
          chmod +x ./.config/scripts/increment_version.sh
          ./.config/scripts/increment_version.sh
          echo "VERSION=$(cat version.txt)" >> $GITHUB_ENV

      - name: Add, commit and push version increment
        uses: EndBug/add-and-commit@v9
        with:
          author_name: "GitHub Actions"
          author_email: "actions@github.com"
          message: "Increment version"
          add: "version.txt"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Preset Image Name
        run: echo "IMAGE_URL=$(echo ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY_OWNER }}/${{ env.PACKAGE_NAME }}:${{ env.VERSION }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Build and push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./dockerfile
          push: true
          tags: ${{ env.IMAGE_URL }}
          build-args: |
            "GITHUB_TOKEN=${{ secrets.GH_TOKEN }}"
            "VERSION=${{ env.VERSION }}"

      - name: Checkout k3s manifest repository
        uses: actions/checkout@master
        with:
          repository: RodolfoBonis/k3s-apps
          ref: main
          path: k3s-manifest
          token: ${{ secrets.GH_TOKEN }}

      - name: Update k3s manifest with new image version
        run: |
          cd k3s-manifest
          yq e -i ".spec.template.spec.containers[0].image = \"${{ env.IMAGE_URL }}\"" ./applications/spooliq/service/spooliq-deployment.yaml
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add ./applications/spooliq/service/spooliq-deployment.yaml
          git commit -m "Update image to ${{ env.IMAGE_URL }}"
          git push

      - name: Sync ArgoCD Application
        run: |
          argocd app sync spooliq --grpc-web --server ${{ secrets.ARGOCD_SERVER }} --auth-token ${{ secrets.ARGOCD_TOKEN }}

      - name: Create Tag for Release
        id: create_tag
        if: ${{ job.status == 'success' }}
        run: echo "::set-output name=tag::v${{ env.VERSION }}"

      - name: Download commit messages
        uses: actions/download-artifact@v4
        with:
          name: commit-messages
          path: .

      - name: Create Release
        id: create_release
        if: ${{ job.status == 'success' }}
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          tag_name: ${{ steps.create_tag.outputs.tag }}
          release_name: Release ${{ env.VERSION }}
          body: |
            Changes in this Release:
          body_path: commit_messages.txt
          draft: false
          prerelease: false

  notify_success:
    name: Notify Success
    needs: build_and_deploy
    runs-on: ubuntu-latest
    if: ${{ needs.build_and_deploy.result == 'success' }}
    steps:
      - name: Generate success message
        id: generate_success_message
        run: |
          echo '✅ **Deploy Successful!**' > telegram_message_success.txt
          echo '' >> telegram_message_success.txt
          echo '📋 **📦 **${{ env.PACKAGE_NAME }}** has been deployed!**' >> telegram_message_success.txt
          echo '- Version: ${{ needs.build_and_deploy.outputs.VERSION }}' >> telegram_message_success.txt
          echo '- Deployed by: ${{ github.actor }}' >> telegram_message_success.txt
          echo '- 📝 *Release Notes:* [Release ${{ needs.build_and_deploy.outputs.VERSION }}](https://github.com/${{ github.repository }}/releases/tag/v${{ needs.build_and_deploy.outputs.VERSION }})' >> telegram_message_success.txt
          echo '' >> telegram_message_success.txt
          echo '✨ All tests passed, code linted successfully, and no vulnerabilities found!' >> telegram_message_success.txt
          
          MESSAGE=$(cat telegram_message_success.txt)
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send Telegram notification on success
        if: ${{ needs.build_and_deploy.result == 'success' }}
        uses: an3park/telegram-action@v1
        with:
          chat_id: ${{ secrets.BOTTOKEN }}
          bot_token: ${{ secrets.CHAT_ID }}
          message_thread_id: ${{ secrets.THREAD_ID }}
          message: ${{ steps.generate_success_message.outputs.message }}

  notify_failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: build_and_deploy
    if: ${{ needs.build_and_deploy.result != 'success' }}
    steps:
      - name: Generate failure message
        id: generate_error_message
        run: |
          echo '❌ **Deploy Failed!**' > telegram_message_error.txt
          echo '' >> telegram_message_error.txt
          echo '📦 **${{env.PACKAGE_NAME}}** deploy failed!' >> telegram_message_error.txt
          echo '- Repository: ${{ github.repository }}' >> telegram_message_error.txt
          echo '- Triggered by: ${{ github.actor }}' >> telegram_message_error.txt
          echo '- Commit: ${{ github.sha }}' >> telegram_message_error.txt
          echo '' >> telegram_message_error.txt
          echo '🔍 **Debug Information:**' >> telegram_message_error.txt
          echo '' >> telegram_message_error.txt
          echo '- Build Status: ${{ needs.build_and_deploy.result }}' >> telegram_message_error.txt
          echo '- Commit URL: https://github.com/${{ github.repository }}/commit/${{ github.sha }}' >> telegram_message_error.txt
          echo '⚠️ [Check GitHub Actions Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})' >> telegram_message_error.txt
          echo '' >> telegram_message_error.txt
          echo '🔍 **Failure Summary:**' >> telegram_message_error.txt
          
          MESSAGE=$(cat telegram_message_error.txt)
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send Telegram notification on failure
        if: ${{ needs.build_and_deploy.result != 'success' }}
        uses: an3park/telegram-action@v1
        with:
          chat_id: ${{ secrets.BOTTOKEN }}
          bot_token: ${{ secrets.CHAT_ID }}
          message_thread_id: ${{ secrets.THREAD_ID }}
          message: ${{ steps.generate_error_message.outputs.message }}
