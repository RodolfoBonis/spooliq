name: Prepare Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (leave empty for auto-increment)'
        required: false
        type: string
      increment_type:
        description: 'Auto-increment type (used if version is empty)'
        required: false
        default: 'minor'
        type: choice
        options:
          - major
          - minor
          - patch
      from_branch:
        description: 'Source branch'
        required: true
        default: 'develop'
        type: choice
        options:
          - develop
          - main

permissions:
  contents: write
  pull-requests: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.from_branch }}
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Determine version
        id: determine-version
        run: |
          if [ -z "${{ inputs.version }}" ]; then
            echo "No version provided, auto-incrementing..."
            
            # Get current version from version.txt or last tag
            if [ -f version.txt ]; then
              CURRENT_VERSION=$(cat version.txt | tr -d '\n' | tr -d ' ')
            else
              # Try to get from last tag
              LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
              CURRENT_VERSION=${LAST_TAG#v}
            fi
            
            echo "Current version: $CURRENT_VERSION"
            
            # Parse version components
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Increment based on type
            case "${{ inputs.increment_type }}" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            echo "Auto-incremented to: $NEW_VERSION"
          else
            NEW_VERSION="${{ inputs.version }}"
            echo "Using provided version: $NEW_VERSION"
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Sync with main branch
        run: |
          echo "Fetching main branch..."
          git fetch origin main

          echo "Merging main into ${{ inputs.source_branch }}..."
          git merge origin/main --no-edit -m "chore: sync with main before release" || {
            echo "Merge conflict detected. Auto-resolving by preferring main's version..."
            # Auto-resolve conflicts by preferring main's versions of version.txt and CHANGELOG.md
            git checkout --theirs version.txt CHANGELOG.md 2>/dev/null || true
            git add version.txt CHANGELOG.md 2>/dev/null || true
            git commit -m "chore: sync with main before release (auto-resolved)" || true
          }

          echo "Sync with main completed successfully"

      - name: Create release branch
        run: |
          RELEASE_BRANCH="release/v${{ steps.determine-version.outputs.version }}"
          git checkout -b $RELEASE_BRANCH
          echo "RELEASE_BRANCH=$RELEASE_BRANCH" >> $GITHUB_ENV

      - name: Update version file
        run: |
          echo "${{ steps.determine-version.outputs.version }}" > version.txt
          git add version.txt
          git commit -m "chore: bump version to ${{ steps.determine-version.outputs.version }}"

      - name: Generate CHANGELOG
        id: changelog
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous tags found, generating full changelog"
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            echo "Generating changelog since $LAST_TAG"
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # Create or update CHANGELOG.md
          {
            echo "# Changelog"
            echo ""
            echo "## v${{ steps.determine-version.outputs.version }} - $(date +%Y-%m-%d)"
            echo ""
            echo "### Changes"
            echo "$COMMITS"
            echo ""
            if [ -f CHANGELOG.md ]; then
              # Append existing changelog content (skip the first line)
              tail -n +2 CHANGELOG.md 2>/dev/null || true
            fi
          } > CHANGELOG_NEW.md
          
          mv CHANGELOG_NEW.md CHANGELOG.md
          
          # Store for PR body
          {
            echo "CHANGELOG<<EOF"
            echo "### üìã Changes in v${{ steps.determine-version.outputs.version }}"
            echo ""
            echo "$COMMITS"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Commit CHANGELOG
        run: |
          git add CHANGELOG.md
          git diff --staged --quiet || git commit -m "docs: update CHANGELOG for v${{ steps.determine-version.outputs.version }}"

      - name: Create and push tag
        run: |
          TAG="v${{ steps.determine-version.outputs.version }}"

          echo "Creating tag $TAG..."
          git tag -a "$TAG" -m "Release $TAG"

          echo "Pushing tag and branch..."
          git push origin ${{ env.RELEASE_BRANCH }}
          git push origin "$TAG"

          echo "‚úì Tag $TAG created and pushed"
          echo "‚úì Branch ${{ env.RELEASE_BRANCH }} pushed"

      - name: Ensure labels exist
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Create release label if it doesn't exist
          gh label create "release" \
            --description "Release preparation and deployment" \
            --color "0052CC" \
            --force 2>/dev/null || true

          # Create automated label if it doesn't exist
          gh label create "automated" \
            --description "Automatically created by workflows" \
            --color "E99695" \
            --force 2>/dev/null || true

          # Create backport label if it doesn't exist
          gh label create "backport" \
            --description "Backport changes to other branches" \
            --color "FBCA04" \
            --force 2>/dev/null || true

          echo "‚úì Labels ensured"

      - name: Create Pull Request to main
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          SNAPSHOT_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          EXPECTED_COMPLETION=$(date -u -d '+8 hours' +"%Y-%m-%d %H:%M:%S UTC")

          PR_URL=$(gh pr create \
            --base main \
            --head ${{ env.RELEASE_BRANCH }} \
            --title "üöÄ Release v${{ steps.determine-version.outputs.version }}" \
            --body "$(cat <<EOF
          ## üéØ Quick Release v${{ steps.determine-version.outputs.version }}

          This PR prepares release **v${{ steps.determine-version.outputs.version }}** for production deployment.

          ### üì∏ Develop Snapshot
          ‚úì Tag \`v${{ steps.determine-version.outputs.version }}\` created
          ‚úì Snapshot of \`${{ inputs.from_branch }}\` branch at: **${SNAPSHOT_TIME}**

          ‚ö†Ô∏è **FEATURE CUTOFF ACTIVE**
          Features merged to develop AFTER this snapshot will go to the **next release**.

          ${{ env.CHANGELOG }}

          ### ‚è±Ô∏è Quick Release Timeline (Target: 2-8 hours)
          - [x] Snapshot created & tag pushed
          - [x] Staging deployment (check below)
          - [ ] QA validation in staging (2-4h)
          - [ ] PR approval & merge to main
          - [ ] Production deployment (automatic)
          - [ ] Backport to develop (automatic)

          **Expected completion:** ${EXPECTED_COMPLETION}

          ### üß™ Staging Environment
          Staging deployment triggered automatically.
          Check the Actions tab for deployment status.

          ### üìù Release Checklist
          - [ ] Version bumped to v${{ steps.determine-version.outputs.version }}
          - [ ] CHANGELOG.md updated
          - [ ] All CI tests passing
          - [ ] Staging deployment successful
          - [ ] QA validation complete
          - [ ] Breaking changes documented (if any)
          - [ ] No sensitive data included

          ### üîÑ Post-merge Actions (Automatic)
          1. **Production deployment** via release.yaml (triggered by post-merge-release.yaml)
          2. **ArgoCD sync** to production cluster
          3. **Backport PR** created to develop with auto-merge
          4. **GitHub Release** created with artifacts
          5. **Team notification** via Telegram/n8n

          ### ‚ö†Ô∏è Important Notes
          - **Tag already created:** \`v${{ steps.determine-version.outputs.version }}\`
          - **Feature cutoff:** New features will go to next release
          - **No auto-merge:** This PR requires manual approval
          - **Quick cycle:** Target completion in 8 hours

          ---
          *Automated quick release - develop = next release model*
          EOF
          )" \
            --label "release" \
            --label "automated")

          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "‚úì PR created: $PR_URL"

      - name: Trigger staging deployment
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "Triggering staging deployment for release branch..."

          gh workflow run release-staging.yaml \
            --ref ${{ env.RELEASE_BRANCH }} || echo "Staging deployment will trigger automatically on push"

          echo "‚úì Staging deployment triggered (or will trigger on push)"

      - name: Notify n8n
        if: success()
        run: |
          EXPECTED_COMPLETION=$(date -u -d '+8 hours' +"%Y-%m-%dT%H:%M:%SZ")

          curl -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Authorization: Bearer ${{ secrets.N8N_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "event_type": "release_prepared",
              "repository": "${{ github.repository }}",
              "version": "v${{ steps.determine-version.outputs.version }}",
              "branch": "${{ env.RELEASE_BRANCH }}",
              "actor": "${{ github.actor }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "details": {
                "pr_url": "${{ steps.create-pr.outputs.pr_url }}",
                "from_branch": "${{ inputs.from_branch }}",
                "tag_created": true,
                "staging_triggered": true,
                "expected_completion": "'"$EXPECTED_COMPLETION"'",
                "feature_cutoff": true,
                "quick_release": true
              },
              "telegram_chat_id": "${{ secrets.CHAT_ID }}",
              "telegram_thread_id": "${{ secrets.THREAD_ID }}",
              "telegram_message": "üöÄ Release v${{ steps.determine-version.outputs.version }} prepared!\n\n‚ö†Ô∏è FEATURE CUTOFF: New features ‚Üí next release\n‚è±Ô∏è Target: 8h\nüß™ Staging: deploying\nüìã PR: ${{ steps.create-pr.outputs.pr_url }}"
            }' || echo "Notification failed (non-critical)"