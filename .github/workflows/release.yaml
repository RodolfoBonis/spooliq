name: Release with GoReleaser

permissions:
  contents: write
  pull-requests: write

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v2.1.0)'
        required: true
        type: string
      version:
        description: 'Version without v prefix (e.g., 2.1.0)'
        required: true
        type: string

concurrency:
  group: release-production
  cancel-in-progress: false

env:
  GO_VERSION: '1.23'

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      tag: ${{ steps.validate.outputs.tag }}
    steps:
      - name: Checkout tag
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.tag }}
          fetch-depth: 0

      - name: Validate version consistency
        id: validate
        run: |
          # Extract version from inputs
          INPUT_VERSION="${{ inputs.version }}"
          INPUT_TAG="${{ inputs.tag }}"

          # Read version from version.txt
          FILE_VERSION=$(cat version.txt | tr -d '\n' | tr -d ' ')

          # Verify tag format
          if [[ ! "$INPUT_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Tag must be in format v1.2.3"
            echo "Got: $INPUT_TAG"
            exit 1
          fi

          # Extract version from tag
          TAG_VERSION=${INPUT_TAG#v}

          # Verify input version matches tag version
          if [ "$INPUT_VERSION" != "$TAG_VERSION" ]; then
            echo "ERROR: Input version ($INPUT_VERSION) doesn't match tag version ($TAG_VERSION)"
            exit 1
          fi

          # Verify file version matches tag version
          if [ "$TAG_VERSION" != "$FILE_VERSION" ]; then
            echo "ERROR: Tag version ($TAG_VERSION) doesn't match version.txt ($FILE_VERSION)"
            echo ""
            echo "This means the tag was created with the wrong version!"
            echo "Expected: $FILE_VERSION"
            echo "Got: $TAG_VERSION"
            exit 1
          fi

          # All validations passed
          echo "version=$INPUT_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$INPUT_TAG" >> $GITHUB_OUTPUT

          echo "âœ“ Version validated: $INPUT_VERSION"
          echo "âœ“ Tag validated: $INPUT_TAG"
          echo "âœ“ version.txt matches: $FILE_VERSION"

  release:
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout tag
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.tag }}
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set lowercase repository owner
        id: repo-owner
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "lowercase=$REPO_OWNER" >> $GITHUB_OUTPUT

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPOSITORY_OWNER: ${{ steps.repo-owner.outputs.lowercase }}

      - name: Checkout k3s manifest repository
        uses: actions/checkout@master
        with:
          repository: RodolfoBonis/k3s-apps
          ref: main
          path: k3s-manifest
          token: ${{ secrets.GH_TOKEN }}

      - name: Update K3s Manifests
        env:
          VERSION: ${{ needs.validate.outputs.version }}
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPOSITORY_OWNER: ${{ steps.repo-owner.outputs.lowercase }}
        run: |
          cd k3s-manifest

          # Update Helm values for production
          yq e -i ".image.tag = \"${VERSION}\"" \
            ./apps/spooliq/app/chart/values-prod.yaml

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add ./apps/spooliq/app/chart/values-prod.yaml
          git commit -m "feat: update spooliq production to v${VERSION}"
          git push

      - name: Setup ArgoCD CLI
        uses: imajeetyadav/argocd-cli@v1

      - name: Sync ArgoCD
        run: |
          argocd app sync spooliq-app-prod \
            --grpc-web \
            --server ${{ secrets.ARGOCD_SERVER }} \
            --auth-token ${{ secrets.ARGOCD_TOKEN }}

      - name: Calculate Build Duration
        id: build-duration
        run: |
          START_TIME="${{ github.event.head_commit.timestamp }}"
          if [ -z "$START_TIME" ] || [ "$START_TIME" = "null" ]; then
            START_TIME="${{ github.event.repository.pushed_at }}"
          fi
          if [ -z "$START_TIME" ] || [ "$START_TIME" = "null" ]; then
            # Fallback: use workflow start time (approximate)
            START_TIME=$(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%SZ)
          fi

          END_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Calculate duration in seconds using date command
          START_EPOCH=$(date -d "$START_TIME" +%s)
          END_EPOCH=$(date -d "$END_TIME" +%s)
          DURATION_SECONDS=$((END_EPOCH - START_EPOCH))

          # Convert to human readable format
          if [ $DURATION_SECONDS -lt 60 ]; then
            DURATION="${DURATION_SECONDS}s"
          elif [ $DURATION_SECONDS -lt 3600 ]; then
            MINUTES=$((DURATION_SECONDS / 60))
            SECONDS=$((DURATION_SECONDS % 60))
            DURATION="${MINUTES}m ${SECONDS}s"
          else
            HOURS=$((DURATION_SECONDS / 3600))
            MINUTES=$(((DURATION_SECONDS % 3600) / 60))
            SECONDS=$((DURATION_SECONDS % 60))
            DURATION="${HOURS}h ${MINUTES}m ${SECONDS}s"
          fi

          echo "duration=$DURATION" >> $GITHUB_OUTPUT

      - name: Notify n8n Success
        if: success()
        run: |
          DOCKER_IMAGE="${{ steps.ecr.outputs.registry }}/${{ steps.repo-owner.outputs.lowercase }}/spooliq:${{ needs.validate.outputs.version }}"
          curl -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Authorization: Bearer ${{ secrets.N8N_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "event_type": "deploy_success",
              "repository": "${{ github.repository }}",
              "workflow": "${{ github.workflow }}",
              "commit_sha": "${{ github.sha }}",
              "tag": "${{ needs.validate.outputs.tag }}",
              "branch": "${{ github.ref }}",
              "actor": "${{ github.actor }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "details": {
                "docker_image": "'$DOCKER_IMAGE'",
                "argocd_sync": "success",
                "build_time": "${{ steps.build-duration.outputs.duration }}",
                "release_url": "https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate.outputs.tag }}"
              },
              "telegram_chat_id": "${{ secrets.CHAT_ID }}",
              "telegram_thread_id": "${{ secrets.THREAD_ID }}"
            }'

      - name: Notify n8n Failure
        if: failure()
        run: |
          curl -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Authorization: Bearer ${{ secrets.N8N_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "event_type": "deploy_failure",
              "repository": "${{ github.repository }}",
              "workflow": "${{ github.workflow }}",
              "commit_sha": "${{ github.sha }}",
              "tag": "${{ needs.validate.outputs.tag }}",
              "branch": "${{ github.ref }}",
              "actor": "${{ github.actor }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "details": {
                "error_message": "GoReleaser deployment failed - check GitHub Actions logs",
                "logs_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                "job_status": "${{ job.status }}"
              },
              "telegram_chat_id": "${{ secrets.CHAT_ID }}",
              "telegram_thread_id": "${{ secrets.THREAD_ID }}"
            }'

  backport:
    needs: [validate, release]
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}

      - name: Ensure labels exist
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Create backport label if it doesn't exist
          gh label create "backport" \
            --description "Backport changes to other branches" \
            --color "FBCA04" \
            --force 2>/dev/null || true

          # Create automated label if it doesn't exist
          gh label create "automated" \
            --description "Automatically created by workflows" \
            --color "E99695" \
            --force 2>/dev/null || true

          # Create auto-merge label if it doesn't exist
          gh label create "auto-merge" \
            --description "Automatically merge when approved" \
            --color "0E8A16" \
            --force 2>/dev/null || true

      - name: Create backport to develop
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Setup git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Fetch all branches
          git fetch origin develop:develop

          # Get the release version
          VERSION="${{ needs.validate.outputs.version }}"
          TAG="${{ needs.validate.outputs.tag }}"

          # Create backport branch from develop
          BACKPORT_BRANCH="backport/${TAG}-to-develop"
          git checkout -b $BACKPORT_BRANCH develop

          # Merge main into the backport branch
          git merge origin/main --no-ff -m "chore: backport ${TAG} to develop" || {
            echo "Merge conflict detected"
            echo "This requires manual intervention"
            exit 1
          }

          # Push the backport branch
          git push origin $BACKPORT_BRANCH

          # Create PR with auto-merge label
          gh pr create \
            --base develop \
            --head $BACKPORT_BRANCH \
            --title "ðŸ”„ Backport ${TAG} to develop" \
            --body "$(cat <<'EOF'
          ## Automated Backport

          This PR backports release **${TAG}** from main to develop.

          ### Changes Included
          - Version bump to $VERSION
          - CHANGELOG updates
          - All features and fixes from the release

          ### Auto-merge
          This PR is labeled for auto-merge and will be merged automatically after:
          - âœ“ All CI checks pass
          - âœ“ No merge conflicts

          If there are conflicts, manual resolution is required.

          ---
          *Automated by release workflow*
          EOF
          )" \
            --label "backport" \
            --label "automated" \
            --label "auto-merge" || echo "PR creation failed or already exists"

      - name: Notify n8n backport created
        if: success()
        run: |
          curl -X POST "${{ secrets.N8N_WEBHOOK_URL }}" \
            -H "Authorization: Bearer ${{ secrets.N8N_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "event_type": "backport_created",
              "repository": "${{ github.repository }}",
              "version": "${{ needs.validate.outputs.tag }}",
              "actor": "${{ github.actor }}",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "details": {
                "target_branch": "develop",
                "auto_merge": true
              },
              "telegram_chat_id": "${{ secrets.CHAT_ID }}",
              "telegram_thread_id": "${{ secrets.THREAD_ID }}"
            }' || echo "Notification failed (non-critical)"
